<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty(笔记)</title>
      <link href="/2020/01/16/Netty-%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/16/Netty-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="业界哪些流行的开源框架用Netty作为底层通信框架"><a class="header-anchor" href="#业界哪些流行的开源框架用Netty作为底层通信框架"></a>业界哪些流行的开源框架用Netty作为底层通信框架</h2><ul><li>Dubbo： 阿里开源的高性能RPC框架</li><li>RocketMQ： 阿里出品的高性能消息队列</li><li>Spark： 炙手可热的大数据处理引擎，底层使用Netty</li><li>Elasticsearch： 分布式多用户的全文搜索引擎</li><li>Apache Cassandra：开源分布式搜索数据库</li><li>Flink:分布式高性能高可用的流处理框架</li><li>Netty-SocketIO的java服务端实现</li><li>Spring5：使用Netty作为http协议框架</li><li>Play：简单易用的http服务器</li><li>Grpc:google开源的高性能rpc通信框架</li><li>Infinispan：针对缓存的高并发键值对数据存储</li><li>HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统</li><li>Vert.x轻量级高性能能JVM应用平台<br>-<br><a href="https://netty.io/wiki/adopters.html" target="_blank" rel="noopener">完整的参考列表</a></li></ul><h2 id="业界有哪些公司在使用Netty"><a class="header-anchor" href="#业界有哪些公司在使用Netty"></a>业界有哪些公司在使用Netty</h2><p><strong>在大型企业中</strong>有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram<br><br><strong>在初创企业中</strong>有：做http长连接的<strong>Firebase</strong>、支持各种各样消息推送通知的<strong>Urban Airship</strong><br><br><br> 当然，Netty也从这些项目中<strong>受益</strong>。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。</p><h2 id="Netty是什么"><a class="header-anchor" href="#Netty是什么"></a>Netty是什么</h2><ol><li><strong>异步</strong>和<strong>事件驱动</strong>的高性能网络通信框架。</li><li>**特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。</li><li>**目的:**用于快速开发高性能服务端和客户端</li><li>**封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易</li><li>自带编解码器解决拆包粘包问题，用户只关心业务逻辑</li><li>精心设计的reactor线程模型支持高并发海量连接</li><li>自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手</li><li>**架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离–业务和网络逻辑解耦，模块化和可复用性，可测试性。</li></ol><h2 id="Netty的特性总结"><a class="header-anchor" href="#Netty的特性总结"></a>Netty的特性总结</h2><p><img src="https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim" alt="mark"></p><h2 id="Socket-Netty"><a class="header-anchor" href="#Socket-Netty"></a>Socket &amp; Netty</h2><p><img src="https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim" alt="Socket &amp; Netty"></p><h2 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h2><p><img src="https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim" alt="mark"></p><ul><li>NioEventLoop -&gt;Thread</li><li>Channel -&gt;Socket  <br>NioSocketChannel implements Channel<br>Chennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind</li><li>ByteBuf -&gt;IO Bytes<br>readBytes()、writeBytes() and so on</li><li>Pipline -&gt;Logic Chain 逻辑链</li><li>ChannelHandler -&gt;Logic处理块</li></ul><h2 id="Netty核心组件"><a class="header-anchor" href="#Netty核心组件"></a>Netty核心组件</h2><h3 id="1-Channel-Socket"><a class="header-anchor" href="#1-Channel-Socket"></a>1. Channel-Socket</h3><p>Channel是通讯的载体，其基本构造是Socket<br>是对网络底层读写和连接原语言的抽象</p><h3 id="2-EventLoop-控制流、多线程处理、并发"><a class="header-anchor" href="#2-EventLoop-控制流、多线程处理、并发"></a>2. EventLoop-控制流、多线程处理、并发</h3><p>定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件</p><h3 id="注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"><a class="header-anchor" href="#注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"></a>注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系</h3><p><img src="https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim" alt="mark">)</p><h5 id="A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"><a class="header-anchor" href="#A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"></a>A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；</h5><h5 id="B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"><a class="header-anchor" href="#B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"></a>B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定</h5><h5 id="C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"><a class="header-anchor" href="#C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"></a>C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</h5><h5 id="D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"><a class="header-anchor" href="#D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"></a>D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；</h5><h5 id="E-一个-EventLoop-可能会被分配给一个或多个-Channel"><a class="header-anchor" href="#E-一个-EventLoop-可能会被分配给一个或多个-Channel"></a>E. 一个 EventLoop 可能会被分配给一个或多个 Channel</h5><h5 id="F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"><a class="header-anchor" href="#F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"></a>F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。</h5><h3 id="3-ChannelFuture-异步通知"><a class="header-anchor" href="#3-ChannelFuture-异步通知"></a>3. ChannelFuture-异步通知</h3><p>Netty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法</p><h3 id="4-ChannelHandler和ChannelPipeline"><a class="header-anchor" href="#4-ChannelHandler和ChannelPipeline"></a>4. ChannelHandler和ChannelPipeline</h3><p>ChannelHandler负责Channel中的逻辑处理<br>其旨在简化应用程序处理逻辑的开发过程<br>充当了所有处理入站和出站数据的应用程序逻辑的容器<br>ChannelHandler子接口：<br>ChannelInboundHandler——处理入站数据以及各种状态变化<br>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作<br>ChannelInboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim" alt="mark"><br>ChannelOutboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim" alt="mark"></p><p>ChannelPipeline 提供了 ChannelHandler链的容器<br>定义了用于在该链上传播入站和出站事件流的API</p><h3 id="5-ByteBuf-Netty的数据容器"><a class="header-anchor" href="#5-ByteBuf-Netty的数据容器"></a>5. ByteBuf-Netty的数据容器</h3><p>Java NIO提供了ByteBuffer作为它的字节容器<br>Netty的ByteBuffer替代品是ByteBuf</p><h5 id="A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"><a class="header-anchor" href="#A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"></a>A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；</h5><h5 id="B-容量可以按需增长（类似于-JDK-的-StringBuilder）"><a class="header-anchor" href="#B-容量可以按需增长（类似于-JDK-的-StringBuilder）"></a>B.容量可以按需增长（类似于 JDK 的 StringBuilder）</h5><h5 id="C-读和写使用了不同的索引"><a class="header-anchor" href="#C-读和写使用了不同的索引"></a>C.读和写使用了不同的索引</h5><h5 id="D-支持方法的链式调用"><a class="header-anchor" href="#D-支持方法的链式调用"></a>D.支持方法的链式调用</h5><h5 id="E-支持引用计数"><a class="header-anchor" href="#E-支持引用计数"></a>E.支持引用计数</h5><h5 id="F-支持池化"><a class="header-anchor" href="#F-支持池化"></a>F.支持池化</h5><h3 id="6-Bootstap-引导客户端和无连接协议"><a class="header-anchor" href="#6-Bootstap-引导客户端和无连接协议"></a>6. Bootstap-引导客户端和无连接协议</h3><p>Bootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel<br><img src="http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg" alt></p><h2 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h2><p>使用EmbeddedChannel 测试 ChannelHandler</p><ol><li>测试入站消息</li><li>测试出站消息</li><li>测试异常处理</li></ol><h2 id="编解码器"><a class="header-anchor" href="#编解码器"></a>编解码器</h2><ul><li>解码器<br>将字节解码为消息<br>将一种消息类型解码为另一种</li><li>编码器<br>将消息编码为字节<br>将消息编码为消息</li></ul><h2 id="Netty服务端启动"><a class="header-anchor" href="#Netty服务端启动"></a>Netty服务端启动</h2><ol><li>创建服务端Channel</li><li>初始化服务端Channel</li><li>注册Selector</li><li>端口绑定，实现对本地端口的接听</li></ol><h2 id="预置的ChannelHandler和编解码器"><a class="header-anchor" href="#预置的ChannelHandler和编解码器"></a>预置的ChannelHandler和编解码器</h2><ol><li>通过 SSL/TLS 保护 Netty 应用程序</li><li>ChannelHandler处理 HTTP 和 HTTPS协议</li><li>支持WebSocket</li><li>ChannelHandler检测空闲连接以及超时</li><li>FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域</li><li>使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据</li><li>使用UDP广播事件</li></ol><h3 id="创建服务端Channel"><a class="header-anchor" href="#创建服务端Channel"></a>创建服务端Channel</h3><p><strong>bind()[用户代码入口] -&gt;initAndRegister()[初始化并注册] -&gt;newChannel()[创建服务端channel]</strong><br><img src="https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim" alt="mark"></p><h2 id="如何使用Netty进行RPC服务器的开发"><a class="header-anchor" href="#如何使用Netty进行RPC服务器的开发"></a>如何使用Netty进行RPC服务器的开发?</h2><ol><li>定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</li><li>服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</li><li>客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</li><li>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</li><li>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。<br><img src="https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim" alt="mark"> <strong>客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。</strong><br>Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</li><li><img src="https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim" alt="mark"><br><strong>客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</strong></li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="Netty疑问"><a class="header-anchor" href="#Netty疑问"></a>Netty疑问</h3><ol><li>Netty是什么？<br>Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。</li><li>使用Netty能够做什么？<br>①开发异步、非阻塞的TCP网络应用程序；<br>②开发异步、非阻塞的UDP网络应用程序；<br>③开发异步文件传输应用程序；<br>④开发异步HTTP服务端和客户端应用程序；<br>⑤提供对多种编解码框架的集成；<br>⑥提供形式多样的编解码基础类库；<br>⑦基于职责链模式的Pipeline-Handler机制；<br>⑧所有的IO操作都是异步的；<br>⑨IP黑白名单控制，性能统计；<br>⑩基于链路空闲事件检测的心跳检测；</li><li>Netty在哪些行业得到了应用<br>**①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。<br>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。<br>除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。<br>**②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。<br>**③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。<br>**④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。<br>**⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。</li><li>使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？<br>传统的同步阻塞IO通信存在如下几个问题：<br>**①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>**②性能差：**频繁的线程上下文切换导致CPU利用效率不高；<br>**③可靠性差：*<em>由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br><strong>采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：</strong><br>①Nio采用Reactor模式</em>，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N &lt; 进程可用的最大句柄数)；<br>②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；<br>③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。<br><strong>由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。</strong></li><li>为什么不直接基于JDK的NIO类库编程呢？<br>即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。</li><li>为什么要选择Netty框架？<br>Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。<br>Netty的优点总结如下：<br>①API使用简单，开发门槛低；<br>②功能强大，预置了多种编解码功能，支持多种主流协议；<br>③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；<br>④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；<br>⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；<br>⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；<br>⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。</li></ol><h2 id="代码"><a class="header-anchor" href="#代码"></a>代码</h2><h3 id="1-基于Netty的客户端和服务端的简单通信"><a class="header-anchor" href="#1-基于Netty的客户端和服务端的简单通信"></a>1. 基于Netty的客户端和服务端的简单通信</h3><h5 id="要点："><a class="header-anchor" href="#要点："></a>要点：</h5><p>①为初始化客户端， 创建了一个 Bootstrap 实例<br>②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；<br>③为服务器连接创建了一个 InetSocketAddress 实例；<br>④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；<br>⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；<br><img src="https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim" alt="mark"></p><h3 id="EchoServerHandler"><a class="header-anchor" href="#EchoServerHandler"></a>EchoServerHandler</h3><h5 id="channelRead-—对于每个传入的消息都要调用；"><a class="header-anchor" href="#channelRead-—对于每个传入的消息都要调用；"></a>channelRead()—对于每个传入的消息都要调用；</h5><h5 id="channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"><a class="header-anchor" href="#channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"></a>channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；</h5><h5 id="exceptionCaught-—在读取操作期间，有异常抛出时会调用。"><a class="header-anchor" href="#exceptionCaught-—在读取操作期间，有异常抛出时会调用。"></a>exceptionCaught()—在读取操作期间，有异常抛出时会调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标示一个ChannelHandler可以被多个 Channel 安全地共享</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//将消息记录到控制台</span></span><br><span class="line">        System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">//将接收到的消息写给发送者，而不冲刷出站消息</span></span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将未决消息冲刷到远程节点，并且关闭该 Channel</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印异常栈跟踪</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="comment">//关闭该Channel</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EchoServer"><a class="header-anchor" href="#EchoServer"></a>EchoServer</h3><h5 id="绑定到服务器将在其上监听并接受传入连接请求的端口；"><a class="header-anchor" href="#绑定到服务器将在其上监听并接受传入连接请求的端口；"></a>绑定到服务器将在其上监听并接受传入连接请求的端口；</h5><h5 id="配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"><a class="header-anchor" href="#配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"></a>配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoServer.class.getSimpleName() +<span class="string">" &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span></span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//调用服务器的 start()方法</span></span><br><span class="line">        <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="comment">//(1) 创建EventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//(2) 创建ServerBootstrap</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//(3) 指定所使用的 NIO 传输 Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//(4) 使用指定的端口设置套接字地址</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    <span class="comment">//(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例</span></span><br><span class="line">                            <span class="comment">//这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，</span></span><br><span class="line">                            ch.pipeline().addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成</span></span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            System.out.println(EchoServer.class.getName() +</span><br><span class="line">                    <span class="string">" started and listening for connections on "</span> + f.channel().localAddress());</span><br><span class="line">            <span class="comment">//(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//(8) 关闭 EventLoopGroup，释放所有的资源</span></span><br><span class="line">            grop.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-ChannelHandler-实现客户端逻辑"><a class="header-anchor" href="#通过-ChannelHandler-实现客户端逻辑"></a>通过 ChannelHandler 实现客户端逻辑</h3><h5 id="channelActive-——在到服务器的连接已经建立之后将被调用；"><a class="header-anchor" href="#channelActive-——在到服务器的连接已经建立之后将被调用；"></a>channelActive()——在到服务器的连接已经建立之后将被调用；</h5><h5 id="channelRead0-——当服务器接收到一条消息时被调用"><a class="header-anchor" href="#channelRead0-——当服务器接收到一条消息时被调用"></a>channelRead0()——当服务器接收到一条消息时被调用</h5><h5 id="exceptionCaught-——在处理过程中引发异常时被调用。"><a class="header-anchor" href="#exceptionCaught-——在处理过程中引发异常时被调用。"></a>exceptionCaught()——在处理过程中引发异常时被调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="comment">//标记该类的实例可以被多个 Channel 共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当被通知 Channel是活跃的时候，发送一条消息</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty rocks!"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录已接收消息的转储</span></span><br><span class="line">        System.out.println(<span class="string">"Client received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在发生异常时，记录错误并关闭Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导客户端"><a class="header-anchor" href="#引导客户端"></a>引导客户端</h3><h5 id="客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"><a class="header-anchor" href="#客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"></a>客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建 Bootstrap</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现</span></span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//适用于 NIO 传输的Channel 类型</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置服务器的InetSocketAddress</span></span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">                    <span class="comment">//在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(</span><br><span class="line">                                    <span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//连接到远程节点，阻塞等待直到连接完成</span></span><br><span class="line">            ChannelFuture f = b.connect().sync();</span><br><span class="line">            <span class="comment">//阻塞，直到Channel 关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池并且释放所有的资源</span></span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() +</span><br><span class="line">                    <span class="string">" &lt;host&gt; &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"><a class="header-anchor" href="#2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"></a>2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架</h3><h5 id="简易RPC有如下特性："><a class="header-anchor" href="#简易RPC有如下特性："></a>简易RPC有如下特性：</h5><ul><li>服务异步调用的支持，回调函数callback的支持</li><li>客户端使用长连接（在多次调用共享连接）</li><li>服务端异步多线程处理RPC请求</li><li>服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。</li><li>通信：使用Netty作为通信框架</li><li>Spring：使用Spring配置服务，加载Bean，扫描注解</li><li>动态代理：客户端使用代理模式透明化服务调用</li><li>消息编解码：使用Protostuff序列化和反序列化消息</li></ul><h5 id="RPC介绍"><a class="header-anchor" href="#RPC介绍"></a>RPC介绍</h5><p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。</p><p><img src="https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim" alt="mark"></p><ul><li>服务端发布服务</li></ul><h5 id="服务注解："><a class="header-anchor" href="#服务注解："></a>服务注解：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务接口："><a class="header-anchor" href="#一个服务接口："></a>一个服务接口：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">hello</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务实现：使用注解标注："><a class="header-anchor" href="#一个服务实现：使用注解标注："></a>一个服务实现：使用注解标注：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RpcService</span>(HelloService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + person.getFirstName() + <span class="string">" "</span> + person.getLastName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务在启动的时候扫描得到所有的服务接口及其实现："><a class="header-anchor" href="#服务在启动的时候扫描得到所有的服务接口及其实现："></a>服务在启动的时候扫描得到所有的服务接口及其实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">      <span class="keyword">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class="line">            handlerMap.put(interfaceName, serviceBean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="在Zookeeper集群上注册服务地址："><a class="header-anchor" href="#在Zookeeper集群上注册服务地址："></a>在Zookeeper集群上注册服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedExceptin ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端使用代理模式调用服务："><a class="header-anchor" href="#客户端使用代理模式调用服务："></a>客户端使用代理模式调用服务：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Zookeeper上获取服务地址："><a class="header-anchor" href="#从Zookeeper上获取服务地址："></a>从Zookeeper上获取服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceDiscovery</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">        ZooKeeper zk = connectServer();</span><br><span class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">            watchNode(zk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = dataList.size();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">                data = dataList.get(<span class="number">0</span>);</span><br><span class="line">                LOGGER.debug(<span class="string">"using only data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class="line">                LOGGER.debug(<span class="string">"using random data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watchNode</span><span class="params">(<span class="keyword">final</span> ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        watchNode(zk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : nodeList) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class="string">"/"</span> + node, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                dataList.add(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(<span class="string">"node data: &#123;&#125;"</span>, dataList);</span><br><span class="line">            <span class="keyword">this</span>.dataList = dataList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterrupteException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息编码-请求消息："><a class="header-anchor" href="#消息编码-请求消息："></a>消息编码 请求消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameterTypes</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getParameters() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(Object[] parameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="响应消息："><a class="header-anchor" href="#响应消息："></a>响应消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息序列化和反序列化工具：（基于-Protostuff-实现）"><a class="header-anchor" href="#消息序列化和反序列化工具：（基于-Protostuff-实现）"></a>消息序列化和反序列化工具：（基于 Protostuff 实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Objenesis objenesis = <span class="keyword">new</span> ObjenesisStd(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializationUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Schema&lt;T&gt; <span class="title">getSchema</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class="line">        <span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</span><br><span class="line">            schema = RuntimeSchema.createFrom(cls);</span><br><span class="line">            <span class="keyword">if</span> (schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedSchema.put(cls, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化（对象 -&gt; 字节数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();</span><br><span class="line">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化（字节数组 -&gt; 对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T message = (T) objenesis.newInstance(cls);</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(data, message, schema);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStatexception(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能改进-服务端请求异步处理"><a class="header-anchor" href="#性能改进-服务端请求异步处理"></a>性能改进 服务端请求异步处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,<span class="keyword">final</span> RpcRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcServer.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                LOGGER.debug(<span class="string">"Receive request "</span> + request.getRequestId());</span><br><span class="line">                RpcResponse response = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                response.setRequestId(request.getRequestId());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object result = handle(request);</span><br><span class="line">                    response.setResult(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    response.setError(t.toString());</span><br><span class="line">                    LOGGER.error(<span class="string">"RPC Server handle request error"</span>,t);</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        LOGGER.debug(<span class="string">"Send response for request "</span> + request.getRequestId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="服务端长连接的管理"><a class="header-anchor" href="#服务端长连接的管理"></a>服务端长连接的管理</h5><p>客户端保持和服务进行<strong>长连接</strong>，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。<br>通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。</p><h5 id="客户端请求异步处理"><a class="header-anchor" href="#客户端请求异步处理"></a>客户端请求异步处理</h5><p><strong>客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);</span><br><span class="line">RPCFuture helloFuture = client.call(<span class="string">"hello"</span>, Integer.toString(i));</span><br><span class="line">String result = (String) helloFuture.get(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(上)</title>
      <link href="/2020/01/16/RocketMQ-%E4%B8%8A/"/>
      <url>/2020/01/16/RocketMQ-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RocketMQ-是什么"><a class="header-anchor" href="#1-RocketMQ-是什么"></a>1. RocketMQ 是什么</h2><h4 id="RocketMQ是一款、、、易于使用的消息中间件"><a class="header-anchor" href="#RocketMQ是一款、、、易于使用的消息中间件"></a>RocketMQ是一款<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、易于使用的消息中间件</h4><h4 id="RocketMQ具有以下特性"><a class="header-anchor" href="#RocketMQ具有以下特性"></a>RocketMQ具有以下特性</h4><ul><li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li><li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li><li>支持拉（pull）和推（push）两种消息模式</li><li>单一队列百万消息的堆积能力</li><li>支持多种消息协议，如 JMS、MQTT 等</li><li>分布式高可用的部署架构,满足至少一次消息传递语义</li><li>提供 docker 镜像用于隔离测试和云集群部署</li><li>提供配置、指标和监控等功能丰富的 Dashboard</li></ul><blockquote><h3 id="Producer"><a class="header-anchor" href="#Producer"></a>Producer</h3><p><strong>消息生产者</strong>，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。</p><h3 id="Producer-Group"><a class="header-anchor" href="#Producer-Group"></a>Producer Group</h3><p><strong>生产者组</strong>，就是多个发送同一类消息的生产者称之为一个生产者组。</p></blockquote><blockquote><h3 id="Consumer"><a class="header-anchor" href="#Consumer"></a>Consumer</h3><p><strong>消息消费者</strong>，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p><h3 id="Consumer-Group"><a class="header-anchor" href="#Consumer-Group"></a>Consumer Group</h3><p><strong>消费者组</strong>，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></blockquote><blockquote><h3 id="Topic"><a class="header-anchor" href="#Topic"></a>Topic</h3><p><em>Topic</em> 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推</p><h3 id="Message"><a class="header-anchor" href="#Message"></a>Message</h3><p><em>Message</em>是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p></blockquote><blockquote><h3 id="Tag"><a class="header-anchor" href="#Tag"></a>Tag</h3><p><em>Tag</em><strong>标签</strong>可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息</p><h3 id="Broker"><a class="header-anchor" href="#Broker"></a>Broker</h3><p><em>Broker</em>是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备</p><h3 id="Name-Server"><a class="header-anchor" href="#Name-Server"></a>Name Server</h3><p><em>Name Server</em> 为 producer 和 consumer 提供路由信息。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>响应时间低，比如一个网页在几秒内打开，越短表示延迟越低 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>指的是运行时间能够满足预计时间的一个系统或组件 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
