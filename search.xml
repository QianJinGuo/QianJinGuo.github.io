<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"/>
      <url>/2022/01/14/%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="字节数组"><a class="header-anchor" href="#字节数组"></a>字节数组</h1><p>#字节 #字节数组 #缓存</p><h1 id="字节属于最小单位"><a class="header-anchor" href="#字节属于最小单位"></a>字节属于最小单位</h1><p>例如在Java中，int占用4个字节，long占用8个字节等。基本上所有基本类型(包括String)都可以转换成字节，那么这到底有何作用。<br>在实际开发中，经常会用到本地缓存，或使用<code>Redis</code>或者<code>Memcached</code>来作分布式缓存,Java一般存入缓存中的对象无非是以下几种:</p><ul><li>序列化的Java对象：一个Java对象序列化后所占用的字节是按对象中属性个数，方法个数，以及属性的值决定，最小也需要几百个字节来存储，大的话可能需要几万个字节</li><li>String(可能是json串)：占用字节由字符串的长度决定</li><li>规则的byte[]数组：占用字节由数组长度决定，相比较于String来说，基本类型转换成固定字节的数组，而不是转换成内容长度的String，故字节数组所占用的字节比String更少</li></ul><blockquote><ol><li>在大量的缓存数据(亿级以上)的情况下，为了提高空间利用率，切勿将<strong>Java对象</strong>当做缓存的内容</li><li>字节数组所需空间最少</li></ol></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/665f4dd77f30" target="_blank" rel="noopener">字节数组的妙用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/01/14/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="线程中断"><a class="header-anchor" href="#线程中断"></a>线程中断</h1><p>#线程 #并发</p><h2 id="Thread类详解"><a class="header-anchor" href="#Thread类详解"></a>Thread类详解</h2><ul><li>interrupt</li><li>interrupted</li><li>isInterrupted</li><li>join</li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/xingele0917/p/3994468.html" target="_blank" rel="noopener">并发编程实践</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="线程执行顺序"><a class="header-anchor" href="#线程执行顺序"></a>线程执行顺序</h1><p>#线程 #jvm</p><h2 id="线程执行顺序-v2"><a class="header-anchor" href="#线程执行顺序-v2"></a>线程执行顺序</h2><blockquote><p>jvm为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证[^1]<br><code>1.《深入理解Java虚拟机：JVM高级特性与最佳实践》 — 周志明</code></p></blockquote><p>如果程序没有正确同步，那么可能会存在数据竞争。JMM对数据竞争的定义如下：</p><blockquote><p>在一个线程中写一个变量，在另一个线程中读取同一个变量，而且写和读没有通过同步来排序</p></blockquote><p>顺序一致性模型有以下<strong>两大特性</strong>：</p><ol><li>一个线程中的所有操作必须按照==程序的顺序==来执行</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致内存模型中，每一个操作都必须是原子执行且立即对所有线程可见。</li></ol><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以把顺序顺序一致模型理解为一个单摆，每一个时刻单摆只能到一个位置，对应过来，任何时刻最多只能有一个线程才能连接到内存。</span><br><span class="line">由于重排序的影响，实际指令的执行顺序是不可知的，但是不管如何排序，每个操作能够立即对其他线程可见，所以所有线程看到的都是一样的执行顺序。</span><br><span class="line">但是在JMM中是没有这个规定的，就是说其他线程看到执行顺序与除自己外的线程看到的执行顺序可能是不一致的。</span><br><span class="line">比如，当前线程把写过的数据缓存缓存到写缓存中，在没有刷新到主内存（计算机系统的DRAM）之前，这个写操作对其他线程是不可见的，意味着其他线程认为该线程根本没有执行写操作。</span><br><span class="line">那么何时才能可见呢？只有在当前线程把写缓存中数据刷新到主内存的时候，对其他内存才是可见的。</span><br></pre></td></tr></table></figure><p><strong>如何控制多线程的执行顺序</strong>？</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/hello_worldee/article/details/77823426" target="_blank" rel="noopener">多线程-重排序与顺序一致性</a><br>![[并发编程以及锁.pptx]]![[java多线程相关分享.pptx]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池实现原理"><a class="header-anchor" href="#线程池实现原理"></a>线程池实现原理</h1><p>#线程 #线程池 #并发</p><h2 id="线程池是什么"><a class="header-anchor" href="#线程池是什么"></a>线程池是什么</h2><p>线程池（Thread Pool）是一种基于==池化==思想管理线程的工具，经常出现在多线程服务器中，如MySQL。<br>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h2 id="线程池解决的问题是什么"><a class="header-anchor" href="#线程池解决的问题是什么"></a>线程池解决的问题是什么</h2><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。<br>为解决资源分配这个问题，线程池采用了“==池化==”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</li></ol><blockquote><p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p></blockquote><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。<br>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ol><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ol><h2 id="线程池核心设计与实现"><a class="header-anchor" href="#线程池核心设计与实现"></a>线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。</p><h2 id="线程池在业务中的实践"><a class="header-anchor" href="#线程池在业务中的实践"></a>线程池在业务中的实践</h2><p><strong>场景1：快速响应用户请求</strong><br><strong>场景2：快速处理批量任务</strong></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a><br><a href="https://www.cnblogs.com/xiaoxi/p/7692250.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98/"/>
      <url>/2022/01/14/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="先更新数据库还是先更新缓存"><a class="header-anchor" href="#先更新数据库还是先更新缓存"></a>先更新数据库还是先更新缓存</h1><p>#缓存  #redis #数据库</p><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><p>在系统中引入缓存后，当向数据库中写入数据时，是先写数据库还是先写缓存呢？先写数据库和先写缓存有什么区别吗？</p><blockquote><p>从本质上讲，无论是先写数据库还是先写缓存，都是为了保证数据库和缓存的数据一致，也就是我们常说的数据一致性。<br>随着互联网的高速发展，当今时代已然从IT时代进入到DT时代。互联网系统架构也已经由最初的单体架构转变为分布式、微服务架构模式。从数据体量上来看，各系统存储的数据量越来越大，数据的查询性能越来越低。此时，就需要我们不断的进行优化，一种常用的优化手段就是引入缓存。而引入缓存后，我们在向数据库插入数据时，到底是先更新数据库还是先更新缓存呢？</p></blockquote><h2 id="缓存的一般使用"><a class="header-anchor" href="#缓存的一般使用"></a>缓存的一般使用</h2><p>缓存，从本质上讲，是为了更好的协调两个速度差异比较大的组件而引入的一种中间缓存层。例如，如果需要将数据读入CPU进行计算处理，由于CPU的运算速度是非常快的，而磁盘的IO处理相比于CPU来说，慢了很多数量级，每次从磁盘读取数据，势会造成CPU长时间并且频繁等待磁盘IO。此时，我们就可以通过内存来缓和CPU和磁盘之间的速度差异。</p><h2 id="缓存更新策略"><a class="header-anchor" href="#缓存更新策略"></a>缓存更新策略</h2><p>从理论上来说，给缓存设置过期时间，其实是一中最终一致性的表现。这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。这也是一般情况下，使用的最多的一种方式。</p><h2 id="应用"><a class="header-anchor" href="#应用"></a>应用</h2><p>火车票中转</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://juejin.cn/post/6985187835145879588?utm_source=gold_browser_extension" target="_blank" rel="noopener">先更新数据库还是先更新缓存</a><br><a href="https://www.jianshu.com/p/dc1e5091a0d8" target="_blank" rel="noopener">Redis缓存双删</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%90%8C%E6%AD%A5%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E6%A0%87%E6%B3%A8/"/>
      <url>/2022/01/14/%E5%90%8C%E6%AD%A5%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E6%A0%87%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="同步注解与并发性标注"><a class="header-anchor" href="#同步注解与并发性标注"></a>同步注解与并发性标注</h1><p>#spring #注解 #线程</p><h2 id="同步注解"><a class="header-anchor" href="#同步注解"></a>同步注解</h2><ul><li>@GuardedBy( “this” ) 受对象内部锁保护</li><li>@GuardedBy( “fieldName” ) 受 与fieldName引用相关联的锁保护</li><li>@GuardedBy( “ClassName.fieldName” ) 受一个类的静态field的锁保护。</li><li>@GuardedBy( “methodName()” ) 锁对象是 methodName() 方法的返值，受这个锁保护。</li><li>@GuardedBy( “ClassName.class” ) 受 ClassName类的直接锁对象保护。而不是这个类的某个实例的锁对象。</li></ul><h2 id="并发性标注"><a class="header-anchor" href="#并发性标注"></a>并发性标注</h2><p>@GuardedBy @NotThreadSafe @ThreadSafe<br>这三个类级别的标注可以描述类的线程安全保证性,属于类公开文档的一部分.它只是标注了该类是否是线程安全的,但实际上没法保证线程安全.</p><ul><li>@Immutable<br>表示类是不可变得既是final修饰的,它是线程安全的</li><li>@ThreadSafe<br>类是线程安全的</li><li>@NotThreadSafe<br>类不是线程安全的，如果类未加任何注解，则不能确定是否线程安全，认为是非线程安全的</li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/u010870167/article/details/88059219" target="_blank" rel="noopener">并发性标注</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%BD%AF%E4%BB%B6/"/>
      <url>/2022/01/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="科学上网"><a class="header-anchor" href="#科学上网"></a>科学上网</h1><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/367821925" target="_blank" rel="noopener">五分钟注册美区Apple ID</a><br><a href="https://v2xtls.org/just-my-socks-ios%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Just My Socks配置</a><br><a href="https://v2xtls.org/shadowsocks-ss-ios%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/" target="_blank" rel="noopener">Shadowsocks客户端</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/01/14/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="关闭线程池"><a class="header-anchor" href="#关闭线程池"></a>关闭线程池</h1><p>#线程池 #dubbo</p><h2 id="dubbo优雅关闭线程池"><a class="header-anchor" href="#dubbo优雅关闭线程池"></a>dubbo优雅关闭线程池</h2><ul><li>shutDown：通知线程池启动有序关闭，执行线程池之前已经提交的任务，但是不再接受新的任务。调用shutDown后再提交任务将会抛出RejectedExecutionException异常。</li><li>shutDownNow：尝试立即停止所有已经提交的任务，并会返回正在等待执行（未执行）的任务列表。shutDownNow通过向线程池中的线程发送一个中断请求而中止线程，如果线程池中运行了会抛出InterruptedException的程序，将会抛出一个InterruptedException。如过这个线程不能响应中断那么可能永远无法被终止。</li><li>isTerminated：所有的任务都被关闭返回true，否则返回false。只有调用了shutDown或者shutDownNow，isTerminated才可能为true。</li><li>awaitTermination(long timeout,TimeUnit unit)throws InterruptedException：阻塞当前线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor shutdownExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>),</span><br><span class="line">            <span class="keyword">new</span> NamedThreadFactory(<span class="string">"Close-ExecutorService-Timer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ExecutorService) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((ExecutorService) executor).isTerminated()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use the shutdown pattern from:</span></span><br><span class="line"><span class="comment">     *  https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the Executor to shutdown</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the timeout in milliseconds before termination</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Disable new tasks from being submitted</span></span><br><span class="line">            es.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Wait a while for existing tasks to terminate</span></span><br><span class="line">            <span class="keyword">if</span> (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                es.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            es.shutdownNow();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            newThreadToCloseExecutor(es);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownNow</span><span class="params">(Executor executor, <span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            es.shutdownNow();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            es.awaitTermination(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            newThreadToCloseExecutor(es);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newThreadToCloseExecutor</span><span class="params">(<span class="keyword">final</span> ExecutorService es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            shutdownExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                            es.shutdownNow();</span><br><span class="line">                            <span class="keyword">if</span> (es.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://developer.aliyun.com/article/756816" target="_blank" rel="noopener">学习dubbo如何优雅关闭线程池</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E8%BF%94%E5%9B%9E%E7%A9%BAList%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/01/14/%E8%BF%94%E5%9B%9E%E7%A9%BAList%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="空list"><a class="header-anchor" href="#空list"></a>空list</h1><p>#list #jdk8 #stream</p><h2 id="返回空List的方式"><a class="header-anchor" href="#返回空List的方式"></a>返回空List的方式</h2><ol><li><code>new ArrayList()</code></li><li><code>new ArrayList(0)</code></li><li><code>Collections.emptyList()</code></li><li><code>Lists.newArrayList()</code></li></ol><p><a href="https://blog.csdn.net/yangguosb/article/details/84573635" target="_blank" rel="noopener">返回空List的方式</a></p><p>因为返回空集合的替代方法通常是返回null;<br>然后呼叫者必须添加针对NullPointerException的警卫。如果返回空集合，则会减轻错误类别。在Java 8+中，还有一个Optional类型，它可以在没有Collection的情况下实现相同的目的。</p><h2 id="返回null-还是-空集合？-推荐空集合"><a class="header-anchor" href="#返回null-还是-空集合？-推荐空集合"></a>返回null 还是 空集合？ 推荐空集合</h2><p>null ?? []<br><strong>返回null 还是 空对象？</strong><br>如果您打算指示没有可用数据，则返回null通常是最好的主意。<br><strong>空对象表示已返回数据，而返回null则表示未返回任何内容。</strong></p><p>此外，如果尝试访问<strong>对象中的成员</strong>，则返回null将会导致<strong>null异常</strong>，这对于突出显示错误代码很有用-尝试不访问任何成员是没有意义的。访问空对象的成员不会失败，这意味着错误可能会被发现。<br>map类似 Stream 的 map方法。处理完之后，返回的还是一个 Optional 对象，所以可以做链式调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">String name = Optional.of(user).map(User::getName).orElse(<span class="string">"佚名"</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure><p>如上，取出user对象的name值，若name为空，返回一个默认值“佚名”（神奇的名字）。<br>这里，直接调用map方法，就不需要对user对象进行预先判空了。因为在map方法里边，会调用isPresent方法帮我们处理user为null的情况。<br>到这里，脑袋转圈快的小伙伴，是不是对开头的坑已经有启发了。<br>没错，我们可以通过 <strong>Optional 的链式调用</strong>，通过 map，orElse 等操作改写。如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getUserAddr1</span><span class="params">(Optional&lt;User&gt; user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先获取address对象</span></span><br><span class="line">    <span class="keyword">return</span> user.map((u)-&gt;u.getAddress())</span><br><span class="line">            <span class="comment">//再获取details值，</span></span><br><span class="line">            .map(e -&gt; e.getDetails())</span><br><span class="line">            <span class="comment">//若detail为null，则返回一个默认值</span></span><br><span class="line">            .orElse(<span class="string">"地址信息未填写"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<a href="https://segmentfault.com/a/1190000023912618" target="_blank" rel="noopener">JDK8新特性</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
      <url>/2022/01/14/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="测试端口连通性"><a class="header-anchor" href="#测试端口连通性"></a>测试端口连通性</h1><p>#centos #端口</p><h2 id="如何测试端口通不通"><a class="header-anchor" href="#如何测试端口通不通"></a>如何测试端口通不通</h2><ul><li><strong>使用telnet判断</strong></li></ul><p><code>telnet ip post</code></p><ul><li><strong>使用ssh判断</strong></li></ul><p><code>ssh -v -p port username@ip</code></p><blockquote><p>-v 调试模式(会打印日志).<br>-p 指定端口</p></blockquote><ul><li><p><strong>使用wget判断</strong><br><code>wget ip:port</code></p></li><li><p><strong>使用端口扫描工具</strong></p></li><li><p><strong>使用专用工具tcping进行访问：</strong></p></li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/swazer_z/article/details/64442730" target="_blank" rel="noopener">如何测试端口通不通</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/14/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue基础语法"><a class="header-anchor" href="#Vue基础语法"></a>Vue基础语法</h1><p>#vue #js</p><h2 id="v-if与v-show的区别以及使用场景"><a class="header-anchor" href="#v-if与v-show的区别以及使用场景"></a>v-if与v-show的区别以及使用场景</h2><p>如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><h2 id="v-model和-model的区别"><a class="header-anchor" href="#v-model和-model的区别"></a>v-model和:model的区别</h2><p><strong>v-model是vue.js中内置的双向数据绑定指令</strong>，用于表单控件以外的标签是不起作用的(即<strong>只对表单控件标签的数据双向绑定有效</strong>)。<br><strong>:model相当于v-bind:model的缩写</strong>，v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，这种只是<strong>将父组件的数据传递到了子组件</strong>，并没有实现子组件和父组件数据的双向绑定。<br>当然引用类型除外，子组件改变引用类型的数据的话，父组件也会改变的。<br><code>&lt;input v-model=&quot;message&quot;&gt; = &lt;input v-bind:value=&quot;message&quot; v-on:input=&quot;message = $event.target.value&quot; /&gt;</code><br>上面这个例子中，v-bind:value=“message” 只是将message变量的值赋给了input的value，并没有双向绑定，在此声明一下以防混淆</p><h2 id="nextTick"><a class="header-anchor" href="#nextTick"></a>nextTick</h2><p><code>Vue</code> 实现响应式并不是数据发生变化之后 <code>DOM</code> 立即变化，而是按一定的策略进行 <code>DOM</code> 的更新<br>简单来说，<code>Vue</code> 在修改数据后，视图不会立刻更新，而是等<strong>同一事件循环</strong>中的所有数据变化完成之后，再统一进行视图更新。<br><code>Vue</code> 中 <code>data</code> 的数据变化是<strong>同步</strong>的，更新完就能拿到；但是 <code>dom</code> 的更新是<strong>异步</strong>的，需要用<code>nextTick</code> 去即时获取<br><strong>说白了就是因为</strong> <code>**Vue**</code> <strong>是异步执行</strong> <code>**DOM**</code> <strong>更新的，想立即操作更新后的</strong> <code>**DOM**</code> <strong>就需要使用</strong> <code>**$nextTick**</code><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/1136954/1629425520217-dd07b909-c560-4281-82a5-354bc43d7003.webp" alt="nextTick"></p><blockquote><p>在 <code>created</code> 和 <code>mounted</code> 阶段，如果需要操作渲染后的视图，也要使用 <code>nextTick</code> 方法。<br>官方文档说明：注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue中数组赋值，push和“-”有什么区别？"><a class="header-anchor" href="#vue中数组赋值，push和“-”有什么区别？"></a>vue中数组赋值，push和“=”有什么区别？</h2><p>push是向数组中==追加数据==，不删除数组原有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">res.push(<span class="number">5</span>);</span><br><span class="line">res.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 输出[2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><p>&quot;=&quot;等于号是一个数组，==覆盖==原数组的数据进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> tmp = [<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">res = tmp;</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 输出[5,6]</span></span><br></pre></td></tr></table></figure><h2 id="日期计算"><a class="header-anchor" href="#日期计算"></a>日期计算</h2><h3 id="计算结束日期与当前时间相差天数"><a class="header-anchor" href="#计算结束日期与当前时间相差天数"></a>计算结束日期与当前时间相差天数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateDiffer(Date_end)&#123;</span><br><span class="line">   <span class="comment">//date1结束时间</span></span><br><span class="line">   <span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(Date_end);</span><br><span class="line">   <span class="comment">//date2当前时间</span></span><br><span class="line">   <span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(date1.getFullYear(), date1.getMonth(), date1.getDate());</span><br><span class="line">   date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(date2.getFullYear(), date2.getMonth(), date2.getDate());</span><br><span class="line">   <span class="keyword">const</span> diff = date1.getTime() - date2.getTime(); <span class="comment">//目标时间减去当前时间</span></span><br><span class="line">   <span class="keyword">const</span> diffDate = diff / (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);  <span class="comment">//计算当前时间与结束时间之间相差天数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算传入日期的最近三个月"><a class="header-anchor" href="#计算传入日期的最近三个月"></a>计算传入日期的最近三个月</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recently3Month(date) &#123;</span><br><span class="line">  <span class="keyword">let</span> reportDate = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">  <span class="keyword">let</span> cutoffDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  cutoffDate.setMonth(cutoffDate.getMonth() - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> reportDate.getTime() &gt; cutoffDate.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date与String相互转换"><a class="header-anchor" href="#Date与String相互转换"></a>Date与String相互转换</h3><blockquote><p>时间转换获取时间戳 : var res = moment(Date.now(), ‘YYYY-MM-DD HH:mm:ss’).valueOf();<br>时间转换获取格式时间: <strong>var</strong> res = moment(Date.now()).format(<strong>‘YYYY-MM-DD HH:mm:ss’</strong>);<br>String转换Date时间戳：var datelong = moment(this.habit.startTime,“YYYY-MM-DD”);</p></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/7af8554d8f08" target="_blank" rel="noopener">v-if与v-show的区别以及使用场景</a><br><a href="https://blog.csdn.net/u012155729/article/details/87857414" target="_blank" rel="noopener">v-model和:model的区别</a><br><a href="https://juejin.cn/post/6970877981778509838" target="_blank" rel="noopener">nextTick方法</a><br><a href="https://blog.csdn.net/qq_31759203/article/details/109072551" target="_blank" rel="noopener">vue中数组赋值</a><br><a href="https://blog.csdn.net/jie520191/article/details/100011426" target="_blank" rel="noopener">vue moment时间戳Date</a><br><a href="https://blog.csdn.net/weixin_46074961/article/details/106421566" target="_blank" rel="noopener">this.$set的正确使用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Stream%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/"/>
      <url>/2022/01/14/Stream%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="stream排序和分页"><a class="header-anchor" href="#stream排序和分页"></a>stream排序和分页</h1><p>#stream #排序 #分页</p><h2 id="Java-8-stream排序-分页"><a class="header-anchor" href="#Java-8-stream排序-分页"></a>Java 8 stream排序&amp;分页</h2><h3 id="排序"><a class="header-anchor" href="#排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student newList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v1.getId().compareTo(</span><br><span class="line">v2.getId()</span><br><span class="line">)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v2getId().compareTo(</span><br><span class="line">v1.getId()</span><br><span class="line">)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据子对象id，升序排序，Student对象中还有一个Boy的对象属性</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v1.getBoy().getbId().compareTo(</span><br><span class="line">v2.getBoy().getbId()</span><br><span class="line">)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="分页"><a class="header-anchor" href="#分页"></a>分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip((currentPage-<span class="number">1</span>)*pageSize).limit(pageSize).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="在项目中的运用："><a class="header-anchor" href="#在项目中的运用："></a>在项目中的运用：</h3><pre><code class="language-java">long totalPage = resultList.size() / request.getPageSize() + (resultList.size() % request.getPageSize() &gt; 0 ? 1 : 0);Pagination pagination = new Pagination(request.getCurrent().longValue(), request.getPageSize().longValue(),(long) resultList.size(), totalPage);//通过stream对返回结果进行分页List&lt;MarketingTaskEntity&gt; paginationResults = resultList.stream().skip((request.getCurrent() - 1) * request.getPageSize()).limit(request.getPageSize()).collect(Collectors.toList());</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/SQL%20Where%E5%A6%99%E7%94%A8/"/>
      <url>/2022/01/14/SQL%20Where%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-Where妙用"><a class="header-anchor" href="#SQL-Where妙用"></a>SQL Where妙用</h1><p>#sql</p><h2 id="深入理解SQL中where-1-1的用处"><a class="header-anchor" href="#深入理解SQL中where-1-1的用处"></a>深入理解SQL中where 1=1的用处</h2><ol><li><p>where 的条件为永真<br>SQL注入时:<br><code>DELETE FROM table_a WHERE name= '张三'</code><br><code>DELETE FROM table_a WHERE name= '张三' or 1=1</code><br>本来是删除ａ值为张三的这一条数据，这就又变成了无约束的删除了。<br>1=1 永真， 1&lt;&gt;1 永假。</p></li><li><p>在后台写不定数量的查询条件下，便于规范语句，增加灵活性<code>String sql = &quot;select * from table a&quot;;</code></p></li></ol><p><strong>在不使用where 1=1的情况下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"name"</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.name='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"age"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"age"</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.age='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"class "</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"class "</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.class ='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当时用</strong>where 1=1** 的时候**<br><code>String sql = &quot;select * from table a where 1=1&quot;;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"name"</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.name='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"age"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"age"</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.age='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"class "</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"class "</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.class ='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis-where-1-1-和-where标签"><a class="header-anchor" href="#Mybatis-where-1-1-和-where标签"></a>Mybatis where 1=1 和 where标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selSampleListByIDX4"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"cn.com.git.cbs.datamodel.TBL_Sample"</span>&gt;</span></span><br><span class="line"> select </span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line"> from SAMPLE</span><br><span class="line"> where 1=1   </span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"samplenumber != null"</span> &gt;</span></span><br><span class="line">     AND SAMPLENUMBER = #&#123;samplenumber,jdbcType=DECIMAL&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mybatis  之前拼条件的时候 写法  where 1=1，也可以使where标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。</li><li>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：<br><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt;</code></li></ul><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><p><a href="https://blog.csdn.net/idomyway/article/details/78903822" target="_blank" rel="noopener">深入理解SQL中where 1=1的用处</a><br><a href="https://blog.csdn.net/qq_23994787/article/details/79045768" target="_blank" rel="noopener">where 1=1有什么用</a><br><a href="https://blog.csdn.net/xiaxiaorui2003/article/details/53301540" target="_blank" rel="noopener">where 1=1 和 where标签</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/SpringBoot%E9%9B%86%E6%88%90Kafka/"/>
      <url>/2022/01/14/SpringBoot%E9%9B%86%E6%88%90Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot集成Kafka"><a class="header-anchor" href="#SpringBoot集成Kafka"></a>SpringBoot集成Kafka</h1><h2 id="Maven配置"><a class="header-anchor" href="#Maven配置"></a>Maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://jishuin.proginn.com/p/763bfbd4c199" target="_blank" rel="noopener">SpringBoot集成Kafka</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2022/01/14/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot参数校验"><a class="header-anchor" href="#SpringBoot参数校验"></a>SpringBoot参数校验</h1><p>#spring</p><h2 id="参数校验"><a class="header-anchor" href="#参数校验"></a>参数校验</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException.class)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">argValidException</span><span class="params">(HttpServletResponse response, MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"参数校验异常："</span>, ex);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ex.getBindingResult().hasErrors()) &#123;</span><br><span class="line">            ex.getBindingResult().getFieldErrors().forEach(err-&gt;&#123;</span><br><span class="line">                builder.append(err.getDefaultMessage()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BaseResponse.fail(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/apply/collection"</span>, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">applyCollectionPermission</span><span class="params">(@Valid @RequestBody ApplyCollectionPermissionRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = metabaseService.applyCollection(request);</span><br><span class="line">        <span class="keyword">return</span> success ? BaseResponse.success(<span class="string">"已提交申请，等待审批。"</span>) : BaseResponse.fail(<span class="string">"操作失败，请重试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyCollectionPermissionRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"申请理由不能为空"</span>)</span><br><span class="line">    String reason;</span><br><span class="line">    List&lt;MBCollection&gt; collections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html" target="_blank" rel="noopener">springboot使用hibernate validator</a><br><a href="https://juejin.cn/post/6844903974257049608" target="_blank" rel="noopener">@valid和@validated</a><br><a href="https://my.oschina.net/u/3706132/blog/1557940" target="_blank" rel="noopener">分组校验</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Redis%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
      <url>/2022/01/14/Redis%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis延迟队列"><a class="header-anchor" href="#Redis延迟队列"></a>Redis延迟队列</h1><p>#缓存 #redis #队列</p><h2 id="带有延迟功能的消息队列"><a class="header-anchor" href="#带有延迟功能的消息队列"></a>带有延迟功能的消息队列</h2><h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><h3 id="设计目标"><a class="header-anchor" href="#设计目标"></a>设计目标</h3><h3 id="设计方案"><a class="header-anchor" href="#设计方案"></a>设计方案</h3><h3 id="核心代码实现"><a class="header-anchor" href="#核心代码实现"></a>核心代码实现</h3><h3 id="源码"><a class="header-anchor" href="#源码"></a>源码</h3><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.yuque.com/jinguo.tech/ca7ygu/ps8gdy" target="_blank" rel="noopener">Redis延迟队列</a><br><a href="https://blog.csdn.net/qq_21033663/article/details/101222502" target="_blank" rel="noopener">延迟队列浅析</a><br><a href="https://www.jianshu.com/p/6bddbfa52cef" target="_blank" rel="noopener">延迟队列的几种实现方式</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Redis%E9%94%81/"/>
      <url>/2022/01/14/Redis%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis锁"><a class="header-anchor" href="#Redis锁"></a>Redis锁</h1><p>#redis  #分布式锁</p><h2 id="项目应用"><a class="header-anchor" href="#项目应用"></a>项目应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不存在(为空)就set值，并返回1；如果存在(不为空)不进行操作，并返回0</span></span><br><span class="line">Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, String.valueOf(System.currentTimeMillis()), seconds, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> success != <span class="keyword">null</span> &amp;&amp; success;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://xie.infoq.cn/article/556aaceb68789b9de4807f1c2" target="_blank" rel="noopener">Redis分布式锁原理</a><br><a href="https://juejin.cn/post/6901484610031452174" target="_blank" rel="noopener">Redis实现分布式锁</a><br><a href="https://blog.csdn.net/amosjob/article/details/99681707" target="_blank" rel="noopener">企业级分布式锁</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Presto%E5%BC%95%E6%93%8E/"/>
      <url>/2022/01/14/Presto%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Presto引擎"><a class="header-anchor" href="#Presto引擎"></a>Presto引擎</h1><p>#presto</p><h2 id="Presto数据模型"><a class="header-anchor" href="#Presto数据模型"></a>Presto数据模型</h2><p>Presto使用Catalog、Schema和Table这3层结构来管理数据。</p><blockquote><p>** Catalog**:就是数据源。Hive是数据源，Mysql也是数据源，Hive 和Mysql都是数据源类型，可以连接多个Hive和多个Mysql，每个连接都有一个名字。一个Catalog可以包含多个Schema，大家可以通过show catalogs 命令看到Presto连接的所有数据源。<br>** Schema**：相当于一个数据库实例，一个Schema包含多张数据表。show schemas from 'catalog_name’可列出catalog_name下的所有schema。<br><strong>Table</strong>：数据表，与一般意义上的数据库表相同。show tables from 'catalog_name.schema_name’可查看’catalog_name.schema_name’下的所有表。</p></blockquote><blockquote><p>在Presto中定位一张表，一般是catalog为根，例如：一张表的全称为 hive.test_data.test，标识 hive(catalog)下的 test_data(schema)中test表。可以简理解为：数据源的大类.数据库.数据表。</p></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="http://blog.chinaunix.net/uid-31012107-id-5819785.html" target="_blank" rel="noopener">Presto入门介绍</a><br><a href="https://www.alibabacloud.com/help/zh/doc-detail/166150.htm" target="_blank" rel="noopener">Presto数据源</a><br><a href="https://cloud.tencent.com/developer/article/1630733" target="_blank" rel="noopener">Presto查询引擎及原理分析</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/OKHttp%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/14/OKHttp%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="OKHttp原理"><a class="header-anchor" href="#OKHttp原理"></a>OKHttp原理</h1><p>#http</p><h2 id="原理概述"><a class="header-anchor" href="#原理概述"></a>原理概述</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1136954/1629450431169-f6cf4ce4-1a30-4f9f-98de-af6e4dcf12f0.webp" alt="okhttp原理"></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://juejin.cn/post/6968773787374321677?utm_source=gold_browser_extension" target="_blank" rel="noopener">探索 OkHttp 原理 - 掘金</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL执行计划</title>
      <link href="/2022/01/14/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2022/01/14/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL执行计划"><a class="header-anchor" href="#MySQL执行计划"></a>MySQL执行计划</h1><h2 id="Explain-用途"><a class="header-anchor" href="#Explain-用途"></a><code>Explain</code> 用途</h2><ol><li>表的读取顺序如何</li><li>数据读取操作有哪些操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间是如何引用</li><li>每张表有多少行被优化器查询</li></ol><h2 id="Explain语法"><a class="header-anchor" href="#Explain语法"></a><code>Explain</code>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/Dreamhai/article/details/104558854" target="_blank" rel="noopener">MySQL查询优化之explain 执行计划</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis转义字符</title>
      <link href="/2022/01/14/Mybatis%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2022/01/14/Mybatis%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis转义字符"><a class="header-anchor" href="#Mybatis转义字符"></a>Mybatis转义字符</h1><h2 id="转义字符"><a class="header-anchor" href="#转义字符"></a>转义字符</h2><table><thead><tr><th>字符</th><th>转义</th><th>描述</th></tr></thead><tbody><tr><td>&lt;</td><td><code>&amp;lt;</code></td><td>小于</td></tr><tr><td>&lt;=</td><td><code>&amp;lt;=</code></td><td>小于等于</td></tr><tr><td>&gt;</td><td><code>&amp;gt;</code></td><td>大于</td></tr><tr><td>&gt;=</td><td><code>&amp;gt;=</code></td><td>大于等于</td></tr><tr><td>&lt;&gt;</td><td><code>&amp;lt;&amp;gt;</code></td><td>不等于</td></tr><tr><td>&amp;</td><td><code>&amp;amp;</code></td><td></td></tr><tr><td>’</td><td><code>&amp;apos</code></td><td></td></tr><tr><td>‘’</td><td><code>&amp;qots</code></td><td></td></tr></tbody></table><p>此外，也可以用CDATA标志<br><code>&lt;![CDATA[ 这里写你的sql ]]&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List按照对象属性去重</title>
      <link href="/2022/01/14/List%E6%8C%89%E7%85%A7%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D/"/>
      <url>/2022/01/14/List%E6%8C%89%E7%85%A7%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="List按照对象属性去重"><a class="header-anchor" href="#List按照对象属性去重"></a>List按照对象属性去重</h1><h2 id="通过stream去重"><a class="header-anchor" href="#通过stream去重"></a>通过stream去重</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getFileDetailList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(fileDetailList)) &#123;</span><br><span class="line"><span class="keyword">return</span> fileDetailList.stream().filter(distinctByKey(SecurityResource::getName)).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">2</span> &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
            <tag> jdk </tag>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础语法</title>
      <link href="/2022/01/14/JS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/14/JS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS基础语法"><a class="header-anchor" href="#JS基础语法"></a>JS基础语法</h1><h2 id="Javascript中-的含义"><a class="header-anchor" href="#Javascript中-的含义"></a>Javascript中!!的含义</h2><p>Javascript中!!(两个感叹号，双感叹号)可以用来做什么，可以做出如下判断：</p><ul><li>数值：表示不是0，且有确定含义的值（包括无穷大）</li><li>字符串：表示长度大于0的字符串</li><li>数组，对象，函数：只能表示不是undefined或null,并不能判断是否有元素和内容。<br><code>if(!!arr &amp;&amp; arr.length&gt;0)</code></li></ul><h2 id="js判断为空Null与字符串为空简写方法"><a class="header-anchor" href="#js判断为空Null与字符串为空简写方法"></a>js判断为空Null与字符串为空简写方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (variable1 !== <span class="literal">null</span> || variable1 !== <span class="literal">undefined</span> || variable1 !== <span class="string">''</span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> variable2 = variable1; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的意思是说如果variable1不是一个空对象，或者未定义，或者不等于空字符串，那么声明一个variable2变量，将variable1赋给variable2。也就是说如果variable1存在那么就将variable1的值赋给variable2，若不存在则为空字符串。如下面的简写代码。<br><code>var variable2 = variable1 || '';</code><br>判断字符串是否为空：<br><code>str.length==0</code><br>如果用户输入的是空格，制表符，换页符呢?这样的话，是不为空的<br>可以用正则表达式来判断<br><code>str.replace(/(^s*)|(s*$)/g, &quot;&quot;).length ==0</code><br>或者<br><code>str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)) != &quot;&quot;</code></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/daysme/p/6979231.html" target="_blank" rel="noopener">js判空</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON序列化</title>
      <link href="/2022/01/14/json%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/01/14/json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON序列化"><a class="header-anchor" href="#JSON序列化"></a>JSON序列化</h1><h2 id="属性序列化"><a class="header-anchor" href="#属性序列化"></a>属性序列化</h2><h3 id="一、jackson的-JsonProperty使用"><a class="header-anchor" href="#一、jackson的-JsonProperty使用"></a>一、jackson的@JsonProperty使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>@JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(value=<span class="string">"name"</span>)。</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@JsonProperty</span>(<span class="string">"screen_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String screen;</span><br></pre></td></tr></table></figure><h3 id="二、fastjson的-JSONField使用"><a class="header-anchor" href="#二、fastjson的-JSONField使用"></a>二、fastjson的@JSONField使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(name=<span class="string">"screen_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String screen;</span><br></pre></td></tr></table></figure><h2 id="忽略属性"><a class="header-anchor" href="#忽略属性"></a>忽略属性</h2><h3 id="一、jackson的JsonIgnore"><a class="header-anchor" href="#一、jackson的JsonIgnore"></a>一、jackson的JsonIgnore</h3><ol><li>作用：在json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。</li><li>使用方法：一般标记在属性或者方法上，返回的json数据即不包含该属性。</li></ol><h3 id="二、fastjson的-JSONField-serialize-false"><a class="header-anchor" href="#二、fastjson的-JSONField-serialize-false"></a>二、fastjson的@JSONField(serialize = false)</h3><h2 id="日期格式化"><a class="header-anchor" href="#日期格式化"></a>日期格式化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)  </span><br><span class="line"><span class="meta">@JsonFormat</span>(shape = JsonFormat.Shape.STRING, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="keyword">private</span> LocalDateTime startTime;</span><br></pre></td></tr></table></figure><p>@DatetimeFormat<br>org.springframework.format.annotation.DateTimeFormat<br>是将String转换成LocalDateTime，一般前台给后台传值时用</p><p>@JsonFormat：com.fasterxml.jackson.annotation.JsonFormat<br>将LocalDateTime转换成String  一般后台传值给前台时用</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joiner简化用分隔符连接字符串序列</title>
      <link href="/2022/01/14/Guava%E4%B9%8BJoiner/"/>
      <url>/2022/01/14/Guava%E4%B9%8BJoiner/</url>
      
        <content type="html"><![CDATA[<h1 id="Guava之Joiner"><a class="header-anchor" href="#Guava之Joiner"></a>Guava之Joiner</h1><p>#guava #字符串</p><h2 id="Joiner-简化用分隔符连接字符串序列"><a class="header-anchor" href="#Joiner-简化用分隔符连接字符串序列"></a><code>Joiner</code> 简化用分隔符连接字符串序列</h2><ul><li>如果序列中包含 <code>null</code> 值，那么可以使用 <code>Joiner</code> 跳过 <code>null</code> 值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过 null 值</span></span><br><span class="line">result = Joiner.on(<span class="string">"; "</span>).skipNulls().join(<span class="string">"Harry"</span>, <span class="keyword">null</span>, <span class="string">"Ron"</span>, <span class="string">"Hermione"</span>);</span><br><span class="line">Assert.assertEquals(result, <span class="string">"Harry; Ron; Hermione"</span>);</span><br></pre></td></tr></table></figure><ul><li>也可以通过 <code>useForNull(String)</code> 来将 <code>null</code> 值替换为指定的字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换 null 值</span></span><br><span class="line">result = Joiner.on(<span class="string">"; "</span>).useForNull(<span class="string">"null"</span>).join(<span class="string">"Harry"</span>, <span class="keyword">null</span>, <span class="string">"Ron"</span>, <span class="string">"Hermione"</span>);</span><br><span class="line">Assert.assertEquals(result, <span class="string">"Harry; null; Ron; Hermione"</span>);</span><br></pre></td></tr></table></figure><ul><li>同样可以在对象上使用 <code>Joiner</code>,最终会调用对象的 <code>toString()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用在对象上，会调用对象的 toString() 函数</span></span><br><span class="line">result = Joiner.on(<span class="string">","</span>).join(Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line">Assert.assertEquals(result, <span class="string">"1,5,7"</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 <code>Map</code> ,可以使用这样的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapJoiner 的使用，将 map 转换为字符串</span></span><br><span class="line">Map map = ImmutableMap.of(<span class="string">"k1"</span>, <span class="string">"v1"</span>, <span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">result = Joiner.on(<span class="string">"; "</span>).withKeyValueSeparator(<span class="string">"="</span>).join(map);</span><br><span class="line">Assert.assertEquals(result, <span class="string">"k1=v1; k2=v2"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guava </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava中本地缓存LoadingCache使用</title>
      <link href="/2022/01/14/Guava%20%E4%B8%AD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%20LoadingCache%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/14/Guava%20%E4%B8%AD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%20LoadingCache%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Guava中本地缓存LoadingCache使用"><a class="header-anchor" href="#Guava中本地缓存LoadingCache使用"></a>Guava中本地缓存LoadingCache使用</h1><h2 id="Guava-Cache"><a class="header-anchor" href="#Guava-Cache"></a>Guava Cache</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`Cache`</span> 在实际场景中有着非常广泛的使用，通常情况下如果遇到需要大量时间计算或者获取值的场景，</span><br><span class="line">就应当将值保存到缓存中。<span class="code">`Cache`</span> 和 <span class="code">`ConcurrentMap`</span> 类似，但又不尽相同。</span><br><span class="line">最大的不同是 <span class="code">`ConcurrentMap`</span> 会永久的存储所有的元素值直到他们被显示的移除，</span><br><span class="line">但是 <span class="code">`Cache`</span> 会为了保持内存使用合理，而配置自动将一些值移除。</span><br></pre></td></tr></table></figure><p>通常情况下，Guava Cache 适用于以下场景：</p><ul><li>花费一些内存来换取速度</li><li>一些 key 会被不止一次被调用</li><li>缓存内容有限，不会超过内存空间的值，Guava Cache 不会存储内容到文件或者到服务器外部，如果有此类需求考虑使用 Memcached, Redis 等类似工具<br>先来看一下 Guava 中 Cache 接口的定义：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#asMap</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#cleanUp</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#get</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#getAllPresent</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#getIfPresent</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#invalidate</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#invalidateAll</span>()</span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#invalidateAll</span>(<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Iterable</span>&lt;?&gt;)</span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#put</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#putAll</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#size</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#stats</span></span><br></pre></td></tr></table></figure><p>Cache 接口定义的方法大都一目了然，值得一说的就是 <code>stats()</code> 方法，这个方法会返回一个 <code>CacheStats</code> 对象，这个对象包括了该 Cache 的一些统计信息，包括 <code>hitCount</code>， <code>missCount</code>，<code>loadSuccessCount</code>，<code>loadExceptionCount</code>，<code>totalLoadTime</code> 和 <code>evictionCount</code>。<br><code>Cache</code> 通过 <code>CacheBuilder</code> 类的 Builder 模式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()</span><br><span class="line">       .maximumSize(<span class="number">1000</span>)</span><br><span class="line">       .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">       .removalListener(MY_LISTENER)</span><br><span class="line">       .build(</span><br><span class="line">           <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> AnyException </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>如果使用的场景中对应着 key 的值有默认的值，那么可以选择使用 <code>CacheLoader</code>，如果没有默认值，那么仍然可以原子的 <code>get-if-absent-compute</code> 方法，在 <code>get</code> 方法中提供一个 <code>Callable</code>，或者元素也可以通过 <code>Cache.put</code> 来直接插入到缓存中。</p><h2 id="LoadingCache"><a class="header-anchor" href="#LoadingCache"></a>LoadingCache</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`LoadingCache`</span> 是一个附加着 <span class="code">`CacheLoader`</span> 的 Cache。</span><br><span class="line"><span class="code">`LoadingCache&lt;K,V&gt;`</span> 在 Guava 中是一个 interface，</span><br><span class="line">通常是用来本地 Cache 缓存 k-v 数据，value 会一直保存在内存中直到被移除或者失效。</span><br><span class="line">实现这个接口的类期望是线程安全的，能够安全的在多线程程序中被访问。</span><br></pre></td></tr></table></figure><h3 id="LoadingCache-不能-Cache-null"><a class="header-anchor" href="#LoadingCache-不能-Cache-null"></a>LoadingCache 不能 Cache null</h3><p>LoadingCache 是不支持缓存 null 值的，如果 load 回调方法返回 null，则在 get 的时候会抛出异常。<br>如果在 CacheLoader 中抛出异常，那么 Cache 会认为没有完成，所以新的值不会被 Cache。基于这一条规则，那么如何避免在 CacheLoader 中因为缓存 null 而抛出异常，那就是编程者自己处理 null 异常</p><h3 id="get-vs-getUnchecked"><a class="header-anchor" href="#get-vs-getUnchecked"></a>get() vs getUnchecked()</h3><p>最正统的查询 <code>LoadingCache</code> 的方法是调用 <code>get(k)</code> 方法，这个方法如果查询到已经缓存的值会立即返回，否则使用缓存的 <code>CacheLoader</code> 自动加载一个新值到缓存并返回。因为 <code>CacheLoader</code> 可能会抛出异常，那么如果有异常，则<code>LoadingCache.get(k)</code> 会抛出 <code>ExecutionException</code> 异常。而如果 CacheLoader 抛出 unchecked 未检查的异常，则 <code>get(k)</code> 方法会抛出 <code>UncheckedExecutionException</code> 异常。<br>此时可以选择使用 <code>getUnchecked(k)</code> 方法，这个方法会将所有的异常包装在 UncheckedExecutionException 异常中。需要注意的是，如果 CacheLoader 声明了检查异常，也就是 CacheLoader 显式的定义了异常，就不能调用 <code>getUnchecked(k)</code> 方法</p><h3 id="定时回收"><a class="header-anchor" href="#定时回收"></a>定时回收</h3><p>CacheBuilder 在构建 Cache 时提供了两种定时回收的方法</p><ul><li>expireAfterAccess(long, TimeUnit) : 缓存项在给定时间内没有被读或写访问，则回收</li><li>expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收</li></ul><h3 id="失效"><a class="header-anchor" href="#失效"></a>失效</h3><p>调用 LoadingCache 的 <code>invalidate</code> 方法可以使得 key 失效</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="noopener">guava wiki</a><br><a href="https://www.jianshu.com/p/2d3d30015915" target="_blank" rel="noopener">微服务缓存之Guava Cache</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guava </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴面试参考指南</title>
      <link href="/2022/01/14/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/"/>
      <url>/2022/01/14/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里巴巴面试参考指南"><a class="header-anchor" href="#阿里巴巴面试参考指南"></a>阿里巴巴面试参考指南</h1><p>#面试</p><h2 id="面试参考指南"><a class="header-anchor" href="#面试参考指南"></a>面试参考指南</h2><ol><li><strong>主从热备机制以及读写分离架构</strong></li></ol><p>Mybatis如何实现？使数据库读写分离对应用透明。</p><ol start="2"><li><strong>cdn刷新和预热资源</strong></li></ol><p>缓存刷新：提交缓存刷新请求后，CDN节点的缓存内容将会被强制过期。当用户向CDN节点请求资源时，CDN会直接回源站拉取对应的资源返回给用户，并将其缓存。</p><p>缓存预热：提交缓存预热请求后，源站将会主动将对应的资源缓存到CDN节点。当用户首次请求时，就能直接从CDN节点缓存中获取到最新的请求资源，无需再回源站拉取。</p><ol start="3"><li><p><strong>nginx针对前端静态资源的缓存处理</strong></p></li><li><p><strong>CPU负载压力</strong></p></li><li><p><strong>分布式文件系统 分布式数据库</strong><br>分库分表、MPP、分布式数据库</p></li><li><p><strong>NOSQL和搜索引擎</strong><br>为什么使用NOSQL数据库?</p></li></ol><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/youzhibing/p/7301463.html" target="_blank" rel="noopener">spring集成mybatis实现mysql读写分离-博客园</a><br><a href="https://shardingsphere.apache.org/blog/cn/material/database/" target="_blank" rel="noopener">我们是怎样打造一款分布式数据库的 · ShardingSphere - 博客</a><br><a href="https://www.cnblogs.com/shenzs-whj/p/10224671.html" target="_blank" rel="noopener">为什么要使用NoSQL数据库-博客园</a><br><a href="https://juejin.cn/post/6844903602935300104" target="_blank" rel="noopener">消息队列之 RocketMQ - 掘金</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java能力框架及学习路径</title>
      <link href="/2021/05/07/%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/05/07/%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Java能力框架及学习路径"><a class="header-anchor" href="#Java能力框架及学习路径"></a>Java能力框架及学习路径</h2><p>衡量每位工程师水平高低的标准，90%比拼的是技术能力，还有一小部分是软实力。建立完整的知识框架，会在职场中表现自己的优势，不再迷茫。在面试过程中可以把它分为基础知识、应用知识、综合能力三大模块的考核。</p><ul><li>基础模块包括：常见技术岗与面试流程、计算机基础JVM原理、多线程、设计模式、数据结构与算法等</li><li>应用模块包括：常用工具集、常用框架、缓存、队列、数据库等</li><li>综合模块包括：项目介绍、系统架构设计、微服务架构、容器化等</li></ul><table><thead><tr><th style="text-align:center">基础模块</th><th style="text-align:center">应用模块</th><th style="text-align:center">综合模块</th></tr></thead><tbody><tr><td style="text-align:center">技术岗位与面试流程</td><td style="text-align:center">常用工具集</td><td style="text-align:center">系统架构设计</td></tr><tr><td style="text-align:center">计算机基础</td><td style="text-align:center">常用框架</td><td style="text-align:center">微服务架构</td></tr><tr><td style="text-align:center">JVM原理</td><td style="text-align:center">缓存</td><td style="text-align:center">容器化</td></tr><tr><td style="text-align:center">多线程</td><td style="text-align:center">队列</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">设计模式</td><td style="text-align:center">数据库</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据结构与算法</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><blockquote><p>不论是应届生，初中级工程师，还是高级/资深工程师，经常会出现自身能力还不错，工作学习也很勤奋，却在找工作时铩羽而归的情况，换工作难的原因有三：</p><ul><li>不知道简历要写什么</li></ul><blockquote><p>​简历不好意味着没有面试机会。技术候选人大约有80%的简历通不过初筛，常见的原因有四种：</p><ol><li><p>工作/项目经验描述得不到位</p></li><li><p>不懂得如何包装自己的技术特长</p></li><li><p>学历不占优势，却放在了最显眼的位置</p></li><li><p>排版太乱，废话太多</p><p><strong>首先看看简历是不是有这些问题</strong>，另外，很多候选人在换工作的时候，按自己的喜好<strong>海投</strong>，从不看岗位的要求，也不会多准备几份简历，这种盲目的投递行为是导致失败的罪魁祸首。简历中的<strong>工作年限、对口经验、学历，甚至简历的美观度、逻辑是否清晰</strong>，都可能是道坎。</p></li></ol></blockquote></blockquote><blockquote><ul><li>不知道面试官要考什么</li></ul><blockquote><p>​很多人接到面试电话，第二天糊里糊涂就去，这种失败率极高。首先，不清楚侧重点、岗位要求。不同行业领域与工作年限对候选人的要求是不一样的，考察点也有所侧重。</p><p>​比如，从行业角度来看，社交门户类考查的是<strong>大规模高并发场景的应用与架构能力</strong>；O2O行业侧重于<strong>综合能力</strong>的考察；而互联网金融更喜欢逻辑缜密，对高可用安全领域有丰富经验的候选人。</p><p>​而针对不同的工作年限，校招面试更多的是对<strong>基础知识与逻辑思维</strong>方面的考察，以培养潜力的考察为主；初中级工程师则需要多关注<strong>知识的广度与基础知识的应用</strong>；而高级或者资深工程师需要深入理解基本原理，能对各种知识灵活运用，以综合的能力考查为主。</p><p>​其次，没有get到面试官的考查意图。举个简单的例子：面试官问使用过某某框架吗？很多人会回答说用过，然后就冷场了。其实，这个问题是想考察<strong>这个框架的使用场景、解决什么样的问题、有什么特点、有何同类型的其他框架</strong>等一系列的问题，如果仅仅回答“是”或者“否”的话，显然没有get到我的意图。同时，也能发现这些候选人在<strong>沟通表达</strong>上有待提高，恐怕会影响到将来的团队协作。</p><p>​    建议在面试前简单对公司<strong>业务岗位职责</strong>做一些功课，做一些有针对性的准备，才能事半功倍。</p></blockquote><ul><li>不知道如何提升晋级</li></ul><blockquote><p>​新技术的<strong>升级换代</strong>非常快，没跟上就可能被淘汰。<strong>不断学习</strong>是非常必要的。很多人都有一个不太好的习惯：东学一点西学一点。当时觉得很有用，可时间长了，发现我的技术并没有因此而提高。究其原因，要么是不成体系很快就遗忘，要么是和现实工作相差太远，无法灵活地运用，遇到了实际案例问题还是无从下手。</p><p>​学习首先要有一个框架，就像书的<strong>目录</strong>一样，<strong>先梗概后细节</strong>，先建立一套<strong>知识体系</strong>再一块一块地夯实。所以需要全面的梳理Java知识体系，建立<strong>思维框架</strong>。</p></blockquote></blockquote><p><img src="https://img.jinguo.tech/blog/image-20210506012953204.png?imageslim" alt="面试大纲"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32个Java常用面试点-概述</title>
      <link href="/2021/05/07/%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/05/07/%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2><p><strong>声明：</strong></p><p>本章节来自于我在拉钩教育上学习的VIP课程《32个Java面试必考点》，讲师是新浪微博资深技术专家-张磊。<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1#/detail/pc?id=1" target="_blank" rel="noopener">课程连接</a></p><p>本章节的知识内容均整理于此课程，仅用于学习记忆。若侵权，请通过本人站点进行联系，本人即刻对内容删除。<a href="https://jinguo.tech">联系站点</a></p><ul><li><p><a href="%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6.md">开篇：建立年薪50万的能力框架</a></p></li><li><p><a href="%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84.md">第一节：技术人职业发展路径</a></p></li><li><p><a href="%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">第二节：操作系统与计算机网络</a></p></li><li><p>第三节：深入浅出JVM</p></li><li><p>第四节：并发与多线程</p></li><li><p>第五节：数据结构与算法</p></li><li><p>第六节：常用工具集</p></li><li><p>第七节（上）：必会框架-Spring全家桶</p></li><li><p>第七节（下）：必会框架-RPC与ORM</p></li><li><p>第八节：高并发架构基石-缓存</p></li><li><p>第九节（上）：消息队列Kafka架构与原理</p></li><li><p>第九节（下）：MySQL调优与最佳实践</p></li><li><p>第十节：架构的演进之路与前沿技术</p></li><li><p>附录：技术人行走职场的建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/2021/04/27/%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/27/%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-dubbo在debug（调试）模式下，启动很慢的问题解决方法"><a class="header-anchor" href="#idea-dubbo在debug（调试）模式下，启动很慢的问题解决方法"></a>idea dubbo在debug（调试）模式下，启动很慢的问题解决方法</h1><p>idea 在debug模式下启动dubbo的时候，dubbo注册的时候会非常慢，但是在非调试模式下，就正常！后来在debug模式下，将所有断点都清除后，速度立马就上来了！所以在debug模式下启动，需要将断点都清除再启动！</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive实战</title>
      <link href="/2020/12/28/Hive%20%E5%AE%9E%E6%93%8D/"/>
      <url>/2020/12/28/Hive%20%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive-实操"><a class="header-anchor" href="#Hive-实操"></a>Hive 实操</h1><h2 id="一、Database"><a class="header-anchor" href="#一、Database"></a>一、Database</h2><h3 id="1-1-查看数据库列表"><a class="header-anchor" href="#1-1-查看数据库列表"></a>1.1 查看数据库列表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902204156290.png?imageslim" alt="image-20200902204156290"></p><h3 id="1-2-查看数据库列表"><a class="header-anchor" href="#1-2-查看数据库列表"></a>1.2 查看数据库列表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> database_name;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902204350677.png?imageslim" alt="image-20200902204350677"></p><h3 id="1-3-新建数据库"><a class="header-anchor" href="#1-3-新建数据库"></a>1.3 新建数据库</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>) [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name   <span class="comment">--DATABASE|SCHEMA 是等价的</span></span><br><span class="line">  [<span class="keyword">COMMENT</span> database_comment] <span class="comment">--数据库注释</span></span><br><span class="line">  [LOCATION hdfs_path] <span class="comment">--存储在 HDFS 上的位置</span></span><br><span class="line">  [<span class="keyword">WITH</span> DBPROPERTIES (property_name=property_value, ...)]; <span class="comment">--指定额外属性</span></span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> hive_test</span><br><span class="line">  <span class="keyword">COMMENT</span> <span class="string">'hive database for test'</span></span><br><span class="line">  <span class="keyword">WITH</span> DBPROPERTIES (<span class="string">'create'</span>=<span class="string">'jinguo'</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902203705654.png?imageslim" alt="image-20200902203705654"></p></li></ul><h3 id="1-4-查看数据库信息"><a class="header-anchor" href="#1-4-查看数据库信息"></a>1.4 查看数据库信息</h3><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC DATABASE [EXTENDED] db_name; <span class="comment">--EXTENDED 表示是否显示额外属性</span></span><br></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC DATABASE  EXTENDED hive_test;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903100904811.png?imageslim" alt="image-20200903100904811"></p><h3 id="1-5-删除数据库"><a class="header-anchor" href="#1-5-删除数据库"></a>1.5 删除数据库</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> (<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>) [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] database_name [RESTRICT|<span class="keyword">CASCADE</span>];</span><br></pre></td></tr></table></figure><p><em>默认行为是 <strong>RESTRICT</strong>，如果数据库中存在表则删除失败。要想删除库及其中的表，可以使用 <strong>CASCADE</strong> 级联删除。</em></p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hive_test;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903111952592.png?imageslim" alt="image-20200903111952592"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">while</span> processing statement: FAILED: Execution Error, <span class="keyword">return</span> code <span class="number">1</span> from org<span class="variable">.apache</span><span class="variable">.hadoop</span><span class="variable">.hive</span><span class="variable">.ql</span><span class="variable">.exec</span><span class="variable">.DDLTask</span>. InvalidOperationException(message:Database hive_test is <span class="keyword">not</span> empty. One <span class="keyword">or</span> more tables exist.)</span><br></pre></td></tr></table></figure><p><em>当数据库中存在表的时候，删除时需要用<strong>CASCADE</strong></em>关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hive_test <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903112539723.png?imageslim" alt="image-20200903112539723"></p><h2 id="二、创建表"><a class="header-anchor" href="#二、创建表"></a>二、创建表</h2><h3 id="2-1-建表语法"><a class="header-anchor" href="#2-1-建表语法"></a>2.1 建表语法</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">TEMPORARY</span>] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name     <span class="comment">--表名</span></span><br><span class="line">  [(col_name data_type [<span class="keyword">COMMENT</span> col_comment],</span><br><span class="line">    ... [constraint_specification])]  <span class="comment">--列名 列数据类型</span></span><br><span class="line">  [<span class="keyword">COMMENT</span> table_comment]   <span class="comment">--表描述</span></span><br><span class="line">  [PARTITIONED <span class="keyword">BY</span> (col_name data_type [<span class="keyword">COMMENT</span> col_comment], ...)]  <span class="comment">--分区表分区规则</span></span><br><span class="line">  [</span><br><span class="line">    CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...) </span><br><span class="line">   [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS</span><br><span class="line">  ]  <span class="comment">--分桶表分桶规则</span></span><br><span class="line">  [SKEWED <span class="keyword">BY</span> (col_name, col_name, ...) <span class="keyword">ON</span> ((col_value, col_value, ...), (col_value, col_value, ...), ...)  </span><br><span class="line">   [<span class="keyword">STORED</span> <span class="keyword">AS</span> DIRECTORIES] </span><br><span class="line">  ]  <span class="comment">--指定倾斜列和值</span></span><br><span class="line">  [</span><br><span class="line">   [<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> row_format]    </span><br><span class="line">   [<span class="keyword">STORED</span> <span class="keyword">AS</span> file_format]</span><br><span class="line">     | <span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'storage.handler.class.name'</span> [<span class="keyword">WITH</span> SERDEPROPERTIES (...)]  </span><br><span class="line">  ]  <span class="comment">-- 指定行分隔符、存储文件格式或采用自定义存储格式</span></span><br><span class="line">  [LOCATION hdfs_path]  <span class="comment">-- 指定表的存储位置</span></span><br><span class="line">  [TBLPROPERTIES (property_name=property_value, ...)]  <span class="comment">--指定表的属性</span></span><br><span class="line">  [<span class="keyword">AS</span> select_statement];   <span class="comment">--从查询结果创建表</span></span><br></pre></td></tr></table></figure><h3 id="2-2-创建内部表"><a class="header-anchor" href="#2-2-创建内部表"></a>2.2 创建内部表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903180953529.png?imageslim" alt="image-20200903180953529"></p><h3 id="2-3-创建外部表"><a class="header-anchor" href="#2-3-创建外部表"></a>2.3 创建外部表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_external(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_external'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903181743473.png?imageslim" alt="image-20200903181743473"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903184628794.png?imageslim" alt="image-20200903184628794"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903190348379.png?imageslim" alt="image-20200903190348379"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903185141700.png?imageslim" alt="image-20200903185141700"></p><h3 id="2-4-内部表和外部表区别"><a class="header-anchor" href="#2-4-内部表和外部表区别"></a>2.4 内部表和外部表区别</h3><p><strong>创建表时</strong></p><ul><li>创建内部表：会将数据移动到数据仓库指向的路径；</li><li>创建外部表：仅记录数据所在的路径， 不对数据的位置做任何改变。</li></ul><p><strong>删除表时</strong></p><ul><li>内部表的元数据和数据会被一起删除</li><li>外部表只删除元数据，不删除数据。外部表相对来说更加安全，数据组织更加灵活，方便共享源数据。</li></ul><p><strong>总结：</strong></p><ol><li><p>未被external修饰的是内部表【<em>managed table</em>】，被external修饰的为外部表【<em>external table</em>】。</p></li><li><p>内部表数据由Hive自身管理，外部表数据由HDFS管理。</p></li><li><p>内部表数据存储在<em>hive.metastore.warehouse.dir</em>【默认:<em>/user/hive/warehouse</em>】，外部表数据存储位置由用户自己决定。如 <em>location ‘/hive/emp_external’</em></p><p><img src="https://img.jinguo.tech/typora/image-20200904222601364.png?imageslim" alt="image-20200904222601364"></p><p><img src="https://img.jinguo.tech/typora/image-20200904222820733.png?imageslim" alt="image-20200904222820733"></p></li><li><p>删除内部表会直接删除元数据【<em>metadata</em>】及<strong>存储数据</strong>，删除外部表仅仅删除元数据，<em>HDFS</em>上的文件不会被删除。</p></li><li><p>对内部表的修改会直接同步到元数据，而对外部表的表结构和分区进行修改，则需要修改【<em>MSCK REPAIR TABLE table_name</em>】。</p></li></ol><h3 id="2-5-创建分区表"><a class="header-anchor" href="#2-5-创建分区表"></a>2.5 创建分区表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_partition(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">   )</span><br><span class="line">   PARTITIONED <span class="keyword">BY</span> (deptno <span class="built_in">INT</span>)  <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_partition'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903191518107.png?imageslim" alt="image-20200903191518107"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903193011185.png?imageslim" alt="image-20200903193011185"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192022966.png?imageslim" alt="image-20200903192022966"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903191648232.png?imageslim" alt="image-20200903191648232"></p><h3 id="2-6-分桶表"><a class="header-anchor" href="#2-6-分桶表"></a>2.6 分桶表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_bucket'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903192305213.png?imageslim" alt="image-20200903192305213"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192644607.png?imageslim" alt="image-20200903192644607"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em><img src="https://img.jinguo.tech/typora/image-20200903192505630.png?imageslim" alt="image-20200903192505630"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192829644.png?imageslim" alt="image-20200903192829644"></p><h3 id="2-7-倾斜表"><a class="header-anchor" href="#2-7-倾斜表"></a>2.7 倾斜表</h3><p><em>通过指定一个或者多个列经常出现的值（严重偏斜），<strong>Hive</strong>会自动将涉及到这些值的数据拆分为单独的文件。在查询时，如果涉及到倾斜值，它就直接从独立文件中获取数据，而不是扫描所有文件，这使得性能得到提升</em></p><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_skewed(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">   )</span><br><span class="line">   SKEWED <span class="keyword">BY</span> (empno) <span class="keyword">ON</span> (<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>)  <span class="comment">--指定 empno 的倾斜值 66,88,100</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_skewed'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903193642678.png?imageslim" alt="image-20200903193642678"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>storm心得-下</title>
      <link href="/2020/08/06/storm%E5%BF%83%E5%BE%97-%E4%B8%8B/"/>
      <url>/2020/08/06/storm%E5%BF%83%E5%BE%97-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="dubbo的引入"><a class="header-anchor" href="#dubbo的引入"></a>dubbo的引入</h2><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进<br><img src="https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim" alt="mark"></p><ul><li><p>单一应用架构<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。</p></li><li><p>垂直应用架构<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的  Web框架(MVC)  是关键。</p></li><li><p>分布式服务架构<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。</p></li><li><p>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率<br>此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。</p></li></ul><p>在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p><ol><li>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。<br>此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</li><li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。<br>这时，需要自动画出应用间的依赖关系图，以理清理关系。</li><li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？<br>为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。<br>其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</li></ol><h3 id="Dubbo的工作原理"><a class="header-anchor" href="#Dubbo的工作原理"></a>Dubbo的工作原理</h3><p><img src="https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim" alt="mark"></p><h3 id="节点角色说明："><a class="header-anchor" href="#节点角色说明："></a>节点角色说明：</h3><ul><li>Provider:  暴露服务的服务提供方。</li><li>Consumer:  调用远程服务的服务消费方。</li><li>Registry:  服务注册与发现的注册中心。</li><li>Monitor:  统计服务的调用次调和调用时间的监控中心。</li><li>Container:  服务运行容器。</li></ul><h3 id="调用关系说明："><a class="header-anchor" href="#调用关系说明："></a>调用关系说明：</h3><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="Dubbo-admin管理平台的安装"><a class="header-anchor" href="#Dubbo-admin管理平台的安装"></a>Dubbo-admin管理平台的安装</h2><h3 id="dubbo-admin-本地编译打包"><a class="header-anchor" href="#dubbo-admin-本地编译打包"></a>dubbo-admin 本地编译打包</h3><p><a href="https://github.com/alibaba/dubbo/releases" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/releases</a><br><a href="https://github.com/apache/incubator-dubbo/releases" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo/releases</a><br>解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址<br><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-ops</a></p><h3 id="克隆项目"><a class="header-anchor" href="#克隆项目"></a>克隆项目</h3><p>apache 下的dubbo-admin git仓库：<br><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-ops</a><br>先把这个项目用git克隆到本地中<br><img src="https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim" alt="mark"></p><h4 id="application-properties配置"><a class="header-anchor" href="#application-properties配置"></a>application.properties配置</h4><p><img src="https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim" alt="mark"></p><h4 id="application-test-properties配置"><a class="header-anchor" href="#application-test-properties配置"></a>application-test.properties配置</h4><p><img src="https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg" alt></p><h4 id="tomcat配置启动项"><a class="header-anchor" href="#tomcat配置启动项"></a>tomcat配置启动项</h4><p><img src="https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim" alt="mark"></p><h4 id="配置部署war包"><a class="header-anchor" href="#配置部署war包"></a>配置部署war包</h4><p><img src="https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim" alt="mark"><br><img src="https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim" alt="mark"></p><h4 id="说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。"><a class="header-anchor" href="#说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。"></a>说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。</h4><h4 id="Production-Setup"><a class="header-anchor" href="#Production-Setup"></a>Production Setup</h4><ol><li>Clone source code on develop branch git clone <a href="https://github.com/apache/incubator-dubbo-admin.git" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-admin.git</a></li><li>Specify registry address in dubbo-admin-server/src/main/resources/application.properties</li><li>Build<br>mvn clean package<br><img src="https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim" alt="mark"></li><li>Start<br>mvn --projects dubbo-admin-server spring-boot:run<br><strong>启动Zookeeper集群</strong><br><img src="https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim" alt="mark"><br><img src="https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim" alt="mark"></li><li>Visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim" alt="mark"></li></ol><h3 id="报错1"><a class="header-anchor" href="#报错1"></a>报错1</h3><p><img src="https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim" alt="mark"></p><h3 id="解决办法"><a class="header-anchor" href="#解决办法"></a>解决办法</h3><p>如果SpringBoot在子模块，直接main启动子模块会报错。<br>解决办法就是在IDEA MAVEN Projects-&gt;dubbo-admin-server-&gt;Plugins-&gt;spring-boot-&gt;spring-boot:run-&gt;run maven build<br><img src="https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim" alt="mark"></p><h3 id="报错2"><a class="header-anchor" href="#报错2"></a>报错2</h3><p><img src="https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim" alt="mark"></p><h3 id="解决办法-v2"><a class="header-anchor" href="#解决办法-v2"></a>解决办法</h3><p>taskkill /pid 8876 /f</p><p><img src="https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim" alt="mark"></p><h2 id="zookeeper与dubbo关系"><a class="header-anchor" href="#zookeeper与dubbo关系"></a>zookeeper与dubbo关系</h2><p>dubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；</p><h2 id="Netty在Dubbo中的应用"><a class="header-anchor" href="#Netty在Dubbo中的应用"></a>Netty在Dubbo中的应用</h2><p><strong>Dubbo 底层使用的是 Netty 作为网络通信</strong></p><ol><li>dubbo的Consumer消费者如何使用Netty</li></ol><h3 id="调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。"><a class="header-anchor" href="#调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。"></a>调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get remote service proxy</span></span><br><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br></pre></td></tr></table></figure><h3 id="调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存"><a class="header-anchor" href="#调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存"></a>调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">getSharedClient</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">String key=url.getAddress();</span><br><span class="line">ReferenceCountExchangeClient client=referenceClientMap.get(key);</span><br><span class="line"><span class="keyword">if</span>(client!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!=client.isClosed())&#123;</span><br><span class="line">client.incrementAndGetCount();</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">referenceClientMap.remove(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(key.intern())&#123;</span><br><span class="line"><span class="comment">//这个initClient()方法是创建Netty的client的</span></span><br><span class="line">ExchangeClient exchangeClient=initClient(url);</span><br><span class="line">client=<span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient,ghostClientMap);</span><br><span class="line">referenceClientMap.put(key,client);</span><br><span class="line">ghostClientMap.remove(key);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。"><a class="header-anchor" href="#最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。"></a>最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractClient</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    doOpen();</span><br><span class="line">    connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doOpent-方法用来创建-Netty-的-bootstrap-："><a class="header-anchor" href="#doOpent-方法用来创建-Netty-的-bootstrap-："></a>doOpent 方法用来创建 Netty 的 bootstrap ：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ClientBootstrap(channelFactory);</span><br><span class="line">    bootstrap.setOption(<span class="string">"keepAlive"</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">"connectTimeoutMillis"</span>, getTimeout());</span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="connect-方法用来连接提供者："><a class="header-anchor" href="#connect-方法用来连接提供者："></a>connect 方法用来连接提供者：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 </span></span><br><span class="line">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class="line">    <span class="keyword">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class="line">        Channel newChannel = future.getChannel();</span><br><span class="line">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。"><a class="header-anchor" href="#main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。"></a>main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line"><span class="comment">//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  </span></span><br><span class="line">    channel.send(req);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-的-Provider-提供者如何使用-Netty"><a class="header-anchor" href="#dubbo-的-Provider-提供者如何使用-Netty"></a>dubbo 的 Provider 提供者如何使用 Netty</h2><p>Provider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。</p><h3 id="NettyServer-对象的构造方法同样是-doOpen-方法。"><a class="header-anchor" href="#NettyServer-对象的构造方法同样是-doOpen-方法。"></a>NettyServer 对象的构造方法同样是 doOpen 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line"><span class="comment">//boss 线程，worker 线程，和 ServerBootstrap</span></span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"><span class="comment">//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。</span></span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Netty在Dubbo中的应用总结"><a class="header-anchor" href="#Netty在Dubbo中的应用总结"></a>Netty在Dubbo中的应用总结</h3><p>dubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。</p><h2 id="Apache-Storm分布式消息系统"><a class="header-anchor" href="#Apache-Storm分布式消息系统"></a>Apache Storm分布式消息系统</h2><p>Apache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。</p><h3 id="什么是分布式消息系统？"><a class="header-anchor" href="#什么是分布式消息系统？"></a>什么是分布式消息系统？</h3><p>分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。<br>大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。<br>一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。<br>需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。</p><p><img src="https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim" alt="mark"></p><p>下表描述了一些流行的高吞吐量消息传递系统 -<br><img src="https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim" alt="mark"><br>Thrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。<br>Apache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。<br>Storm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。</p><h2 id="Storm工作原理"><a class="header-anchor" href="#Storm工作原理"></a>Storm工作原理</h2><p><img src="https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim" alt="mark"></p><h3 id="Storm与传统关系型数据库"><a class="header-anchor" href="#Storm与传统关系型数据库"></a>Storm与传统关系型数据库</h3><p>传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存<br>传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据<br>关系型数据库重视事务，并发控制，相对来说Storm比较简陋<br>Storm与Hadoop，Spark等是流行的大数据方案<br>与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑</p><ol><li><p>topology<br>Storm集群中有两种组件节点，一种是<strong>控制节点</strong>(Nimbus节点)，另一种是<strong>工作节点</strong>(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。<br>和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去<br>数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。<br><img src="https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim" alt="mark"></p></li><li><p>zookeeper集群<br>storm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。<br>部署zookeeper有些需要注意的地方：<br>①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控<br>②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用</p></li><li><p>Component<br>Storm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口<br>全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。<br><img src="https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim" alt="mark"></p></li><li><p>Spout<br>Spout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①open()方法 – 初始化方法<br>close() – 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行<br>②ack(Object msgId) – 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放<br>③fail(Object msgId) – 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放<br>④nextTuple() – 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout</p></li><li><p>Bolt<br>Bolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成<br>prepare方法 – 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境<br>declareOutputFields方法 – 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似<br>cleanup方法 – 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。<br>execute方法 – 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。<br>Storm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException<br>通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple)</p></li><li><p>Topology运行方式<br>在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式</p></li></ol><h3 id="本地运行的提交方式"><a class="header-anchor" href="#本地运行的提交方式"></a>本地运行的提交方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster(); </span><br><span class="line">cluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); </span><br><span class="line">Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">cluster.shutdown();</span><br></pre></td></tr></table></figure><h3 id="分布式提交方式"><a class="header-anchor" href="#分布式提交方式"></a>分布式提交方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology());</span><br></pre></td></tr></table></figure><p>需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。</p><h3 id="运行的命令如下"><a class="header-anchor" href="#运行的命令如下"></a>运行的命令如下###</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar StormTopology.jar mainclass [args]</span><br></pre></td></tr></table></figure><h2 id="storm守护进程的命令"><a class="header-anchor" href="#storm守护进程的命令"></a>storm守护进程的命令</h2><p>Nimbus: storm nimbus 启动nimbus守护进程<br>Supervisor: storm supervisor 启动supervisor守护迚程<br>UI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。<br>DRPC: storm drpc 启动DRPC的守护进程</p><h2 id="storm管理命令"><a class="header-anchor" href="#storm管理命令"></a>storm管理命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAR：storm jar topology_jar topology_class [arguments...]</span><br></pre></td></tr></table></figure><p>jar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL：storm kill topology_name [-w wait_time]</span><br></pre></td></tr></table></figure><p>杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deactivate：storm deactivate topology_name</span><br></pre></td></tr></table></figure><p>停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activate：storm activate topology_name</span><br></pre></td></tr></table></figure><p>启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]...</span><br></pre></td></tr></table></figure><p>rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8</span><br></pre></td></tr></table></figure><p>还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等</p><h2 id="Storm与Hadoop的对比"><a class="header-anchor" href="#Storm与Hadoop的对比"></a>Storm与Hadoop的对比</h2><p><img src="https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim" alt="mark"></p><h2 id="DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下："><a class="header-anchor" href="#DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下："></a>DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：</h2><p>引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。</p><ol><li>接收到一个RPC调用请求；</li><li>发送请求到Storm上的<strong>拓扑</strong>；</li><li>从Storm上接收计算结果；</li><li>将计算结果返回给客户端。</li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="maven更新镜像源"><a class="header-anchor" href="#maven更新镜像源"></a>maven更新镜像源</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">         <span class="comment">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RPC和MQ对比及其适用-不适用场合"><a class="header-anchor" href="#RPC和MQ对比及其适用-不适用场合"></a>RPC和MQ对比及其适用/不适用场合</h2><h3 id="系统结构"><a class="header-anchor" href="#系统结构"></a>系统结构</h3><p><strong>RPC系统结构：</strong><br>Cosume &lt;=&gt; Provider<br>Consumer调用的Provider提供的服务</p><p><strong>Message Queue系统结构：</strong><br>Sender &lt;=&gt; Queue &lt;=&gt; Reciver<br>Sender发送消息给Queue；Receiver从Queue拿到消息来处理。</p><h3 id="功能的特点"><a class="header-anchor" href="#功能的特点"></a>功能的特点</h3><p>在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。</p><h3 id="消息的特点"><a class="header-anchor" href="#消息的特点"></a>消息的特点</h3><ul><li>Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。</li><li>Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响</li><li>Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。</li><li>所以对于有同步返回需求，用Message Queue则变得麻烦了。</li></ul><h3 id="PRC的特点"><a class="header-anchor" href="#PRC的特点"></a>PRC的特点</h3><ul><li>同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。</li><li>RPC也可以是异步调用。</li><li>由于等待结果，Consumer（Client）会有线程消耗。</li><li>如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。</li></ul><h3 id="适用场合说明"><a class="header-anchor" href="#适用场合说明"></a>适用场合说明</h3><ul><li>希望同步得到结果的场合，RPC合适。</li><li>希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。</li><li>不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。</li><li>随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。</li><li>这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。</li></ul><h3 id="不适用场合说明"><a class="header-anchor" href="#不适用场合说明"></a>不适用场合说明</h3><p>RPC同步调用使用Message Queue来传输调用信息。<br>发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>storm(心得)</title>
      <link href="/2020/01/16/storm%E5%BF%83%E5%BE%97-%E4%B8%8A/"/>
      <url>/2020/01/16/storm%E5%BF%83%E5%BE%97-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Storm入门"><a class="header-anchor" href="#Storm入门"></a>Storm入门</h1><p>Storm是一个<strong>分布式的</strong>，可靠的，容错的<strong>数据流处理系统</strong>。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。<br>Storm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等<br>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的<br>Storm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。<br>一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。<br>注：Storm中的核心术语<br><strong>spout</strong>龙卷，读取原始数据为bolt提供数据<br><strong>bolt</strong> 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果<br><strong>nimbus</strong> 雨云，主节点的守护进程，负责为工作节点分发任务<br><strong>topology</strong> 拓扑结构，Storm的一个任务单元<br><strong>define field(s)</strong> 定义域，由spout或bolt提供，被bolt接收</p><h2 id="Storm应用案例"><a class="header-anchor" href="#Storm应用案例"></a>Storm应用案例</h2><ul><li>数据处理流，Storm不需要中间队列</li><li>连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。</li><li><strong>分布式远程过程调用</strong></li><li>频繁的CPU密集型操作<strong>并行化</strong>。</li></ul><h2 id="Storm组件"><a class="header-anchor" href="#Storm组件"></a>Storm组件</h2><p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。<br>主节点运行着一个叫做<strong>Nimbus</strong>的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。<br><strong>Supervisor</strong>守护进程作为拓扑的一部分运行在工作节点上。<br>一个Storm<strong>拓扑结构</strong>在不同的机器上运行着众多的工作节点。<br>因为Storm在<strong>Zookeeper</strong>或本地磁盘上<strong>维持所有的集群状态</strong>，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康<br>在系统底层，Storm使用了<strong>zeromq</strong>，这是一种先进的，可嵌入的<strong>网络通讯库</strong>，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets</p><h3 id="注：zeromq的特性"><a class="header-anchor" href="#注：zeromq的特性"></a>注：zeromq的特性</h3><ul><li>一个并发架构的Socket库</li><li>对于集群产品和超级计算，比TCP要快</li><li>可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信</li><li>异步I / O的可扩展的多核消息传递应用程序</li><li>利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接<br>注：最新的Storm已不再必须依赖<strong>ZeroMQ</strong>，各种依赖的库和软件也已经有更新的版本。<br>最近版本的Storm支持使用<strong>netty</strong>做消息队列。<br>Netty提供<strong>异步的、事件驱动</strong>的网络应用程序框架和工具，用以快速开发<strong>高性能、高可靠性的</strong>网络服务器和客户端程序。正好是 storm所需要的。</li></ul><h2 id="Storm的特性"><a class="header-anchor" href="#Storm的特性"></a>Storm的特性</h2><ul><li>简化编程：使用Storm，实现实时处理的复杂性被大大降低了</li><li>开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发</li><li>容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。</li><li>可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。</li><li>可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。</li><li>快速：速度是驱动Storm设计的一个关键因素</li><li>事务性：可以为几乎任何计算得到恰好一次消息语义</li></ul><h2 id="安装Storm集群"><a class="header-anchor" href="#安装Storm集群"></a>安装Storm集群</h2><p>要手工安装Storm，需要先安装以下软件</p><ol><li>Zookeeper集群</li><li>Java</li><li>Python</li><li>Unzip命令</li></ol><h3 id="注："><a class="header-anchor" href="#注："></a>注：</h3><p>Nimbus和管理进程将要依赖Java、Python和unzip命令</p><h3 id="前期准备"><a class="header-anchor" href="#前期准备"></a>前期准备</h3><ol><li>准备搭建3节点集群,准备3个虚拟机node1,node2,node3</li><li>配置好hosts映射文件和互相的ssh免密登录</li><li>配置好JDK<br>注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好</li></ol><h3 id="安装storm"><a class="header-anchor" href="#安装storm"></a>安装storm</h3><ol><li>准备好storm安装包</li><li>上传解压重命名为storm到/export/server路径下</li><li>修改配置文件 storm.yaml</li></ol><h3 id="运行"><a class="header-anchor" href="#运行"></a>运行</h3><ul><li>前台启动 (前台启动会占用窗口)<br>（1）在node1上启动 nimbus进程(主节点) 和 web UI<br>（2）在 node2 和 node3 上启动 supervisor(从节点)</li><li>后台启动</li></ul><h4 id="ssh脚本实现一键启动"><a class="header-anchor" href="#ssh脚本实现一键启动"></a>ssh脚本实现一键启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.#!/bin/bash</span><br><span class="line">source /etc/profile</span><br><span class="line">nohup /export/server/storm/bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "node1 nimbus is running"</span><br><span class="line">nohup /export/server/storm/bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "node1 core is running"</span><br><span class="line">for host in node2 node3</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ssh $host "source /etc/profile;nohup /export/server/storm/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;"</span><br><span class="line">echo "$host Supervisor is running"</span><br><span class="line">&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="进入web页面查看集群"><a class="header-anchor" href="#进入web页面查看集群"></a>进入web页面查看集群</h3><h2 id="使用入门"><a class="header-anchor" href="#使用入门"></a>使用入门</h2><h3 id="MAVEN依赖"><a class="header-anchor" href="#MAVEN依赖"></a>MAVEN依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>storm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 目前&lt;scope&gt;可以使用5个值：</span></span><br><span class="line"><span class="comment">    * compile，缺省值，适用于所有阶段，会随着项目一起发布。</span></span><br><span class="line"><span class="comment">    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。</span></span><br><span class="line"><span class="comment">    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。</span></span><br><span class="line"><span class="comment">    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</span></span><br><span class="line"><span class="comment">    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理"><a class="header-anchor" href="#编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理"></a>编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Version: </span></span><br><span class="line"><span class="comment"> * Description: 读取外部文件,把一行一行的数据发送给下游的bolt</span></span><br><span class="line"><span class="comment"> *              类似于hadoop mapreduce的inputformat</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="comment">//BaseBasicSpout</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFileSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector spoutOutputCollector;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader bufferedReader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法, 类似于这个类的构造器, 只被运行一次</span></span><br><span class="line"><span class="comment">     * spout组件读取原始数据为bolt提供数据</span></span><br><span class="line"><span class="comment">     * 一般用来打开数据链接, 打开网络连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象, 一般不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//本地模式</span></span><br><span class="line">            <span class="comment">//this.bufferedReader = new BufferedReader(new FileReader(new File("D:\\wordcount.txt")));</span></span><br><span class="line">            <span class="comment">//集群模式</span></span><br><span class="line">            <span class="keyword">this</span>.bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"//root//stormdata//wordcount.txt"</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.spoutOutputCollector = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个tuple, tuple是数据传送的基本单位</span></span><br><span class="line"><span class="comment">     * 不断地往下一个组件发送tuple消息</span></span><br><span class="line"><span class="comment">     * 这里面是该spout组件的核心逻辑</span></span><br><span class="line"><span class="comment">     * 如从kafka消息队列中拿到数据</span></span><br><span class="line"><span class="comment">     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//一行一行的读取文件内容,并且一行一行的发送</span></span><br><span class="line">            line = bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (line != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//将信息封装成tuple，发送消息给下一个组件</span></span><br><span class="line">        <span class="comment">//this.collector.emit(new Value(this.words[index]));</span></span><br><span class="line"></span><br><span class="line">                spoutOutputCollector.emit(Arrays.asList(line));</span><br><span class="line"></span><br><span class="line"><span class="comment">//每发送一个消息，休眠500ms</span></span><br><span class="line">       <span class="comment">// Thread.sleep(500);</span></span><br><span class="line"><span class="comment">// Utils.sleep(500);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字段声明发出的数据是什么,tuple中的数据的字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"line"</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Bolt类对出入的内容进行单词切分"><a class="header-anchor" href="#编写Bolt类对出入的内容进行单词切分"></a>编写Bolt类对出入的内容进行单词切分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Description: 输入一行一行的数据</span></span><br><span class="line"><span class="comment"> *              对一行数据进行切割</span></span><br><span class="line"><span class="comment"> *              输出单词及单词出现的次数</span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment">//BaseBasicBolt</span></span><br><span class="line"><span class="comment">public class SplitBolt extends BaseRichBolt &#123;</span></span><br><span class="line"><span class="comment">    private OutputCollector outputCollector;</span></span><br><span class="line"><span class="comment">    /**</span></span><br><span class="line"><span class="comment">     * 初始化方法,只被运行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector 数据收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputCollector = outputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行业务逻辑的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tuple 获取的上游数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上游句子(字段:"line"),从tuple中读取数据</span></span><br><span class="line"><span class="comment">//获取nextTuple()方法emit()过来的数据</span></span><br><span class="line">        String line = tuple.getStringByField(<span class="string">"line"</span>);</span><br><span class="line">        <span class="comment">//对句子进行切割</span></span><br><span class="line">        String[] words = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//需要发送单词和单词出现的次数,总共两个字段</span></span><br><span class="line">            outputCollector.emit(Arrays.asList(word, <span class="string">"1"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明发送出去的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"num"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Bolt类对单词进行计数"><a class="header-anchor" href="#编写Bolt类对单词进行计数"></a>编写Bolt类对单词进行计数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce</span></span><br><span class="line"><span class="comment">*              输入单词及单词出现的次数</span></span><br><span class="line"><span class="comment">*              输出打印在控制台</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个map用于储存单词及其数量</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; wordCountMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector 数据收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取信息(单词, 数量)</span></span><br><span class="line">        String word = tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        String num = tuple.getStringByField(<span class="string">"num"</span>);</span><br><span class="line">        <span class="comment">//使用map进行记录</span></span><br><span class="line">        <span class="comment">//开始计数</span></span><br><span class="line">        <span class="keyword">if</span> (wordCountMap.containsKey(word))&#123;</span><br><span class="line">            <span class="comment">//如果map里已经有这个单词,就把数量进行累加</span></span><br><span class="line">            Integer integer = wordCountMap.get(word);</span><br><span class="line">            wordCountMap.put(word, integer + Integer.parseInt(num));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果map里已经没有这个单词,就把单词和数量放入map</span></span><br><span class="line">            wordCountMap.put(word, Integer.parseInt(num));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(wordCountMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于不向外发送数据,所以不用写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写启动类对程序进行整合"><a class="header-anchor" href="#编写启动类对程序进行整合"></a>编写启动类对程序进行整合</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Description: wordcount驱动类,用来提交任务</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WordCountTopology</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException</span> &#123;</span><br><span class="line">        <span class="comment">//通过TopologyBuilder 封装任务信息</span></span><br><span class="line">        TopologyBuilder topologyBuilder = <span class="keyword">new</span> TopologyBuilder();</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//设置spout获取数据</span></span><br><span class="line">        <span class="comment">//SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件</span></span><br><span class="line"><span class="comment">//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task</span></span><br><span class="line"></span><br><span class="line">        topologyBuilder.setSpout(<span class="string">"readfilesspout"</span>, <span class="keyword">new</span> ReadFileSpout(), <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置splitbolt 对句子进行切割</span></span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"splitbolt"</span>, <span class="keyword">new</span> SplitBolt(), <span class="number">4</span>).shuffleGrouping(<span class="string">"readfilesspout"</span>);</span><br><span class="line">        <span class="comment">//设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息</span></span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"wordcountbolt"</span>, <span class="keyword">new</span> WordCountBolt(), <span class="number">2</span>).shuffleGrouping(<span class="string">"splitbolt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备一个配置文件，配置一些topology在集群中运行的参数</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动2个worker!</span></span><br><span class="line">        config.setNumWorkers(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务提交有:本地模式 和 集群模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//本地模式</span></span><br><span class="line">        <span class="comment">//LocalCluster localCluster = new LocalCluster();</span></span><br><span class="line">        <span class="comment">//localCluster.submitTopology("wordcount", config, topologyBuilder.createTopology());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集群模式,参数:Topology名字, 配置文件, Topology对象</span></span><br><span class="line"><span class="comment">//用builder来创建topology</span></span><br><span class="line">        StormSubmitter.submitTopology(<span class="string">"wordcount2"</span>, config, topologyBuilder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行程序"><a class="header-anchor" href="#执行程序"></a>执行程序</h3><ol><li>选择本地模式运行<br>直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台</li><li>选择上传到集群进行执行<br>首先通过maven的package命名将程序打好jar包</li></ol><h4 id="注：-v2"><a class="header-anchor" href="#注：-v2"></a>注：</h4><p>在storm-core的依赖中加入:<scope>provided</scope><br>在上传到node2或node3上, 在指定路径下要确保存在日志文件</p><h1 id="Storm-Distributed-RPC（DRPC）"><a class="header-anchor" href="#Storm-Distributed-RPC（DRPC）"></a>Storm Distributed RPC（DRPC）</h1><h2 id="分布式远程过程调用"><a class="header-anchor" href="#分布式远程过程调用"></a>分布式远程过程调用</h2><ul><li>DRPC的主要作用就是利用Storm的<strong>实时计算</strong>能力来<strong>并行化</strong>CPU intensive的计算。</li><li>对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。</li><li>DRPC其实不能算是storm本身的一个特性，它是通过组合storm的<strong>原语</strong>spout，bolt，topology而成的一种模式(pattern)。</li><li>DRPC通过一个&quot;DRPC server&quot;来进行<strong>协调均衡</strong>。（Storm整合了DRPC server的一个实现）。</li><li>DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。</li><li>对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。</li></ul><h3 id="客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果："><a class="header-anchor" href="#客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果："></a>客户端使用DRPC来获取以&quot;<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a>&quot;为参数的&quot;reach&quot;函数的返回结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"drpc-host"</span>, <span class="number">3772</span>);</span><br><span class="line">String result = client.execute(<span class="string">"reach"</span>, <span class="string">"http://baidu.com"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim" alt="mark"></p><h4 id="1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用"><a class="header-anchor" href="#1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用"></a>1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用</h4><h4 id="2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。"><a class="header-anchor" href="#2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。"></a>2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。</h4><h4 id="3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。"><a class="header-anchor" href="#3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。"></a>3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。</h4><h4 id="4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。"><a class="header-anchor" href="#4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。"></a>4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。</h4><h4 id="5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。"><a class="header-anchor" href="#5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。"></a>5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。</h4><h2 id="LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）"><a class="header-anchor" href="#LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）"></a>LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）</h2><h3 id="Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下"><a class="header-anchor" href="#Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下"></a>Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:</h3><ol><li>建立 spout</li><li>将结果返回到DRPC server</li><li>向bolts提供了在tuples集合上进行有限聚集的功能</li></ol><h4 id="创建LinearDRPCTopologyBuilder"><a class="header-anchor" href="#创建LinearDRPCTopologyBuilder"></a>创建LinearDRPCTopologyBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclaimBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">        String input = tuple.getString(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//简单的在元组的第二个字段的值后加了一个"!"</span></span><br><span class="line">        collector.emit(<span class="keyword">new</span> Values(tuple.getValue(<span class="number">0</span>), input + <span class="string">"!"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//我们将DRPC函数名告诉给topology（本例函数名为exclamation）。</span></span><br><span class="line">  <span class="comment">//单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。</span></span><br><span class="line">  <span class="comment">//第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。</span></span><br><span class="line">    LinearDRPCTopologyBuilder builder = <span class="keyword">new</span> LinearDRPCTopologyBuilder(<span class="string">"exclamation"</span>);</span><br><span class="line">    builder.addBolt(<span class="keyword">new</span> ExclaimBolt(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Local-mode-DRPC"><a class="header-anchor" href="#创建Local-mode-DRPC"></a>创建Local mode DRPC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。</span></span><br><span class="line">LocalDRPC drpc = <span class="keyword">new</span> LocalDRPC();</span><br><span class="line"><span class="comment">//然后创建LocalCluster来以本地模式来运行该topology。</span></span><br><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line"><span class="comment">//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。</span></span><br><span class="line"><span class="comment">//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象</span></span><br><span class="line"><span class="comment">//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;</span></span><br><span class="line">cluster.submitTopology(<span class="string">"drpc-demo"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class="line"><span class="comment">//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。</span></span><br><span class="line">System.out.println(<span class="string">"Results for 'hello':"</span> + drpc.execute(<span class="string">"exclamation"</span>, <span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">cluster.shutdown();</span><br><span class="line">drpc.shutdown();</span><br></pre></td></tr></table></figure><h4 id="Remote-mode-DRPC"><a class="header-anchor" href="#Remote-mode-DRPC"></a>Remote mode DRPC</h4><ol><li>建立DRPC servers</li><li>配置DRPC servers的位置</li><li>向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：</li></ol><h5 id="1-用storm脚本建立DRPC-server："><a class="header-anchor" href="#1-用storm脚本建立DRPC-server："></a>1. 用storm脚本建立DRPC server：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/storm drpc</span><br></pre></td></tr></table></figure><h5 id="2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置"><a class="header-anchor" href="#2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置"></a>2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drpc.servers:</span><br><span class="line">  - <span class="string">"drpc1.foo.com"</span></span><br><span class="line">  - <span class="string">"drpc2.foo.com"</span></span><br></pre></td></tr></table></figure><h5 id="3-通过StormSubmitter建立DRPC-topologies"><a class="header-anchor" href="#3-通过StormSubmitter建立DRPC-topologies"></a>3. 通过StormSubmitter建立DRPC topologies</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology(<span class="string">"exclamation-drpc"</span>, conf, builder.createRemoteTopology());</span><br></pre></td></tr></table></figure><h2 id="Storm-DRPC深入"><a class="header-anchor" href="#Storm-DRPC深入"></a>Storm DRPC深入</h2><p>分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的<strong>函数调用</strong>进行<strong>并行计算</strong>。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。<br>可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。</p><h3 id="注：-v3"><a class="header-anchor" href="#注：-v3"></a>注：</h3><p>Storm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）<br>Storm只负责数据的计算，不负责数据的存储<br>2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x</p><p><img src="https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim" alt="mark"><br><strong>其中:</strong><br>Nimbus：负责资源分配和任务调度。<br>Supervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>Worker：运行具体处理组件逻辑的进程。<br>Task：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。<br><img src="https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim" alt="mark"></p><h3 id="注：-v4"><a class="header-anchor" href="#注：-v4"></a>注：</h3><p><strong>DataSource</strong>: 数据源<br><strong>Spout</strong>：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。<br><strong>Bolt</strong>：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。<br><strong>Tuple</strong>：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.<br><strong>Stream</strong>：源源不断传递的tuple就组成了stream。<br><strong>Topology</strong>：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。</p><h3 id="分组策略"><a class="header-anchor" href="#分组策略"></a>分组策略</h3><ol><li>随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用</li><li>字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。</li><li>LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。</li></ol><h2 id="zookeeper安装和使用"><a class="header-anchor" href="#zookeeper安装和使用"></a>zookeeper安装和使用</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p><h3 id="zoo-sample-cfg文件配置"><a class="header-anchor" href="#zoo-sample-cfg文件配置"></a>zoo_sample.cfg文件配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">D:\\DevelopSoftware\\zookeeper\\zookeeper-3.4.14\\data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">D:\\DevelopSoftware\\zookeeper\\zookeeper-3.4.14\\log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure><h3 id="参数解释"><a class="header-anchor" href="#参数解释"></a>参数解释</h3><ul><li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li><li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒</li><li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒</li><li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li><li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li></ul><h3 id="异常"><a class="header-anchor" href="#异常"></a>异常</h3><p>Socket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information<br>**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg</p><p>zookeeper启动成功<br><img src="https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim" alt="mark"></p><h2 id="Zookeeper伪分布式集群搭建"><a class="header-anchor" href="#Zookeeper伪分布式集群搭建"></a>Zookeeper伪分布式集群搭建</h2><ol><li>将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。</li><li>创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。</li><li>在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.</li><li>修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改</li></ol><h3 id="zoo-cfg文件如下"><a class="header-anchor" href="#zoo-cfg文件如下"></a>zoo.cfg文件如下</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># 服务器与客户端之间交互的基本时间单元（ms）</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># zookeeper所能接受的客户端数量</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># 服务器与客户端之间请求和应答的时间间隔</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 保存zookeeper数据，日志路径</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">D:/DevelopSoftware/zookeeper/zk-data/8001/data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">D:/DevelopSoftware/zookeeper/zk-data/8001/log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 这是客户端链接的端口号</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口</span></span><br><span class="line"><span class="comment"># server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。</span></span><br><span class="line"><span class="comment"># 客户端与zookeeper相互交互的端口</span></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:8001:9001</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:8002:9002</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:8003:9003</span></span><br></pre></td></tr></table></figure><h3 id="报错"><a class="header-anchor" href="#报错"></a>报错</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> [myid:<span class="number">1</span>] - WARN  [WorkerSender[myid=<span class="number">1</span>]:QuorumCnxManager@<span class="number">584</span>] - Cannot open channel to <span class="number">3</span> at election address /<span class="number">127.0</span>.0.1:<span class="number">9003</span></span><br><span class="line">java.net.ConnectException: Connection refused: connect</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:<span class="number">85</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span><br><span class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:<span class="number">172</span>)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:<span class="number">392</span>)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:<span class="number">589</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:<span class="number">558</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:<span class="number">534</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:<span class="number">454</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:<span class="number">435</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><h3 id="报错解决办法"><a class="header-anchor" href="#报错解决办法"></a>报错解决办法</h3><p>产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty教程</title>
      <link href="/2020/01/16/Netty%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/16/Netty%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="业界哪些流行的开源框架用Netty作为底层通信框架"><a class="header-anchor" href="#业界哪些流行的开源框架用Netty作为底层通信框架"></a>业界哪些流行的开源框架用Netty作为底层通信框架</h2><ul><li>Dubbo： 阿里开源的高性能RPC框架</li><li>RocketMQ： 阿里出品的高性能消息队列</li><li>Spark： 炙手可热的大数据处理引擎，底层使用Netty</li><li>Elasticsearch： 分布式多用户的全文搜索引擎</li><li>Apache Cassandra：开源分布式搜索数据库</li><li>Flink:分布式高性能高可用的流处理框架</li><li>Netty-SocketIO的java服务端实现</li><li>Spring5：使用Netty作为http协议框架</li><li>Play：简单易用的http服务器</li><li>Grpc:google开源的高性能rpc通信框架</li><li>Infinispan：针对缓存的高并发键值对数据存储</li><li>HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统</li><li>Vert.x轻量级高性能能JVM应用平台<br>-<br><a href="https://netty.io/wiki/adopters.html" target="_blank" rel="noopener">完整的参考列表</a></li></ul><h2 id="业界有哪些公司在使用Netty"><a class="header-anchor" href="#业界有哪些公司在使用Netty"></a>业界有哪些公司在使用Netty</h2><p><strong>在大型企业中</strong>有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram<br><br><strong>在初创企业中</strong>有：做http长连接的<strong>Firebase</strong>、支持各种各样消息推送通知的<strong>Urban Airship</strong><br><br><br> 当然，Netty也从这些项目中<strong>受益</strong>。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。</p><h2 id="Netty是什么"><a class="header-anchor" href="#Netty是什么"></a>Netty是什么</h2><ol><li><strong>异步</strong>和<strong>事件驱动</strong>的高性能网络通信框架。</li><li>**特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。</li><li>**目的:**用于快速开发高性能服务端和客户端</li><li>**封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易</li><li>自带编解码器解决拆包粘包问题，用户只关心业务逻辑</li><li>精心设计的reactor线程模型支持高并发海量连接</li><li>自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手</li><li>**架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离–业务和网络逻辑解耦，模块化和可复用性，可测试性。</li></ol><h2 id="Netty的特性总结"><a class="header-anchor" href="#Netty的特性总结"></a>Netty的特性总结</h2><p><img src="https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim" alt="mark"></p><h2 id="Socket-Netty"><a class="header-anchor" href="#Socket-Netty"></a>Socket &amp; Netty</h2><p><img src="https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim" alt="Socket &amp; Netty"></p><h2 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h2><p><img src="https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim" alt="mark"></p><ul><li>NioEventLoop -&gt;Thread</li><li>Channel -&gt;Socket  <br>NioSocketChannel implements Channel<br>Chennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind</li><li>ByteBuf -&gt;IO Bytes<br>readBytes()、writeBytes() and so on</li><li>Pipline -&gt;Logic Chain 逻辑链</li><li>ChannelHandler -&gt;Logic处理块</li></ul><h2 id="Netty核心组件"><a class="header-anchor" href="#Netty核心组件"></a>Netty核心组件</h2><h3 id="1-Channel-Socket"><a class="header-anchor" href="#1-Channel-Socket"></a>1. Channel-Socket</h3><p>Channel是通讯的载体，其基本构造是Socket<br>是对网络底层读写和连接原语言的抽象</p><h3 id="2-EventLoop-控制流、多线程处理、并发"><a class="header-anchor" href="#2-EventLoop-控制流、多线程处理、并发"></a>2. EventLoop-控制流、多线程处理、并发</h3><p>定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件</p><h3 id="注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"><a class="header-anchor" href="#注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"></a>注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系</h3><p><img src="https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim" alt="mark">)</p><h5 id="A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"><a class="header-anchor" href="#A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"></a>A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；</h5><h5 id="B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"><a class="header-anchor" href="#B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"></a>B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定</h5><h5 id="C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"><a class="header-anchor" href="#C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"></a>C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</h5><h5 id="D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"><a class="header-anchor" href="#D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"></a>D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；</h5><h5 id="E-一个-EventLoop-可能会被分配给一个或多个-Channel"><a class="header-anchor" href="#E-一个-EventLoop-可能会被分配给一个或多个-Channel"></a>E. 一个 EventLoop 可能会被分配给一个或多个 Channel</h5><h5 id="F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"><a class="header-anchor" href="#F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"></a>F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。</h5><h3 id="3-ChannelFuture-异步通知"><a class="header-anchor" href="#3-ChannelFuture-异步通知"></a>3. ChannelFuture-异步通知</h3><p>Netty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法</p><h3 id="4-ChannelHandler和ChannelPipeline"><a class="header-anchor" href="#4-ChannelHandler和ChannelPipeline"></a>4. ChannelHandler和ChannelPipeline</h3><p>ChannelHandler负责Channel中的逻辑处理<br>其旨在简化应用程序处理逻辑的开发过程<br>充当了所有处理入站和出站数据的应用程序逻辑的容器<br>ChannelHandler子接口：<br>ChannelInboundHandler——处理入站数据以及各种状态变化<br>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作<br>ChannelInboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim" alt="mark"><br>ChannelOutboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim" alt="mark"></p><p>ChannelPipeline 提供了 ChannelHandler链的容器<br>定义了用于在该链上传播入站和出站事件流的API</p><h3 id="5-ByteBuf-Netty的数据容器"><a class="header-anchor" href="#5-ByteBuf-Netty的数据容器"></a>5. ByteBuf-Netty的数据容器</h3><p>Java NIO提供了ByteBuffer作为它的字节容器<br>Netty的ByteBuffer替代品是ByteBuf</p><h5 id="A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"><a class="header-anchor" href="#A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"></a>A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；</h5><h5 id="B-容量可以按需增长（类似于-JDK-的-StringBuilder）"><a class="header-anchor" href="#B-容量可以按需增长（类似于-JDK-的-StringBuilder）"></a>B.容量可以按需增长（类似于 JDK 的 StringBuilder）</h5><h5 id="C-读和写使用了不同的索引"><a class="header-anchor" href="#C-读和写使用了不同的索引"></a>C.读和写使用了不同的索引</h5><h5 id="D-支持方法的链式调用"><a class="header-anchor" href="#D-支持方法的链式调用"></a>D.支持方法的链式调用</h5><h5 id="E-支持引用计数"><a class="header-anchor" href="#E-支持引用计数"></a>E.支持引用计数</h5><h5 id="F-支持池化"><a class="header-anchor" href="#F-支持池化"></a>F.支持池化</h5><h3 id="6-Bootstap-引导客户端和无连接协议"><a class="header-anchor" href="#6-Bootstap-引导客户端和无连接协议"></a>6. Bootstap-引导客户端和无连接协议</h3><p>Bootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel<br><img src="http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg" alt></p><h2 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h2><p>使用EmbeddedChannel 测试 ChannelHandler</p><ol><li>测试入站消息</li><li>测试出站消息</li><li>测试异常处理</li></ol><h2 id="编解码器"><a class="header-anchor" href="#编解码器"></a>编解码器</h2><ul><li>解码器<br>将字节解码为消息<br>将一种消息类型解码为另一种</li><li>编码器<br>将消息编码为字节<br>将消息编码为消息</li></ul><h2 id="Netty服务端启动"><a class="header-anchor" href="#Netty服务端启动"></a>Netty服务端启动</h2><ol><li>创建服务端Channel</li><li>初始化服务端Channel</li><li>注册Selector</li><li>端口绑定，实现对本地端口的接听</li></ol><h2 id="预置的ChannelHandler和编解码器"><a class="header-anchor" href="#预置的ChannelHandler和编解码器"></a>预置的ChannelHandler和编解码器</h2><ol><li>通过 SSL/TLS 保护 Netty 应用程序</li><li>ChannelHandler处理 HTTP 和 HTTPS协议</li><li>支持WebSocket</li><li>ChannelHandler检测空闲连接以及超时</li><li>FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域</li><li>使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据</li><li>使用UDP广播事件</li></ol><h3 id="创建服务端Channel"><a class="header-anchor" href="#创建服务端Channel"></a>创建服务端Channel</h3><p><strong>bind()[用户代码入口] -&gt;initAndRegister()[初始化并注册] -&gt;newChannel()[创建服务端channel]</strong><br><img src="https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim" alt="mark"></p><h2 id="如何使用Netty进行RPC服务器的开发"><a class="header-anchor" href="#如何使用Netty进行RPC服务器的开发"></a>如何使用Netty进行RPC服务器的开发?</h2><ol><li>定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</li><li>服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</li><li>客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</li><li>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</li><li>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。<br><img src="https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim" alt="mark"> <strong>客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。</strong><br>Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</li><li><img src="https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim" alt="mark"><br><strong>客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</strong></li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="Netty疑问"><a class="header-anchor" href="#Netty疑问"></a>Netty疑问</h3><ol><li>Netty是什么？<br>Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。</li><li>使用Netty能够做什么？<br>①开发异步、非阻塞的TCP网络应用程序；<br>②开发异步、非阻塞的UDP网络应用程序；<br>③开发异步文件传输应用程序；<br>④开发异步HTTP服务端和客户端应用程序；<br>⑤提供对多种编解码框架的集成；<br>⑥提供形式多样的编解码基础类库；<br>⑦基于职责链模式的Pipeline-Handler机制；<br>⑧所有的IO操作都是异步的；<br>⑨IP黑白名单控制，性能统计；<br>⑩基于链路空闲事件检测的心跳检测；</li><li>Netty在哪些行业得到了应用<br>**①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。<br>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。<br>除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。<br>**②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。<br>**③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。<br>**④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。<br>**⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。</li><li>使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？<br>传统的同步阻塞IO通信存在如下几个问题：<br>**①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>**②性能差：**频繁的线程上下文切换导致CPU利用效率不高；<br>**③可靠性差：*<em>由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br><strong>采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：</strong><br>①Nio采用Reactor模式</em>，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N &lt; 进程可用的最大句柄数)；<br>②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；<br>③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。<br><strong>由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。</strong></li><li>为什么不直接基于JDK的NIO类库编程呢？<br>即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。</li><li>为什么要选择Netty框架？<br>Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。<br>Netty的优点总结如下：<br>①API使用简单，开发门槛低；<br>②功能强大，预置了多种编解码功能，支持多种主流协议；<br>③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；<br>④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；<br>⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；<br>⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；<br>⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。</li></ol><h2 id="代码"><a class="header-anchor" href="#代码"></a>代码</h2><h3 id="1-基于Netty的客户端和服务端的简单通信"><a class="header-anchor" href="#1-基于Netty的客户端和服务端的简单通信"></a>1. 基于Netty的客户端和服务端的简单通信</h3><h5 id="要点："><a class="header-anchor" href="#要点："></a>要点：</h5><p>①为初始化客户端， 创建了一个 Bootstrap 实例<br>②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；<br>③为服务器连接创建了一个 InetSocketAddress 实例；<br>④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；<br>⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；<br><img src="https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim" alt="mark"></p><p><code>&lt;!--more--&gt;</code></p><h3 id="EchoServer"><a class="header-anchor" href="#EchoServer"></a>EchoServer</h3><h3 id="EchoServerHandler"><a class="header-anchor" href="#EchoServerHandler"></a>EchoServerHandler</h3><h5 id="channelRead-—对于每个传入的消息都要调用；"><a class="header-anchor" href="#channelRead-—对于每个传入的消息都要调用；"></a>channelRead()—对于每个传入的消息都要调用；</h5><h5 id="channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"><a class="header-anchor" href="#channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"></a>channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；</h5><h5 id="exceptionCaught-—在读取操作期间，有异常抛出时会调用。"><a class="header-anchor" href="#exceptionCaught-—在读取操作期间，有异常抛出时会调用。"></a>exceptionCaught()—在读取操作期间，有异常抛出时会调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标示一个ChannelHandler可以被多个 Channel 安全地共享</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//将消息记录到控制台</span></span><br><span class="line">        System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">//将接收到的消息写给发送者，而不冲刷出站消息</span></span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将未决消息冲刷到远程节点，并且关闭该 Channel</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印异常栈跟踪</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="comment">//关闭该Channel</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EchoServer-v2"><a class="header-anchor" href="#EchoServer-v2"></a>EchoServer</h3><h5 id="绑定到服务器将在其上监听并接受传入连接请求的端口；"><a class="header-anchor" href="#绑定到服务器将在其上监听并接受传入连接请求的端口；"></a>绑定到服务器将在其上监听并接受传入连接请求的端口；</h5><h5 id="配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"><a class="header-anchor" href="#配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"></a>配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoServer.class.getSimpleName() +<span class="string">" &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span></span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//调用服务器的 start()方法</span></span><br><span class="line">        <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="comment">//(1) 创建EventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//(2) 创建ServerBootstrap</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//(3) 指定所使用的 NIO 传输 Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//(4) 使用指定的端口设置套接字地址</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    <span class="comment">//(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例</span></span><br><span class="line">                            <span class="comment">//这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，</span></span><br><span class="line">                            ch.pipeline().addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成</span></span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            System.out.println(EchoServer.class.getName() +</span><br><span class="line">                    <span class="string">" started and listening for connections on "</span> + f.channel().localAddress());</span><br><span class="line">            <span class="comment">//(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//(8) 关闭 EventLoopGroup，释放所有的资源</span></span><br><span class="line">            grop.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-ChannelHandler-实现客户端逻辑"><a class="header-anchor" href="#通过-ChannelHandler-实现客户端逻辑"></a>通过 ChannelHandler 实现客户端逻辑</h3><h5 id="channelActive-——在到服务器的连接已经建立之后将被调用；"><a class="header-anchor" href="#channelActive-——在到服务器的连接已经建立之后将被调用；"></a>channelActive()——在到服务器的连接已经建立之后将被调用；</h5><h5 id="channelRead0-——当服务器接收到一条消息时被调用"><a class="header-anchor" href="#channelRead0-——当服务器接收到一条消息时被调用"></a>channelRead0()——当服务器接收到一条消息时被调用</h5><h5 id="exceptionCaught-——在处理过程中引发异常时被调用。"><a class="header-anchor" href="#exceptionCaught-——在处理过程中引发异常时被调用。"></a>exceptionCaught()——在处理过程中引发异常时被调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="comment">//标记该类的实例可以被多个 Channel 共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当被通知 Channel是活跃的时候，发送一条消息</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty rocks!"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录已接收消息的转储</span></span><br><span class="line">        System.out.println(<span class="string">"Client received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在发生异常时，记录错误并关闭Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导客户端"><a class="header-anchor" href="#引导客户端"></a>引导客户端</h3><h5 id="客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"><a class="header-anchor" href="#客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"></a>客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建 Bootstrap</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现</span></span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//适用于 NIO 传输的Channel 类型</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置服务器的InetSocketAddress</span></span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">                    <span class="comment">//在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(</span><br><span class="line">                                    <span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//连接到远程节点，阻塞等待直到连接完成</span></span><br><span class="line">            ChannelFuture f = b.connect().sync();</span><br><span class="line">            <span class="comment">//阻塞，直到Channel 关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池并且释放所有的资源</span></span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() +</span><br><span class="line">                    <span class="string">" &lt;host&gt; &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"><a class="header-anchor" href="#2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"></a>2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架</h3><h5 id="简易RPC有如下特性："><a class="header-anchor" href="#简易RPC有如下特性："></a>简易RPC有如下特性：</h5><ul><li>服务异步调用的支持，回调函数callback的支持</li><li>客户端使用长连接（在多次调用共享连接）</li><li>服务端异步多线程处理RPC请求</li><li>服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。</li><li>通信：使用Netty作为通信框架</li><li>Spring：使用Spring配置服务，加载Bean，扫描注解</li><li>动态代理：客户端使用代理模式透明化服务调用</li><li>消息编解码：使用Protostuff序列化和反序列化消息</li></ul><h5 id="RPC介绍"><a class="header-anchor" href="#RPC介绍"></a>RPC介绍</h5><p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。</p><p><img src="https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim" alt="mark"></p><ul><li>服务端发布服务</li></ul><h5 id="服务注解："><a class="header-anchor" href="#服务注解："></a>服务注解：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务接口："><a class="header-anchor" href="#一个服务接口："></a>一个服务接口：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">hello</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务实现：使用注解标注："><a class="header-anchor" href="#一个服务实现：使用注解标注："></a>一个服务实现：使用注解标注：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RpcService</span>(HelloService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + person.getFirstName() + <span class="string">" "</span> + person.getLastName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务在启动的时候扫描得到所有的服务接口及其实现："><a class="header-anchor" href="#服务在启动的时候扫描得到所有的服务接口及其实现："></a>服务在启动的时候扫描得到所有的服务接口及其实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">      <span class="keyword">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class="line">            handlerMap.put(interfaceName, serviceBean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="在Zookeeper集群上注册服务地址："><a class="header-anchor" href="#在Zookeeper集群上注册服务地址："></a>在Zookeeper集群上注册服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedExceptin ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端使用代理模式调用服务："><a class="header-anchor" href="#客户端使用代理模式调用服务："></a>客户端使用代理模式调用服务：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Zookeeper上获取服务地址："><a class="header-anchor" href="#从Zookeeper上获取服务地址："></a>从Zookeeper上获取服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceDiscovery</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">        ZooKeeper zk = connectServer();</span><br><span class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">            watchNode(zk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = dataList.size();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">                data = dataList.get(<span class="number">0</span>);</span><br><span class="line">                LOGGER.debug(<span class="string">"using only data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class="line">                LOGGER.debug(<span class="string">"using random data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watchNode</span><span class="params">(<span class="keyword">final</span> ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        watchNode(zk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : nodeList) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class="string">"/"</span> + node, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                dataList.add(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(<span class="string">"node data: &#123;&#125;"</span>, dataList);</span><br><span class="line">            <span class="keyword">this</span>.dataList = dataList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterrupteException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息编码-请求消息："><a class="header-anchor" href="#消息编码-请求消息："></a>消息编码 请求消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameterTypes</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getParameters() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(Object[] parameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="响应消息："><a class="header-anchor" href="#响应消息："></a>响应消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息序列化和反序列化工具：（基于-Protostuff-实现）"><a class="header-anchor" href="#消息序列化和反序列化工具：（基于-Protostuff-实现）"></a>消息序列化和反序列化工具：（基于 Protostuff 实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Objenesis objenesis = <span class="keyword">new</span> ObjenesisStd(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializationUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Schema&lt;T&gt; <span class="title">getSchema</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class="line">        <span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</span><br><span class="line">            schema = RuntimeSchema.createFrom(cls);</span><br><span class="line">            <span class="keyword">if</span> (schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedSchema.put(cls, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化（对象 -&gt; 字节数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();</span><br><span class="line">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化（字节数组 -&gt; 对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T message = (T) objenesis.newInstance(cls);</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(data, message, schema);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStatexception(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能改进-服务端请求异步处理"><a class="header-anchor" href="#性能改进-服务端请求异步处理"></a>性能改进 服务端请求异步处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,<span class="keyword">final</span> RpcRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcServer.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                LOGGER.debug(<span class="string">"Receive request "</span> + request.getRequestId());</span><br><span class="line">                RpcResponse response = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                response.setRequestId(request.getRequestId());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object result = handle(request);</span><br><span class="line">                    response.setResult(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    response.setError(t.toString());</span><br><span class="line">                    LOGGER.error(<span class="string">"RPC Server handle request error"</span>,t);</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        LOGGER.debug(<span class="string">"Send response for request "</span> + request.getRequestId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="服务端长连接的管理"><a class="header-anchor" href="#服务端长连接的管理"></a>服务端长连接的管理</h5><p>客户端保持和服务进行<strong>长连接</strong>，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。<br>通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。</p><h5 id="客户端请求异步处理"><a class="header-anchor" href="#客户端请求异步处理"></a>客户端请求异步处理</h5><p><strong>客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);</span><br><span class="line">RPCFuture helloFuture = client.call(<span class="string">"hello"</span>, Integer.toString(i));</span><br><span class="line">String result = (String) helloFuture.get(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(上)</title>
      <link href="/2020/01/16/RocketMQ-%E4%B8%8A/"/>
      <url>/2020/01/16/RocketMQ-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RocketMQ-是什么"><a class="header-anchor" href="#1-RocketMQ-是什么"></a>1. RocketMQ 是什么</h2><h4 id="RocketMQ是一款、、、易于使用的消息中间件"><a class="header-anchor" href="#RocketMQ是一款、、、易于使用的消息中间件"></a>RocketMQ是一款<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、易于使用的消息中间件</h4><h4 id="RocketMQ具有以下特性"><a class="header-anchor" href="#RocketMQ具有以下特性"></a>RocketMQ具有以下特性</h4><ul><li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li><li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li><li>支持拉（pull）和推（push）两种消息模式</li><li>单一队列百万消息的堆积能力</li><li>支持多种消息协议，如 JMS、MQTT 等</li><li>分布式高可用的部署架构,满足至少一次消息传递语义</li><li>提供 docker 镜像用于隔离测试和云集群部署</li><li>提供配置、指标和监控等功能丰富的 Dashboard</li></ul><blockquote><h3 id="Producer"><a class="header-anchor" href="#Producer"></a>Producer</h3><p><strong>消息生产者</strong>，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。</p><h3 id="Producer-Group"><a class="header-anchor" href="#Producer-Group"></a>Producer Group</h3><p><strong>生产者组</strong>，就是多个发送同一类消息的生产者称之为一个生产者组。</p></blockquote><blockquote><h3 id="Consumer"><a class="header-anchor" href="#Consumer"></a>Consumer</h3><p><strong>消息消费者</strong>，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p><h3 id="Consumer-Group"><a class="header-anchor" href="#Consumer-Group"></a>Consumer Group</h3><p><strong>消费者组</strong>，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></blockquote><blockquote><h3 id="Topic"><a class="header-anchor" href="#Topic"></a>Topic</h3><p><em>Topic</em> 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推</p><h3 id="Message"><a class="header-anchor" href="#Message"></a>Message</h3><p><em>Message</em>是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p></blockquote><blockquote><h3 id="Tag"><a class="header-anchor" href="#Tag"></a>Tag</h3><p><em>Tag</em><strong>标签</strong>可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息</p><h3 id="Broker"><a class="header-anchor" href="#Broker"></a>Broker</h3><p><em>Broker</em>是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备</p><h3 id="Name-Server"><a class="header-anchor" href="#Name-Server"></a>Name Server</h3><p><em>Name Server</em> 为 producer 和 consumer 提供路由信息。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>响应时间低，比如一个网页在几秒内打开，越短表示延迟越低 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>指的是运行时间能够满足预计时间的一个系统或组件 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
