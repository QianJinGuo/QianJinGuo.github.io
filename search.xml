<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"/>
      <url>/2022/01/14/%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="字节数组"><a class="header-anchor" href="#字节数组"></a>字节数组</h1><p>#字节 #字节数组 #缓存</p><h1 id="字节属于最小单位"><a class="header-anchor" href="#字节属于最小单位"></a>字节属于最小单位</h1><p>例如在Java中，int占用4个字节，long占用8个字节等。基本上所有基本类型(包括String)都可以转换成字节，那么这到底有何作用。<br>在实际开发中，经常会用到本地缓存，或使用<code>Redis</code>或者<code>Memcached</code>来作分布式缓存,Java一般存入缓存中的对象无非是以下几种:</p><ul><li>序列化的Java对象：一个Java对象序列化后所占用的字节是按对象中属性个数，方法个数，以及属性的值决定，最小也需要几百个字节来存储，大的话可能需要几万个字节</li><li>String(可能是json串)：占用字节由字符串的长度决定</li><li>规则的byte[]数组：占用字节由数组长度决定，相比较于String来说，基本类型转换成固定字节的数组，而不是转换成内容长度的String，故字节数组所占用的字节比String更少</li></ul><blockquote><ol><li>在大量的缓存数据(亿级以上)的情况下，为了提高空间利用率，切勿将<strong>Java对象</strong>当做缓存的内容</li><li>字节数组所需空间最少</li></ol></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/665f4dd77f30" target="_blank" rel="noopener">字节数组的妙用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/01/14/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="线程中断"><a class="header-anchor" href="#线程中断"></a>线程中断</h1><p>#线程 #并发</p><h2 id="Thread类详解"><a class="header-anchor" href="#Thread类详解"></a>Thread类详解</h2><ul><li>interrupt</li><li>interrupted</li><li>isInterrupted</li><li>join</li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/xingele0917/p/3994468.html" target="_blank" rel="noopener">并发编程实践</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="线程执行顺序"><a class="header-anchor" href="#线程执行顺序"></a>线程执行顺序</h1><p>#线程 #jvm</p><h2 id="线程执行顺序-v2"><a class="header-anchor" href="#线程执行顺序-v2"></a>线程执行顺序</h2><blockquote><p>jvm为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证[^1]<br><code>1.《深入理解Java虚拟机：JVM高级特性与最佳实践》 — 周志明</code></p></blockquote><p>如果程序没有正确同步，那么可能会存在数据竞争。JMM对数据竞争的定义如下：</p><blockquote><p>在一个线程中写一个变量，在另一个线程中读取同一个变量，而且写和读没有通过同步来排序</p></blockquote><p>顺序一致性模型有以下<strong>两大特性</strong>：</p><ol><li>一个线程中的所有操作必须按照==程序的顺序==来执行</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致内存模型中，每一个操作都必须是原子执行且立即对所有线程可见。</li></ol><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以把顺序顺序一致模型理解为一个单摆，每一个时刻单摆只能到一个位置，对应过来，任何时刻最多只能有一个线程才能连接到内存。</span><br><span class="line">由于重排序的影响，实际指令的执行顺序是不可知的，但是不管如何排序，每个操作能够立即对其他线程可见，所以所有线程看到的都是一样的执行顺序。</span><br><span class="line">但是在JMM中是没有这个规定的，就是说其他线程看到执行顺序与除自己外的线程看到的执行顺序可能是不一致的。</span><br><span class="line">比如，当前线程把写过的数据缓存缓存到写缓存中，在没有刷新到主内存（计算机系统的DRAM）之前，这个写操作对其他线程是不可见的，意味着其他线程认为该线程根本没有执行写操作。</span><br><span class="line">那么何时才能可见呢？只有在当前线程把写缓存中数据刷新到主内存的时候，对其他内存才是可见的。</span><br></pre></td></tr></table></figure><p><strong>如何控制多线程的执行顺序</strong>？</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/hello_worldee/article/details/77823426" target="_blank" rel="noopener">多线程-重排序与顺序一致性</a><br>![[并发编程以及锁.pptx]]![[java多线程相关分享.pptx]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池实现原理"><a class="header-anchor" href="#线程池实现原理"></a>线程池实现原理</h1><p>#线程 #线程池 #并发</p><h2 id="线程池是什么"><a class="header-anchor" href="#线程池是什么"></a>线程池是什么</h2><p>线程池（Thread Pool）是一种基于==池化==思想管理线程的工具，经常出现在多线程服务器中，如MySQL。<br>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h2 id="线程池解决的问题是什么"><a class="header-anchor" href="#线程池解决的问题是什么"></a>线程池解决的问题是什么</h2><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。<br>为解决资源分配这个问题，线程池采用了“==池化==”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</li></ol><blockquote><p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p></blockquote><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。<br>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ol><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ol><h2 id="线程池核心设计与实现"><a class="header-anchor" href="#线程池核心设计与实现"></a>线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。</p><h2 id="线程池在业务中的实践"><a class="header-anchor" href="#线程池在业务中的实践"></a>线程池在业务中的实践</h2><p><strong>场景1：快速响应用户请求</strong><br><strong>场景2：快速处理批量任务</strong></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a><br><a href="https://www.cnblogs.com/xiaoxi/p/7692250.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98/"/>
      <url>/2022/01/14/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="先更新数据库还是先更新缓存"><a class="header-anchor" href="#先更新数据库还是先更新缓存"></a>先更新数据库还是先更新缓存</h1><p>#缓存  #redis #数据库</p><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><p>在系统中引入缓存后，当向数据库中写入数据时，是先写数据库还是先写缓存呢？先写数据库和先写缓存有什么区别吗？</p><blockquote><p>从本质上讲，无论是先写数据库还是先写缓存，都是为了保证数据库和缓存的数据一致，也就是我们常说的数据一致性。<br>随着互联网的高速发展，当今时代已然从IT时代进入到DT时代。互联网系统架构也已经由最初的单体架构转变为分布式、微服务架构模式。从数据体量上来看，各系统存储的数据量越来越大，数据的查询性能越来越低。此时，就需要我们不断的进行优化，一种常用的优化手段就是引入缓存。而引入缓存后，我们在向数据库插入数据时，到底是先更新数据库还是先更新缓存呢？</p></blockquote><h2 id="缓存的一般使用"><a class="header-anchor" href="#缓存的一般使用"></a>缓存的一般使用</h2><p>缓存，从本质上讲，是为了更好的协调两个速度差异比较大的组件而引入的一种中间缓存层。例如，如果需要将数据读入CPU进行计算处理，由于CPU的运算速度是非常快的，而磁盘的IO处理相比于CPU来说，慢了很多数量级，每次从磁盘读取数据，势会造成CPU长时间并且频繁等待磁盘IO。此时，我们就可以通过内存来缓和CPU和磁盘之间的速度差异。</p><h2 id="缓存更新策略"><a class="header-anchor" href="#缓存更新策略"></a>缓存更新策略</h2><p>从理论上来说，给缓存设置过期时间，其实是一中最终一致性的表现。这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。这也是一般情况下，使用的最多的一种方式。</p><h2 id="应用"><a class="header-anchor" href="#应用"></a>应用</h2><p>火车票中转</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://juejin.cn/post/6985187835145879588?utm_source=gold_browser_extension" target="_blank" rel="noopener">先更新数据库还是先更新缓存</a><br><a href="https://www.jianshu.com/p/dc1e5091a0d8" target="_blank" rel="noopener">Redis缓存双删</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%90%8C%E6%AD%A5%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E6%A0%87%E6%B3%A8/"/>
      <url>/2022/01/14/%E5%90%8C%E6%AD%A5%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E6%A0%87%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="同步注解与并发性标注"><a class="header-anchor" href="#同步注解与并发性标注"></a>同步注解与并发性标注</h1><p>#spring #注解 #线程</p><h2 id="同步注解"><a class="header-anchor" href="#同步注解"></a>同步注解</h2><ul><li>@GuardedBy( “this” ) 受对象内部锁保护</li><li>@GuardedBy( “fieldName” ) 受 与fieldName引用相关联的锁保护</li><li>@GuardedBy( “ClassName.fieldName” ) 受一个类的静态field的锁保护。</li><li>@GuardedBy( “methodName()” ) 锁对象是 methodName() 方法的返值，受这个锁保护。</li><li>@GuardedBy( “ClassName.class” ) 受 ClassName类的直接锁对象保护。而不是这个类的某个实例的锁对象。</li></ul><h2 id="并发性标注"><a class="header-anchor" href="#并发性标注"></a>并发性标注</h2><p>@GuardedBy @NotThreadSafe @ThreadSafe<br>这三个类级别的标注可以描述类的线程安全保证性,属于类公开文档的一部分.它只是标注了该类是否是线程安全的,但实际上没法保证线程安全.</p><ul><li>@Immutable<br>表示类是不可变得既是final修饰的,它是线程安全的</li><li>@ThreadSafe<br>类是线程安全的</li><li>@NotThreadSafe<br>类不是线程安全的，如果类未加任何注解，则不能确定是否线程安全，认为是非线程安全的</li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/u010870167/article/details/88059219" target="_blank" rel="noopener">并发性标注</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%BD%AF%E4%BB%B6/"/>
      <url>/2022/01/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="科学上网"><a class="header-anchor" href="#科学上网"></a>科学上网</h1><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/367821925" target="_blank" rel="noopener">五分钟注册美区Apple ID</a><br><a href="https://v2xtls.org/just-my-socks-ios%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Just My Socks配置</a><br><a href="https://v2xtls.org/shadowsocks-ss-ios%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/" target="_blank" rel="noopener">Shadowsocks客户端</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/01/14/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="关闭线程池"><a class="header-anchor" href="#关闭线程池"></a>关闭线程池</h1><p>#线程池 #dubbo</p><h2 id="dubbo优雅关闭线程池"><a class="header-anchor" href="#dubbo优雅关闭线程池"></a>dubbo优雅关闭线程池</h2><ul><li>shutDown：通知线程池启动有序关闭，执行线程池之前已经提交的任务，但是不再接受新的任务。调用shutDown后再提交任务将会抛出RejectedExecutionException异常。</li><li>shutDownNow：尝试立即停止所有已经提交的任务，并会返回正在等待执行（未执行）的任务列表。shutDownNow通过向线程池中的线程发送一个中断请求而中止线程，如果线程池中运行了会抛出InterruptedException的程序，将会抛出一个InterruptedException。如过这个线程不能响应中断那么可能永远无法被终止。</li><li>isTerminated：所有的任务都被关闭返回true，否则返回false。只有调用了shutDown或者shutDownNow，isTerminated才可能为true。</li><li>awaitTermination(long timeout,TimeUnit unit)throws InterruptedException：阻塞当前线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor shutdownExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>),</span><br><span class="line">            <span class="keyword">new</span> NamedThreadFactory(<span class="string">"Close-ExecutorService-Timer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ExecutorService) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((ExecutorService) executor).isTerminated()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use the shutdown pattern from:</span></span><br><span class="line"><span class="comment">     *  https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the Executor to shutdown</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the timeout in milliseconds before termination</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Disable new tasks from being submitted</span></span><br><span class="line">            es.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Wait a while for existing tasks to terminate</span></span><br><span class="line">            <span class="keyword">if</span> (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                es.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            es.shutdownNow();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            newThreadToCloseExecutor(es);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownNow</span><span class="params">(Executor executor, <span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            es.shutdownNow();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            es.awaitTermination(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            newThreadToCloseExecutor(es);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newThreadToCloseExecutor</span><span class="params">(<span class="keyword">final</span> ExecutorService es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            shutdownExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                            es.shutdownNow();</span><br><span class="line">                            <span class="keyword">if</span> (es.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://developer.aliyun.com/article/756816" target="_blank" rel="noopener">学习dubbo如何优雅关闭线程池</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E8%BF%94%E5%9B%9E%E7%A9%BAList%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/01/14/%E8%BF%94%E5%9B%9E%E7%A9%BAList%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="空list"><a class="header-anchor" href="#空list"></a>空list</h1><p>#list #jdk8 #stream</p><h2 id="返回空List的方式"><a class="header-anchor" href="#返回空List的方式"></a>返回空List的方式</h2><ol><li><code>new ArrayList()</code></li><li><code>new ArrayList(0)</code></li><li><code>Collections.emptyList()</code></li><li><code>Lists.newArrayList()</code></li></ol><p><a href="https://blog.csdn.net/yangguosb/article/details/84573635" target="_blank" rel="noopener">返回空List的方式</a></p><p>因为返回空集合的替代方法通常是返回null;<br>然后呼叫者必须添加针对NullPointerException的警卫。如果返回空集合，则会减轻错误类别。在Java 8+中，还有一个Optional类型，它可以在没有Collection的情况下实现相同的目的。</p><h2 id="返回null-还是-空集合？-推荐空集合"><a class="header-anchor" href="#返回null-还是-空集合？-推荐空集合"></a>返回null 还是 空集合？ 推荐空集合</h2><p>null ?? []<br><strong>返回null 还是 空对象？</strong><br>如果您打算指示没有可用数据，则返回null通常是最好的主意。<br><strong>空对象表示已返回数据，而返回null则表示未返回任何内容。</strong></p><p>此外，如果尝试访问<strong>对象中的成员</strong>，则返回null将会导致<strong>null异常</strong>，这对于突出显示错误代码很有用-尝试不访问任何成员是没有意义的。访问空对象的成员不会失败，这意味着错误可能会被发现。<br>map类似 Stream 的 map方法。处理完之后，返回的还是一个 Optional 对象，所以可以做链式调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">String name = Optional.of(user).map(User::getName).orElse(<span class="string">"佚名"</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure><p>如上，取出user对象的name值，若name为空，返回一个默认值“佚名”（神奇的名字）。<br>这里，直接调用map方法，就不需要对user对象进行预先判空了。因为在map方法里边，会调用isPresent方法帮我们处理user为null的情况。<br>到这里，脑袋转圈快的小伙伴，是不是对开头的坑已经有启发了。<br>没错，我们可以通过 <strong>Optional 的链式调用</strong>，通过 map，orElse 等操作改写。如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getUserAddr1</span><span class="params">(Optional&lt;User&gt; user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先获取address对象</span></span><br><span class="line">    <span class="keyword">return</span> user.map((u)-&gt;u.getAddress())</span><br><span class="line">            <span class="comment">//再获取details值，</span></span><br><span class="line">            .map(e -&gt; e.getDetails())</span><br><span class="line">            <span class="comment">//若detail为null，则返回一个默认值</span></span><br><span class="line">            .orElse(<span class="string">"地址信息未填写"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<a href="https://segmentfault.com/a/1190000023912618" target="_blank" rel="noopener">JDK8新特性</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
      <url>/2022/01/14/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="测试端口连通性"><a class="header-anchor" href="#测试端口连通性"></a>测试端口连通性</h1><p>#centos #端口</p><h2 id="如何测试端口通不通"><a class="header-anchor" href="#如何测试端口通不通"></a>如何测试端口通不通</h2><ul><li><strong>使用telnet判断</strong></li></ul><p><code>telnet ip post</code></p><ul><li><strong>使用ssh判断</strong></li></ul><p><code>ssh -v -p port username@ip</code></p><blockquote><p>-v 调试模式(会打印日志).<br>-p 指定端口</p></blockquote><ul><li><p><strong>使用wget判断</strong><br><code>wget ip:port</code></p></li><li><p><strong>使用端口扫描工具</strong></p></li><li><p><strong>使用专用工具tcping进行访问：</strong></p></li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/swazer_z/article/details/64442730" target="_blank" rel="noopener">如何测试端口通不通</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/14/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue基础语法"><a class="header-anchor" href="#Vue基础语法"></a>Vue基础语法</h1><p>#vue #js</p><h2 id="v-if与v-show的区别以及使用场景"><a class="header-anchor" href="#v-if与v-show的区别以及使用场景"></a>v-if与v-show的区别以及使用场景</h2><p>如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><h2 id="v-model和-model的区别"><a class="header-anchor" href="#v-model和-model的区别"></a>v-model和:model的区别</h2><p><strong>v-model是vue.js中内置的双向数据绑定指令</strong>，用于表单控件以外的标签是不起作用的(即<strong>只对表单控件标签的数据双向绑定有效</strong>)。<br><strong>:model相当于v-bind:model的缩写</strong>，v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，这种只是<strong>将父组件的数据传递到了子组件</strong>，并没有实现子组件和父组件数据的双向绑定。<br>当然引用类型除外，子组件改变引用类型的数据的话，父组件也会改变的。<br><code>&lt;input v-model=&quot;message&quot;&gt; = &lt;input v-bind:value=&quot;message&quot; v-on:input=&quot;message = $event.target.value&quot; /&gt;</code><br>上面这个例子中，v-bind:value=“message” 只是将message变量的值赋给了input的value，并没有双向绑定，在此声明一下以防混淆</p><h2 id="nextTick"><a class="header-anchor" href="#nextTick"></a>nextTick</h2><p><code>Vue</code> 实现响应式并不是数据发生变化之后 <code>DOM</code> 立即变化，而是按一定的策略进行 <code>DOM</code> 的更新<br>简单来说，<code>Vue</code> 在修改数据后，视图不会立刻更新，而是等<strong>同一事件循环</strong>中的所有数据变化完成之后，再统一进行视图更新。<br><code>Vue</code> 中 <code>data</code> 的数据变化是<strong>同步</strong>的，更新完就能拿到；但是 <code>dom</code> 的更新是<strong>异步</strong>的，需要用<code>nextTick</code> 去即时获取<br><strong>说白了就是因为</strong> <code>**Vue**</code> <strong>是异步执行</strong> <code>**DOM**</code> <strong>更新的，想立即操作更新后的</strong> <code>**DOM**</code> <strong>就需要使用</strong> <code>**$nextTick**</code><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/1136954/1629425520217-dd07b909-c560-4281-82a5-354bc43d7003.webp" alt="nextTick"></p><blockquote><p>在 <code>created</code> 和 <code>mounted</code> 阶段，如果需要操作渲染后的视图，也要使用 <code>nextTick</code> 方法。<br>官方文档说明：注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue中数组赋值，push和“-”有什么区别？"><a class="header-anchor" href="#vue中数组赋值，push和“-”有什么区别？"></a>vue中数组赋值，push和“=”有什么区别？</h2><p>push是向数组中==追加数据==，不删除数组原有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">res.push(<span class="number">5</span>);</span><br><span class="line">res.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 输出[2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><p>&quot;=&quot;等于号是一个数组，==覆盖==原数组的数据进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> tmp = [<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">res = tmp;</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 输出[5,6]</span></span><br></pre></td></tr></table></figure><h2 id="日期计算"><a class="header-anchor" href="#日期计算"></a>日期计算</h2><h3 id="计算结束日期与当前时间相差天数"><a class="header-anchor" href="#计算结束日期与当前时间相差天数"></a>计算结束日期与当前时间相差天数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateDiffer(Date_end)&#123;</span><br><span class="line">   <span class="comment">//date1结束时间</span></span><br><span class="line">   <span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(Date_end);</span><br><span class="line">   <span class="comment">//date2当前时间</span></span><br><span class="line">   <span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(date1.getFullYear(), date1.getMonth(), date1.getDate());</span><br><span class="line">   date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(date2.getFullYear(), date2.getMonth(), date2.getDate());</span><br><span class="line">   <span class="keyword">const</span> diff = date1.getTime() - date2.getTime(); <span class="comment">//目标时间减去当前时间</span></span><br><span class="line">   <span class="keyword">const</span> diffDate = diff / (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);  <span class="comment">//计算当前时间与结束时间之间相差天数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算传入日期的最近三个月"><a class="header-anchor" href="#计算传入日期的最近三个月"></a>计算传入日期的最近三个月</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recently3Month(date) &#123;</span><br><span class="line">  <span class="keyword">let</span> reportDate = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">  <span class="keyword">let</span> cutoffDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  cutoffDate.setMonth(cutoffDate.getMonth() - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> reportDate.getTime() &gt; cutoffDate.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date与String相互转换"><a class="header-anchor" href="#Date与String相互转换"></a>Date与String相互转换</h3><blockquote><p>时间转换获取时间戳 : var res = moment(Date.now(), ‘YYYY-MM-DD HH:mm:ss’).valueOf();<br>时间转换获取格式时间: <strong>var</strong> res = moment(Date.now()).format(<strong>‘YYYY-MM-DD HH:mm:ss’</strong>);<br>String转换Date时间戳：var datelong = moment(this.habit.startTime,“YYYY-MM-DD”);</p></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/7af8554d8f08" target="_blank" rel="noopener">v-if与v-show的区别以及使用场景</a><br><a href="https://blog.csdn.net/u012155729/article/details/87857414" target="_blank" rel="noopener">v-model和:model的区别</a><br><a href="https://juejin.cn/post/6970877981778509838" target="_blank" rel="noopener">nextTick方法</a><br><a href="https://blog.csdn.net/qq_31759203/article/details/109072551" target="_blank" rel="noopener">vue中数组赋值</a><br><a href="https://blog.csdn.net/jie520191/article/details/100011426" target="_blank" rel="noopener">vue moment时间戳Date</a><br><a href="https://blog.csdn.net/weixin_46074961/article/details/106421566" target="_blank" rel="noopener">this.$set的正确使用</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Stream%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/"/>
      <url>/2022/01/14/Stream%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="stream排序和分页"><a class="header-anchor" href="#stream排序和分页"></a>stream排序和分页</h1><p>#stream #排序 #分页</p><h2 id="Java-8-stream排序-分页"><a class="header-anchor" href="#Java-8-stream排序-分页"></a>Java 8 stream排序&amp;分页</h2><h3 id="排序"><a class="header-anchor" href="#排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student newList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v1.getId().compareTo(</span><br><span class="line">v2.getId()</span><br><span class="line">)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v2getId().compareTo(</span><br><span class="line">v1.getId()</span><br><span class="line">)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据子对象id，升序排序，Student对象中还有一个Boy的对象属性</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v1.getBoy().getbId().compareTo(</span><br><span class="line">v2.getBoy().getbId()</span><br><span class="line">)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="分页"><a class="header-anchor" href="#分页"></a>分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip((currentPage-<span class="number">1</span>)*pageSize).limit(pageSize).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="在项目中的运用："><a class="header-anchor" href="#在项目中的运用："></a>在项目中的运用：</h3><pre><code class="language-java">long totalPage = resultList.size() / request.getPageSize() + (resultList.size() % request.getPageSize() &gt; 0 ? 1 : 0);Pagination pagination = new Pagination(request.getCurrent().longValue(), request.getPageSize().longValue(),(long) resultList.size(), totalPage);//通过stream对返回结果进行分页List&lt;MarketingTaskEntity&gt; paginationResults = resultList.stream().skip((request.getCurrent() - 1) * request.getPageSize()).limit(request.getPageSize()).collect(Collectors.toList());</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/SQL%20Where%E5%A6%99%E7%94%A8/"/>
      <url>/2022/01/14/SQL%20Where%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-Where妙用"><a class="header-anchor" href="#SQL-Where妙用"></a>SQL Where妙用</h1><p>#sql</p><h2 id="深入理解SQL中where-1-1的用处"><a class="header-anchor" href="#深入理解SQL中where-1-1的用处"></a>深入理解SQL中where 1=1的用处</h2><ol><li><p>where 的条件为永真<br>SQL注入时:<br><code>DELETE FROM table_a WHERE name= '张三'</code><br><code>DELETE FROM table_a WHERE name= '张三' or 1=1</code><br>本来是删除ａ值为张三的这一条数据，这就又变成了无约束的删除了。<br>1=1 永真， 1&lt;&gt;1 永假。</p></li><li><p>在后台写不定数量的查询条件下，便于规范语句，增加灵活性<code>String sql = &quot;select * from table a&quot;;</code></p></li></ol><p><strong>在不使用where 1=1的情况下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"name"</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.name='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"age"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"age"</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.age='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"class "</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"class "</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.class ='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当时用</strong>where 1=1** 的时候**<br><code>String sql = &quot;select * from table a where 1=1&quot;;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"name"</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.name='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"age"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"age"</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.age='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"class "</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"class "</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.class ='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis-where-1-1-和-where标签"><a class="header-anchor" href="#Mybatis-where-1-1-和-where标签"></a>Mybatis where 1=1 和 where标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selSampleListByIDX4"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"cn.com.git.cbs.datamodel.TBL_Sample"</span>&gt;</span></span><br><span class="line"> select </span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line"> from SAMPLE</span><br><span class="line"> where 1=1   </span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"samplenumber != null"</span> &gt;</span></span><br><span class="line">     AND SAMPLENUMBER = #&#123;samplenumber,jdbcType=DECIMAL&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mybatis  之前拼条件的时候 写法  where 1=1，也可以使where标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。</li><li>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：<br><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt;</code></li></ul><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><p><a href="https://blog.csdn.net/idomyway/article/details/78903822" target="_blank" rel="noopener">深入理解SQL中where 1=1的用处</a><br><a href="https://blog.csdn.net/qq_23994787/article/details/79045768" target="_blank" rel="noopener">where 1=1有什么用</a><br><a href="https://blog.csdn.net/xiaxiaorui2003/article/details/53301540" target="_blank" rel="noopener">where 1=1 和 where标签</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/SpringBoot%E9%9B%86%E6%88%90Kafka/"/>
      <url>/2022/01/14/SpringBoot%E9%9B%86%E6%88%90Kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot集成Kafka"><a class="header-anchor" href="#SpringBoot集成Kafka"></a>SpringBoot集成Kafka</h1><h2 id="Maven配置"><a class="header-anchor" href="#Maven配置"></a>Maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://jishuin.proginn.com/p/763bfbd4c199" target="_blank" rel="noopener">SpringBoot集成Kafka</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2022/01/14/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot参数校验"><a class="header-anchor" href="#SpringBoot参数校验"></a>SpringBoot参数校验</h1><p>#spring</p><h2 id="参数校验"><a class="header-anchor" href="#参数校验"></a>参数校验</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException.class)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">argValidException</span><span class="params">(HttpServletResponse response, MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"参数校验异常："</span>, ex);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ex.getBindingResult().hasErrors()) &#123;</span><br><span class="line">            ex.getBindingResult().getFieldErrors().forEach(err-&gt;&#123;</span><br><span class="line">                builder.append(err.getDefaultMessage()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BaseResponse.fail(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/apply/collection"</span>, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">applyCollectionPermission</span><span class="params">(@Valid @RequestBody ApplyCollectionPermissionRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = metabaseService.applyCollection(request);</span><br><span class="line">        <span class="keyword">return</span> success ? BaseResponse.success(<span class="string">"已提交申请，等待审批。"</span>) : BaseResponse.fail(<span class="string">"操作失败，请重试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyCollectionPermissionRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"申请理由不能为空"</span>)</span><br><span class="line">    String reason;</span><br><span class="line">    List&lt;MBCollection&gt; collections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html" target="_blank" rel="noopener">springboot使用hibernate validator</a><br><a href="https://juejin.cn/post/6844903974257049608" target="_blank" rel="noopener">@valid和@validated</a><br><a href="https://my.oschina.net/u/3706132/blog/1557940" target="_blank" rel="noopener">分组校验</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Redis%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
      <url>/2022/01/14/Redis%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis延迟队列"><a class="header-anchor" href="#Redis延迟队列"></a>Redis延迟队列</h1><p>#缓存 #redis #队列</p><h2 id="带有延迟功能的消息队列"><a class="header-anchor" href="#带有延迟功能的消息队列"></a>带有延迟功能的消息队列</h2><h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><h3 id="设计目标"><a class="header-anchor" href="#设计目标"></a>设计目标</h3><h3 id="设计方案"><a class="header-anchor" href="#设计方案"></a>设计方案</h3><h3 id="核心代码实现"><a class="header-anchor" href="#核心代码实现"></a>核心代码实现</h3><h3 id="源码"><a class="header-anchor" href="#源码"></a>源码</h3><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.yuque.com/jinguo.tech/ca7ygu/ps8gdy" target="_blank" rel="noopener">Redis延迟队列</a><br><a href="https://blog.csdn.net/qq_21033663/article/details/101222502" target="_blank" rel="noopener">延迟队列浅析</a><br><a href="https://www.jianshu.com/p/6bddbfa52cef" target="_blank" rel="noopener">延迟队列的几种实现方式</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Redis%E9%94%81/"/>
      <url>/2022/01/14/Redis%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis锁"><a class="header-anchor" href="#Redis锁"></a>Redis锁</h1><p>#redis  #分布式锁</p><h2 id="项目应用"><a class="header-anchor" href="#项目应用"></a>项目应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不存在(为空)就set值，并返回1；如果存在(不为空)不进行操作，并返回0</span></span><br><span class="line">Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, String.valueOf(System.currentTimeMillis()), seconds, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> success != <span class="keyword">null</span> &amp;&amp; success;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://xie.infoq.cn/article/556aaceb68789b9de4807f1c2" target="_blank" rel="noopener">Redis分布式锁原理</a><br><a href="https://juejin.cn/post/6901484610031452174" target="_blank" rel="noopener">Redis实现分布式锁</a><br><a href="https://blog.csdn.net/amosjob/article/details/99681707" target="_blank" rel="noopener">企业级分布式锁</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Presto%E5%BC%95%E6%93%8E/"/>
      <url>/2022/01/14/Presto%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Presto引擎"><a class="header-anchor" href="#Presto引擎"></a>Presto引擎</h1><p>#presto</p><h2 id="Presto数据模型"><a class="header-anchor" href="#Presto数据模型"></a>Presto数据模型</h2><p>Presto使用Catalog、Schema和Table这3层结构来管理数据。</p><blockquote><p>** Catalog**:就是数据源。Hive是数据源，Mysql也是数据源，Hive 和Mysql都是数据源类型，可以连接多个Hive和多个Mysql，每个连接都有一个名字。一个Catalog可以包含多个Schema，大家可以通过show catalogs 命令看到Presto连接的所有数据源。<br>** Schema**：相当于一个数据库实例，一个Schema包含多张数据表。show schemas from 'catalog_name’可列出catalog_name下的所有schema。<br><strong>Table</strong>：数据表，与一般意义上的数据库表相同。show tables from 'catalog_name.schema_name’可查看’catalog_name.schema_name’下的所有表。</p></blockquote><blockquote><p>在Presto中定位一张表，一般是catalog为根，例如：一张表的全称为 hive.test_data.test，标识 hive(catalog)下的 test_data(schema)中test表。可以简理解为：数据源的大类.数据库.数据表。</p></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="http://blog.chinaunix.net/uid-31012107-id-5819785.html" target="_blank" rel="noopener">Presto入门介绍</a><br><a href="https://www.alibabacloud.com/help/zh/doc-detail/166150.htm" target="_blank" rel="noopener">Presto数据源</a><br><a href="https://cloud.tencent.com/developer/article/1630733" target="_blank" rel="noopener">Presto查询引擎及原理分析</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/OKHttp%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/14/OKHttp%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="OKHttp原理"><a class="header-anchor" href="#OKHttp原理"></a>OKHttp原理</h1><p>#http</p><h2 id="原理概述"><a class="header-anchor" href="#原理概述"></a>原理概述</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1136954/1629450431169-f6cf4ce4-1a30-4f9f-98de-af6e4dcf12f0.webp" alt="okhttp原理"></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://juejin.cn/post/6968773787374321677?utm_source=gold_browser_extension" target="_blank" rel="noopener">探索 OkHttp 原理 - 掘金</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2022/01/14/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h1><p>#mysql #执行计划</p><h2 id="Explain-用途"><a class="header-anchor" href="#Explain-用途"></a><code>Explain</code> 用途</h2><ol><li>表的读取顺序如何</li><li>数据读取操作有哪些操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间是如何引用</li><li>每张表有多少行被优化器查询</li></ol><h2 id="Explain语法"><a class="header-anchor" href="#Explain语法"></a><code>Explain</code>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/Dreamhai/article/details/104558854" target="_blank" rel="noopener">MySQL查询优化之explain 执行计划</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/MySQL%20ZIP%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/14/MySQL%20ZIP%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-zip版安装教程"><a class="header-anchor" href="#MySQL-zip版安装教程"></a>MySQL zip版安装教程</h1><p>#mysql</p><h2 id="安装"><a class="header-anchor" href="#安装"></a>安装</h2><p><strong>问题：由于找不到MSVCR120.dll，无法继续执行代码</strong></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/zxs9999/article/details/68942233" target="_blank" rel="noopener">mysql压缩包版安装方法</a><br><a href="https://www.jianshu.com/p/a752eceb47a0?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">缺少MSVCR120的解决方案</a><br><a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=40784" target="_blank" rel="noopener">MSVCR120依赖下载</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Mybatis%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2022/01/14/Mybatis%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis转义字符"><a class="header-anchor" href="#Mybatis转义字符"></a>Mybatis转义字符</h1><p>#mybatis</p><h2 id="转义字符"><a class="header-anchor" href="#转义字符"></a>转义字符</h2><table><thead><tr><th>字符</th><th>转义</th><th>描述</th></tr></thead><tbody><tr><td>&lt;</td><td><code>&amp;lt;</code></td><td>小于</td></tr><tr><td>&lt;=</td><td><code>&amp;lt;=</code></td><td>小于等于</td></tr><tr><td>&gt;</td><td><code>&amp;gt;</code></td><td>大于</td></tr><tr><td>&gt;=</td><td><code>&amp;gt;=</code></td><td>大于等于</td></tr><tr><td>&lt;&gt;</td><td><code>&amp;lt;&amp;gt;</code></td><td>不等于</td></tr><tr><td>&amp;</td><td><code>&amp;amp;</code></td><td></td></tr><tr><td>’</td><td><code>&amp;apos</code></td><td></td></tr><tr><td>‘’</td><td><code>&amp;qots</code></td><td></td></tr></tbody></table><p>此外，也可以用CDATA标志<br><code>&lt;![CDATA[ 这里写你的sql ]]&gt;</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/MacOS%E6%89%A9%E5%B1%95%E7%A1%AC%E7%9B%98/"/>
      <url>/2022/01/14/MacOS%E6%89%A9%E5%B1%95%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS拓展磁盘"><a class="header-anchor" href="#MacOS拓展磁盘"></a>MacOS拓展磁盘</h1><h2 id="扩展硬盘"><a class="header-anchor" href="#扩展硬盘"></a>扩展硬盘</h2><p>实际上使用的命令：diskutil resizeVolume disk0s2 100GB<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1136954/1626193261241-ebfe689c-7da0-4fa2-8944-7b119186ba3f.png" alt="macos拓展磁盘"></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/21d33bd99965?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">vmware macos拓展磁盘</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/List%E6%8C%89%E7%85%A7%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D/"/>
      <url>/2022/01/14/List%E6%8C%89%E7%85%A7%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="List按照对象属性去重"><a class="header-anchor" href="#List按照对象属性去重"></a>List按照对象属性去重</h1><p>#list #jdk8 #stream</p><h2 id="通过stream去重"><a class="header-anchor" href="#通过stream去重"></a>通过stream去重</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">getFileDetailList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(fileDetailList)) &#123;</span><br><span class="line"><span class="keyword">return</span> fileDetailList.stream().filter(distinctByKey(SecurityResource::getName)).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">2</span> &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/JS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/14/JS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS基础语法"><a class="header-anchor" href="#JS基础语法"></a>JS基础语法</h1><p>#js</p><h2 id="Javascript中-的含义"><a class="header-anchor" href="#Javascript中-的含义"></a>Javascript中!!的含义</h2><p>Javascript中!!(两个感叹号，双感叹号)可以用来做什么，可以做出如下判断：</p><ul><li>数值：表示不是0，且有确定含义的值（包括无穷大）</li><li>字符串：表示长度大于0的字符串</li><li>数组，对象，函数：只能表示不是undefined或null,并不能判断是否有元素和内容。<br><code>if(!!arr &amp;&amp; arr.length&gt;0)</code></li></ul><h2 id="js判断为空Null与字符串为空简写方法"><a class="header-anchor" href="#js判断为空Null与字符串为空简写方法"></a>js判断为空Null与字符串为空简写方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (variable1 !== <span class="literal">null</span> || variable1 !== <span class="literal">undefined</span> || variable1 !== <span class="string">''</span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> variable2 = variable1; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的意思是说如果variable1不是一个空对象，或者未定义，或者不等于空字符串，那么声明一个variable2变量，将variable1赋给variable2。也就是说如果variable1存在那么就将variable1的值赋给variable2，若不存在则为空字符串。如下面的简写代码。<br><code>var variable2 = variable1 || '';</code><br>判断字符串是否为空：<br><code>str.length==0</code><br>如果用户输入的是空格，制表符，换页符呢?这样的话，是不为空的<br>可以用正则表达式来判断<br><code>str.replace(/(^s*)|(s*$)/g, &quot;&quot;).length ==0</code><br>或者<br><code>str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)) != &quot;&quot;</code></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/daysme/p/6979231.html" target="_blank" rel="noopener">js判空</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/json%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/01/14/json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="json序列化"><a class="header-anchor" href="#json序列化"></a>json序列化</h1><p>#json</p><h2 id="属性序列化"><a class="header-anchor" href="#属性序列化"></a>属性序列化</h2><h3 id="一、jackson的-JsonProperty使用"><a class="header-anchor" href="#一、jackson的-JsonProperty使用"></a>一、jackson的@JsonProperty使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>@JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(value=<span class="string">"name"</span>)。</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@JsonProperty</span>(<span class="string">"screen_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String screen;</span><br></pre></td></tr></table></figure><h3 id="二、fastjson的-JSONField使用"><a class="header-anchor" href="#二、fastjson的-JSONField使用"></a>二、fastjson的@JSONField使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(name=<span class="string">"screen_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String screen;</span><br></pre></td></tr></table></figure><h2 id="忽略属性"><a class="header-anchor" href="#忽略属性"></a>忽略属性</h2><h3 id="一、jackson的JsonIgnore"><a class="header-anchor" href="#一、jackson的JsonIgnore"></a>一、jackson的JsonIgnore</h3><ol><li>作用：在json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。</li><li>使用方法：一般标记在属性或者方法上，返回的json数据即不包含该属性。</li></ol><h3 id="二、fastjson的-JSONField-serialize-false"><a class="header-anchor" href="#二、fastjson的-JSONField-serialize-false"></a>二、fastjson的@JSONField(serialize = false)</h3><h2 id="日期格式化"><a class="header-anchor" href="#日期格式化"></a>日期格式化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)  </span><br><span class="line"><span class="meta">@JsonFormat</span>(shape = JsonFormat.Shape.STRING, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="keyword">private</span> LocalDateTime startTime;</span><br></pre></td></tr></table></figure><p>@DatetimeFormat<br>org.springframework.format.annotation.DateTimeFormat<br>是将String转换成LocalDateTime，一般前台给后台传值时用</p><p>@JsonFormat：com.fasterxml.jackson.annotation.JsonFormat<br>将LocalDateTime转换成String  一般后台传值给前台时用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/14/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础知识-面试"><a class="header-anchor" href="#Java基础知识-面试"></a>Java基础知识 &amp; 面试</h1><h2 id="基础概念与常识"><a class="header-anchor" href="#基础概念与常识"></a>基础概念与常识</h2><ul><li>Java 语言有哪些特点?</li><li><pre><code>- 1. 简单易学；- 2. 面向对象（封装，继承，多态）；- 3. 平台无关性（ Java 虚拟机实现平台无关性）；- 4. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；- 5. 可靠性；- 6. 安全性；- 7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；- 8. 编译与解释并存；</code></pre><ul><li><blockquote><p><strong>🐛 修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544" target="_blank" rel="noopener">issue#544</a>）</strong> ：C<ins>11 开始（2011 年的时候）,C</ins>就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread" target="_blank" rel="noopener">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p></blockquote></li></ul></li><li>JVM vs JDK vs JRE<ul><li>JVM<ul><li><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote></li><li><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote></li></ul></li><li>JDK 和 JRE</li></ul></li><li>为什么说 Java 语言“编译与解释并存”？</li><li>Oracle JDK 和 OpenJDK 的对比<ul><li><blockquote><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p></blockquote></li></ul></li><li><pre><code>- 1. Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：[https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence](https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence) 。- 2. OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；- 3. Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；- 4. 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；- 5. Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；- 6. Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</code></pre></li><li><pre><code>- BCL 协议（Oracle Binary Code License Agreement）： 可以使用JDK（支持商用），但是不能进行修改。- OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的JDK用的都是这个协议，可以自己私下用，但是商用需要付费。</code></pre></li><li>Java 和 C++的区别?<ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>…</li></ul></li><li>import java 和 javax 有什么区别？</li></ul><h2 id="基本语法-ec21adf2-bd48-bea7"><a class="header-anchor" href="#基本语法-ec21adf2-bd48-bea7"></a>基本语法 ^ec21adf2-bd48-bea7</h2><ul><li><p>字符型常量和字符串常量的区别?</p></li><li><pre><code>- 1. **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符- 2. **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)- 3. **占内存大小** ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (**注意： char 在 Java 中占两个字节**),   - 字符封装类 `Character` 有一个成员常量 `Character.SIZE` 值为 16,单位是`bits`,该值除以 8(`1byte=8bits`)后就可以得到 2 个字节</code></pre><ul><li><blockquote><p>java 编程思想第四版：2.2.2 节<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt></p></blockquote></li></ul></li><li><p>注释</p></li><li><pre><code>- 1. 单行注释- 2. 多行注释- 3. 文档注释。</code></pre><ul><li><blockquote><p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p></blockquote></li></ul></li><li><p>标识符和关键字的区别是什么？</p></li><li><p>Java 中有哪些常见的关键字？</p></li><li><pre><code>- 分类- 关键字</code></pre></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li><pre><code>   - 访问控制   - private   - protected   - public</code></pre></li><li></li><li></li><li></li><li></li><li><pre><code>   - 类，方法和变量修饰符   - abstract   - class   - extends   - final   - implements   - interface   - native</code></pre></li><li></li><li><pre><code>   - new   - static   - strictfp   - synchronized   - transient   - volatile</code></pre></li><li></li><li><pre><code>   - 程序控制   - break   - continue   - return   - do   - while   - if   - else</code></pre></li><li></li><li><pre><code>   - for   - instanceof   - switch   - case   - default</code></pre></li><li></li><li></li><li><pre><code>   - 错误处理   - try   - catch   - throw   - throws   - finally</code></pre></li><li></li><li></li><li><pre><code>   - 包相关   - import   - package</code></pre></li><li></li><li></li><li></li><li></li><li></li><li><pre><code>   - 基本类型   - boolean   - byte   - char   - double   - float   - int   - long</code></pre></li><li></li><li><pre><code>   - short   - null   - true   - false</code></pre></li><li></li><li></li><li></li><li><pre><code>   - 变量引用   - super   - this   - void</code></pre></li><li></li><li></li><li></li><li></li><li><pre><code>   - 保留字   - goto   - const</code></pre></li><li></li><li></li><li></li><li></li><li></li><li><p>自增自减运算符</p></li><li><p>continue、break、和 return 的区别是什么？</p></li><li><pre><code>- 1. continue ：指跳出当前的这一次循环，继续下一次循环。- 2. break ：指跳出整个循环体，继续执行循环下面的语句。</code></pre></li><li><pre><code>- 1. `return;` ：直接使用 return 结束方法执行，用于没有返回值函数的方法- 2. `return value;` ：return 一个特定值，用于有返回值函数的方法</code></pre></li><li><p>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">"kl"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure></li></ul></li><li><pre><code>- ？ 表示不确定的 java 类型- T (type) 表示具体的一个 java 类型- K V (key value) 分别代表 java 键值中的 Key Value- E (element) 代表 Element</code></pre></li><li><p>==和 equals 的区别</p><ul><li><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><pre><code>- **类没有覆盖 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。- **类覆盖了 `equals()`方法** ：一般我们都覆盖 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</code></pre><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line"><span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line"><span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><pre><code>- `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。- 当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。</code></pre><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String anotherString = (String)anObject;</span><br><span class="line"><span class="keyword">int</span> n = value.length;</span><br><span class="line"><span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"><span class="keyword">char</span> v1[] = value;</span><br><span class="line"><span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>hashCode()与 equals()</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><blockquote><p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote></li></ul></li></ul><h2 id="基本数据类型-477f481b-b54f-f4a5"><a class="header-anchor" href="#基本数据类型-477f481b-b54f-f4a5"></a>基本数据类型 ^477f481b-b54f-f4a5</h2><ul><li><p>Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</p></li><li><pre><code>- 1. 6 种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double`- 2. 1 种字符类型：`char`- 3. 1 种布尔型：`boolean`。</code></pre></li><li></li><li><pre><code>   - 基本类型   - 位数   - 字节   - 默认值</code></pre></li><li></li><li><pre><code>      - `int`      - 32      - 4      - 0</code></pre></li><li><pre><code>      - `short`      - 16      - 2      - 0</code></pre></li><li><pre><code>      - `long`      - 64      - 8      - 0L</code></pre></li><li><pre><code>      - `byte`      - 8      - 1      - 0</code></pre></li><li><pre><code>      - `char`      - 16      - 2      - 'u0000'</code></pre></li><li><pre><code>      - `float`      - 32      - 4      - 0f</code></pre></li><li><pre><code>      - `double`      - 64      - 8      - 0d</code></pre></li><li><pre><code>      - `boolean`      - 1</code></pre></li><li><pre><code>      - false</code></pre></li><li><pre><code>- 1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。- 2. `char a = 'h'`char :单引号，`String a = &quot;hello&quot;` :双引号。</code></pre><ul><li><blockquote><p>《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 <strong>（boolean、byte、char、short、int、float、long、double）</strong>、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p></blockquote></li></ul></li><li><p>自动装箱与拆箱</p></li><li><pre><code>- **装箱**：将基本类型用它们对应的引用类型包装起来；- **拆箱**：将包装类型转换为基本数据类型；</code></pre><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line">LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line">BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line">LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line">GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line">PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure></li></ul></li><li><pre><code>- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`- `int n = i` 等价于 `int n = i.intValue()`;</code></pre></li><li><p>8 种基本类型的包装类和常量池 ^79b7e54a-0c33-fb97</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line"></span><br><span class="line">cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">Float i11 = <span class="number">333f</span>;</span><br><span class="line"></span><br><span class="line">Float i22 = <span class="number">333f</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line"></span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="方法（函数）-d691fc9b-42f8-a9a5"><a class="header-anchor" href="#方法（函数）-d691fc9b-42f8-a9a5"></a>方法（函数） ^d691fc9b-42f8-a9a5</h2><ul><li><p>什么是方法的返回值?</p></li><li><p>方法有哪几种类型？</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"无参数无返回值的方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参数无返回值的方法</span></span><br><span class="line"><span class="comment">* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> a, String b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">System.out.println(a + <span class="string">"--&gt;"</span> + b + <span class="string">"--&gt;"</span> + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"有返回值无参数的方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值有参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return在无返回值方法的特殊使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在一个静态方法内调用一个非静态成员为什么是非法的?</p></li><li><p>静态方法和实例方法有何不同？</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staicMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 调用实例方法</span></span><br><span class="line">person.method();</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">Person.staicMethod()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为什么 Java 中只有值传递？</p><ul><li><blockquote><p><strong>example 1</strong></p></blockquote></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">swap(num1, num2);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">b</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">num1</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">num2</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p><strong>example 2</strong></p></blockquote></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">change(arr);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p><strong>example 3</strong></p></blockquote></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br><span class="line">System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">Student temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x:</span>小李</span><br><span class="line"><span class="symbol">y:</span>小张</span><br><span class="line"><span class="symbol">s1:</span>小张</span><br><span class="line"><span class="symbol">s2:</span>小李</span><br></pre></td></tr></table></figure></li><li><blockquote><p><strong>总结</strong></p></blockquote></li></ul></li><li><pre><code>- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。- 一个方法可以改变一个对象参数的状态。- 一个方法不能让对象参数引用一个新的对象。</code></pre></li><li><p>重载和重写的区别</p><ul><li><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p></blockquote></li><li>重载</li><li>重写</li></ul></li><li><pre><code>   - 1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。   - 2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。   - 3. 构造方法无法被重写</code></pre></li><li></li><li><pre><code>      - 区别点      - 重载方法      - 重写方法</code></pre></li><li></li><li><pre><code>         - 发生范围         - 同一个类         - 子类</code></pre></li><li><pre><code>         - 参数列表         - 必须修改         - 一定不能修改</code></pre></li><li><pre><code>         - 返回类型         - 可修改         - 子类方法返回值类型应比父类方法返回值类型更小或相等</code></pre></li><li><pre><code>         - 异常         - 可修改         - 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</code></pre></li><li><pre><code>         - 访问修饰符         - 可修改         - 一定不能做更严格的限制（可以降低限制）</code></pre></li><li><pre><code>         - 发生阶段         - 编译期         - 运行期</code></pre></li><li><pre><code>   - “两同”即方法名相同、形参列表相同；   - “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；   - “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。-  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"超级英雄"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"超人"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Hero <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Hero();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"超级超级英雄"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SuperMan <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SuperMan();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>深拷贝 vs 浅拷贝</p><ul><li><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li></ol></li><li><ol start="2"><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol></li></ul></li></ul><h2 id="Java-面向对象-be37b3bb-5c0e-763d"><a class="header-anchor" href="#Java-面向对象-be37b3bb-5c0e-763d"></a>Java 面向对象 ^be37b3bb-5c0e-763d</h2><ul><li><p>面向对象和面向过程的区别</p></li><li><pre><code>- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。</code></pre><ul><li><blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p></blockquote></li></ul></li><li><p>成员变量与局部变量的区别有哪些？</p><ul><li><ol><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li></ol></li><li><ol start="2"><li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li></ol></li><li><ol start="3"><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li></ol></li><li><ol start="4"><li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol></li></ul></li><li><p>创建一个对象用什么运算符?对象实体与对象引用有何不同?</p></li><li><p>对象的相等与指向他们的引用相等,两者有什么不同?</p></li><li><p>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</p></li><li><p>构造方法有哪些特点？是否可被 override?</p><ul><li><ol><li>名字与类名相同。</li></ol></li><li><ol start="2"><li>没有返回值，但不能用 void 声明构造函数。</li></ol></li><li><ol start="3"><li>生成类的对象时自动执行，无需调用。</li></ol></li></ul></li><li><p>面向对象三大特征</p><ul><li><p>封装</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取id的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置id的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取name的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置name的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>继承</p><ul><li><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li></ol></li><li><ol start="2"><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li></ol></li><li><ol start="3"><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol></li></ul></li><li><p>多态</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul></li></ul></li><li><p>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</p><ul><li><blockquote><p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p></blockquote></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The value is used for character storage.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The count is the number of characters used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><pre><code>- 1. 操作少量的数据: 适用 `String`- 2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`- 3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`</code></pre></li><li><p>Object 类的常见方法总结</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="反射-3d1bd917-20da-afe4"><a class="header-anchor" href="#反射-3d1bd917-20da-afe4"></a>反射 ^3d1bd917-20da-afe4</h2><ul><li><p>何为反射？</p></li><li><p>反射机制优缺点</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow" target="_blank" rel="noopener">Java Reflection: Why is it so slow?</a></li></ul></li><li><p>反射的应用场景</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代理类中的真实对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常-0db6aed3-954f-118d"><a class="header-anchor" href="#异常-0db6aed3-954f-118d"></a>异常 ^0db6aed3-954f-118d</h2><ul><li><p>Java 异常类层次结构图</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li><li><p>Throwable 类常用方法</p><ul><li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul></li><li><p>try-catch-finally</p></li><li><pre><code>- **`try`块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。- **`catch`块：** 用于处理 try 捕获到的异常。- **`finally` 块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。</code></pre></li><li><pre><code>- 1. 在 `try` 或 `finally`块中用了 `System.exit(int)`退出程序。但是，如果 `System.exit(int)` 在异常语句之后，`finally` 还是会被执行- 2. 程序所在的线程死亡。- 3. 关闭 CPU。</code></pre><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value * value;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></p></li><li><pre><code>- 1. **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象- 2. **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</code></pre><ul><li><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>));</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">System.out.println(scanner.nextLine());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>))) &#123;</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">System.out.println(scanner.nextLine());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>)));</span><br><span class="line">BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"out.txt"</span>)))) &#123;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">bout.write(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="I-O-流"><a class="header-anchor" href="#I-O-流"></a>I/O 流</h2><ul><li><p>什么是序列化?什么是反序列化?</p></li><li><pre><code>- **序列化**： 将数据结构或对象转换成二进制字节流的过程- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</code></pre><ul><li><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote></li></ul></li><li><p>Java 序列化中如果有些字段不想进行序列化，怎么办？</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul></li><li><p>获取用键盘输入常用的两种方法</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Java 中 IO 流分为几种?</p></li><li><pre><code>- 按照流的流向分，可以分为输入流和输出流；- 按照操作单元划分，可以划分为字节流和字符流；- 按照流的角色划分为节点流和处理流。</code></pre></li><li><pre><code>- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</code></pre></li><li><p>既然有了字节流,为什么还要有字符流?</p></li></ul><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre" target="_blank" rel="noopener">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li><li><a href="https://www.educba.com/oracle-vs-openjdk/" target="_blank" rel="noopener">https://www.educba.com/oracle-vs-openjdk/</a></li><li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk" target="_blank" rel="noopener">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk</a> 基础概念与常识</li></ul><h2 id="新节点"><a class="header-anchor" href="#新节点"></a>新节点</h2><h2 id="新节点-v2"><a class="header-anchor" href="#新节点-v2"></a>新节点</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Guava%E4%B9%8BJoiner/"/>
      <url>/2022/01/14/Guava%E4%B9%8BJoiner/</url>
      
        <content type="html"><![CDATA[<h1 id="Guava之Joiner"><a class="header-anchor" href="#Guava之Joiner"></a>Guava之Joiner</h1><p>#guava #字符串</p><h2 id="Joiner-简化用分隔符连接字符串序列"><a class="header-anchor" href="#Joiner-简化用分隔符连接字符串序列"></a><code>Joiner</code> 简化用分隔符连接字符串序列</h2><ul><li>如果序列中包含 <code>null</code> 值，那么可以使用 <code>Joiner</code> 跳过 <code>null</code> 值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过 null 值</span></span><br><span class="line">result = Joiner.on(<span class="string">"; "</span>).skipNulls().join(<span class="string">"Harry"</span>, <span class="keyword">null</span>, <span class="string">"Ron"</span>, <span class="string">"Hermione"</span>);</span><br><span class="line">Assert.assertEquals(result, <span class="string">"Harry; Ron; Hermione"</span>);</span><br></pre></td></tr></table></figure><ul><li>也可以通过 <code>useForNull(String)</code> 来将 <code>null</code> 值替换为指定的字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换 null 值</span></span><br><span class="line">result = Joiner.on(<span class="string">"; "</span>).useForNull(<span class="string">"null"</span>).join(<span class="string">"Harry"</span>, <span class="keyword">null</span>, <span class="string">"Ron"</span>, <span class="string">"Hermione"</span>);</span><br><span class="line">Assert.assertEquals(result, <span class="string">"Harry; null; Ron; Hermione"</span>);</span><br></pre></td></tr></table></figure><ul><li>同样可以在对象上使用 <code>Joiner</code>,最终会调用对象的 <code>toString()</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用在对象上，会调用对象的 toString() 函数</span></span><br><span class="line">result = Joiner.on(<span class="string">","</span>).join(Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line">Assert.assertEquals(result, <span class="string">"1,5,7"</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 <code>Map</code> ,可以使用这样的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapJoiner 的使用，将 map 转换为字符串</span></span><br><span class="line">Map map = ImmutableMap.of(<span class="string">"k1"</span>, <span class="string">"v1"</span>, <span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">result = Joiner.on(<span class="string">"; "</span>).withKeyValueSeparator(<span class="string">"="</span>).join(map);</span><br><span class="line">Assert.assertEquals(result, <span class="string">"k1=v1; k2=v2"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/Guava%20%E4%B8%AD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%20LoadingCache%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/14/Guava%20%E4%B8%AD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%20LoadingCache%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Guava中本地缓存LoadingCache使用"><a class="header-anchor" href="#Guava中本地缓存LoadingCache使用"></a>Guava中本地缓存LoadingCache使用</h1><p>#guava #缓存</p><h2 id="Guava-Cache"><a class="header-anchor" href="#Guava-Cache"></a>Guava Cache</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`Cache`</span> 在实际场景中有着非常广泛的使用，通常情况下如果遇到需要大量时间计算或者获取值的场景，</span><br><span class="line">就应当将值保存到缓存中。<span class="code">`Cache`</span> 和 <span class="code">`ConcurrentMap`</span> 类似，但又不尽相同。</span><br><span class="line">最大的不同是 <span class="code">`ConcurrentMap`</span> 会永久的存储所有的元素值直到他们被显示的移除，</span><br><span class="line">但是 <span class="code">`Cache`</span> 会为了保持内存使用合理，而配置自动将一些值移除。</span><br></pre></td></tr></table></figure><p>通常情况下，Guava Cache 适用于以下场景：</p><ul><li>花费一些内存来换取速度</li><li>一些 key 会被不止一次被调用</li><li>缓存内容有限，不会超过内存空间的值，Guava Cache 不会存储内容到文件或者到服务器外部，如果有此类需求考虑使用 Memcached, Redis 等类似工具<br>先来看一下 Guava 中 Cache 接口的定义：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#asMap</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#cleanUp</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#get</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#getAllPresent</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#getIfPresent</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#invalidate</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#invalidateAll</span>()</span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#invalidateAll</span>(<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Iterable</span>&lt;?&gt;)</span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#put</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#putAll</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#size</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.google</span><span class="selector-class">.common</span><span class="selector-class">.cache</span><span class="selector-class">.Cache</span><span class="selector-id">#stats</span></span><br></pre></td></tr></table></figure><p>Cache 接口定义的方法大都一目了然，值得一说的就是 <code>stats()</code> 方法，这个方法会返回一个 <code>CacheStats</code> 对象，这个对象包括了该 Cache 的一些统计信息，包括 <code>hitCount</code>， <code>missCount</code>，<code>loadSuccessCount</code>，<code>loadExceptionCount</code>，<code>totalLoadTime</code> 和 <code>evictionCount</code>。<br><code>Cache</code> 通过 <code>CacheBuilder</code> 类的 Builder 模式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()</span><br><span class="line">       .maximumSize(<span class="number">1000</span>)</span><br><span class="line">       .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">       .removalListener(MY_LISTENER)</span><br><span class="line">       .build(</span><br><span class="line">           <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> AnyException </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>如果使用的场景中对应着 key 的值有默认的值，那么可以选择使用 <code>CacheLoader</code>，如果没有默认值，那么仍然可以原子的 <code>get-if-absent-compute</code> 方法，在 <code>get</code> 方法中提供一个 <code>Callable</code>，或者元素也可以通过 <code>Cache.put</code> 来直接插入到缓存中。</p><h2 id="LoadingCache"><a class="header-anchor" href="#LoadingCache"></a>LoadingCache</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`LoadingCache`</span> 是一个附加着 <span class="code">`CacheLoader`</span> 的 Cache。</span><br><span class="line"><span class="code">`LoadingCache&lt;K,V&gt;`</span> 在 Guava 中是一个 interface，</span><br><span class="line">通常是用来本地 Cache 缓存 k-v 数据，value 会一直保存在内存中直到被移除或者失效。</span><br><span class="line">实现这个接口的类期望是线程安全的，能够安全的在多线程程序中被访问。</span><br></pre></td></tr></table></figure><h3 id="LoadingCache-不能-Cache-null"><a class="header-anchor" href="#LoadingCache-不能-Cache-null"></a>LoadingCache 不能 Cache null</h3><p>LoadingCache 是不支持缓存 null 值的，如果 load 回调方法返回 null，则在 get 的时候会抛出异常。<br>如果在 CacheLoader 中抛出异常，那么 Cache 会认为没有完成，所以新的值不会被 Cache。基于这一条规则，那么如何避免在 CacheLoader 中因为缓存 null 而抛出异常，那就是编程者自己处理 null 异常</p><h3 id="get-vs-getUnchecked"><a class="header-anchor" href="#get-vs-getUnchecked"></a>get() vs getUnchecked()</h3><p>最正统的查询 <code>LoadingCache</code> 的方法是调用 <code>get(k)</code> 方法，这个方法如果查询到已经缓存的值会立即返回，否则使用缓存的 <code>CacheLoader</code> 自动加载一个新值到缓存并返回。因为 <code>CacheLoader</code> 可能会抛出异常，那么如果有异常，则<code>LoadingCache.get(k)</code> 会抛出 <code>ExecutionException</code> 异常。而如果 CacheLoader 抛出 unchecked 未检查的异常，则 <code>get(k)</code> 方法会抛出 <code>UncheckedExecutionException</code> 异常。<br>此时可以选择使用 <code>getUnchecked(k)</code> 方法，这个方法会将所有的异常包装在 UncheckedExecutionException 异常中。需要注意的是，如果 CacheLoader 声明了检查异常，也就是 CacheLoader 显式的定义了异常，就不能调用 <code>getUnchecked(k)</code> 方法</p><h3 id="定时回收"><a class="header-anchor" href="#定时回收"></a>定时回收</h3><p>CacheBuilder 在构建 Cache 时提供了两种定时回收的方法</p><ul><li>expireAfterAccess(long, TimeUnit) : 缓存项在给定时间内没有被读或写访问，则回收</li><li>expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收</li></ul><h3 id="失效"><a class="header-anchor" href="#失效"></a>失效</h3><p>调用 LoadingCache 的 <code>invalidate</code> 方法可以使得 key 失效</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="noopener">guava wiki</a><br><a href="https://www.jianshu.com/p/2d3d30015915" target="_blank" rel="noopener">微服务缓存之Guava Cache</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/ElasticSearch/"/>
      <url>/2022/01/14/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch"><a class="header-anchor" href="#ElasticSearch"></a>ElasticSearch</h1><p>#es</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p>![[elasticsearch分享.pdf]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/14/disruptor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/01/14/disruptor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="高性能内存队列disruptor"><a class="header-anchor" href="#高性能内存队列disruptor"></a>高性能内存队列disruptor</h1><p>#线程 #并发 #队列</p><h2 id="Maven依赖"><a class="header-anchor" href="#Maven依赖"></a>Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.hangge.com/blog/cache/detail_2851.html" target="_blank" rel="noopener">SpringBoot - 并发框架Disruptor使用详解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS修改主机名</title>
      <link href="/2022/01/14/CentOS%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/"/>
      <url>/2022/01/14/CentOS%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS修改主机名"><a class="header-anchor" href="#CentOS修改主机名"></a>CentOS修改主机名</h1><p>#centos #hostname</p><h2 id="修改主机名"><a class="header-anchor" href="#修改主机名"></a>修改主机名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  sudo vim /etc/hosts</span><br><span class="line">2.  sudo vim /etc/sysconfig/network</span><br><span class="line">3.  hostnamectl set-hostname name</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1136954/1627996123050-be05bd32-cf02-4ee4-906d-53d634f64593.png" alt="hosts配置"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1136954/1627996147903-0f77b4b7-18fd-47d4-9fd1-503e2ae90ca7.png" alt="network配置"></p>]]></content>
      
      
      
        <tags>
            
            <tag> centos hostname </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴面试参考指南</title>
      <link href="/2022/01/14/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/"/>
      <url>/2022/01/14/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里巴巴面试参考指南"><a class="header-anchor" href="#阿里巴巴面试参考指南"></a>阿里巴巴面试参考指南</h1><p>#面试</p><h2 id="面试参考指南"><a class="header-anchor" href="#面试参考指南"></a>面试参考指南</h2><ol><li><strong>主从热备机制以及读写分离架构</strong></li></ol><p>Mybatis如何实现？使数据库读写分离对应用透明。</p><ol start="2"><li><strong>cdn刷新和预热资源</strong></li></ol><p>缓存刷新：提交缓存刷新请求后，CDN节点的缓存内容将会被强制过期。当用户向CDN节点请求资源时，CDN会直接回源站拉取对应的资源返回给用户，并将其缓存。</p><p>缓存预热：提交缓存预热请求后，源站将会主动将对应的资源缓存到CDN节点。当用户首次请求时，就能直接从CDN节点缓存中获取到最新的请求资源，无需再回源站拉取。</p><ol start="3"><li><p><strong>nginx针对前端静态资源的缓存处理</strong></p></li><li><p><strong>CPU负载压力</strong></p></li><li><p><strong>分布式文件系统 分布式数据库</strong><br>分库分表、MPP、分布式数据库</p></li><li><p><strong>NOSQL和搜索引擎</strong><br>为什么使用NOSQL数据库?</p></li></ol><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/youzhibing/p/7301463.html" target="_blank" rel="noopener">spring集成mybatis实现mysql读写分离-博客园</a><br><a href="https://shardingsphere.apache.org/blog/cn/material/database/" target="_blank" rel="noopener">我们是怎样打造一款分布式数据库的 · ShardingSphere - 博客</a><br><a href="https://www.cnblogs.com/shenzs-whj/p/10224671.html" target="_blank" rel="noopener">为什么要使用NoSQL数据库-博客园</a><br><a href="https://juejin.cn/post/6844903602935300104" target="_blank" rel="noopener">消息队列之 RocketMQ - 掘金</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java能力框架及学习路径</title>
      <link href="/2021/05/07/%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/05/07/%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Java能力框架及学习路径"><a class="header-anchor" href="#Java能力框架及学习路径"></a>Java能力框架及学习路径</h2><p>衡量每位工程师水平高低的标准，90%比拼的是技术能力，还有一小部分是软实力。建立完整的知识框架，会在职场中表现自己的优势，不再迷茫。在面试过程中可以把它分为基础知识、应用知识、综合能力三大模块的考核。</p><ul><li>基础模块包括：常见技术岗与面试流程、计算机基础JVM原理、多线程、设计模式、数据结构与算法等</li><li>应用模块包括：常用工具集、常用框架、缓存、队列、数据库等</li><li>综合模块包括：项目介绍、系统架构设计、微服务架构、容器化等</li></ul><table><thead><tr><th style="text-align:center">基础模块</th><th style="text-align:center">应用模块</th><th style="text-align:center">综合模块</th></tr></thead><tbody><tr><td style="text-align:center">技术岗位与面试流程</td><td style="text-align:center">常用工具集</td><td style="text-align:center">系统架构设计</td></tr><tr><td style="text-align:center">计算机基础</td><td style="text-align:center">常用框架</td><td style="text-align:center">微服务架构</td></tr><tr><td style="text-align:center">JVM原理</td><td style="text-align:center">缓存</td><td style="text-align:center">容器化</td></tr><tr><td style="text-align:center">多线程</td><td style="text-align:center">队列</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">设计模式</td><td style="text-align:center">数据库</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据结构与算法</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><blockquote><p>不论是应届生，初中级工程师，还是高级/资深工程师，经常会出现自身能力还不错，工作学习也很勤奋，却在找工作时铩羽而归的情况，换工作难的原因有三：</p><ul><li>不知道简历要写什么</li></ul><blockquote><p>​简历不好意味着没有面试机会。技术候选人大约有80%的简历通不过初筛，常见的原因有四种：</p><ol><li><p>工作/项目经验描述得不到位</p></li><li><p>不懂得如何包装自己的技术特长</p></li><li><p>学历不占优势，却放在了最显眼的位置</p></li><li><p>排版太乱，废话太多</p><p><strong>首先看看简历是不是有这些问题</strong>，另外，很多候选人在换工作的时候，按自己的喜好<strong>海投</strong>，从不看岗位的要求，也不会多准备几份简历，这种盲目的投递行为是导致失败的罪魁祸首。简历中的<strong>工作年限、对口经验、学历，甚至简历的美观度、逻辑是否清晰</strong>，都可能是道坎。</p></li></ol></blockquote></blockquote><blockquote><ul><li>不知道面试官要考什么</li></ul><blockquote><p>​很多人接到面试电话，第二天糊里糊涂就去，这种失败率极高。首先，不清楚侧重点、岗位要求。不同行业领域与工作年限对候选人的要求是不一样的，考察点也有所侧重。</p><p>​比如，从行业角度来看，社交门户类考查的是<strong>大规模高并发场景的应用与架构能力</strong>；O2O行业侧重于<strong>综合能力</strong>的考察；而互联网金融更喜欢逻辑缜密，对高可用安全领域有丰富经验的候选人。</p><p>​而针对不同的工作年限，校招面试更多的是对<strong>基础知识与逻辑思维</strong>方面的考察，以培养潜力的考察为主；初中级工程师则需要多关注<strong>知识的广度与基础知识的应用</strong>；而高级或者资深工程师需要深入理解基本原理，能对各种知识灵活运用，以综合的能力考查为主。</p><p>​其次，没有get到面试官的考查意图。举个简单的例子：面试官问使用过某某框架吗？很多人会回答说用过，然后就冷场了。其实，这个问题是想考察<strong>这个框架的使用场景、解决什么样的问题、有什么特点、有何同类型的其他框架</strong>等一系列的问题，如果仅仅回答“是”或者“否”的话，显然没有get到我的意图。同时，也能发现这些候选人在<strong>沟通表达</strong>上有待提高，恐怕会影响到将来的团队协作。</p><p>​    建议在面试前简单对公司<strong>业务岗位职责</strong>做一些功课，做一些有针对性的准备，才能事半功倍。</p></blockquote><ul><li>不知道如何提升晋级</li></ul><blockquote><p>​新技术的<strong>升级换代</strong>非常快，没跟上就可能被淘汰。<strong>不断学习</strong>是非常必要的。很多人都有一个不太好的习惯：东学一点西学一点。当时觉得很有用，可时间长了，发现我的技术并没有因此而提高。究其原因，要么是不成体系很快就遗忘，要么是和现实工作相差太远，无法灵活地运用，遇到了实际案例问题还是无从下手。</p><p>​学习首先要有一个框架，就像书的<strong>目录</strong>一样，<strong>先梗概后细节</strong>，先建立一套<strong>知识体系</strong>再一块一块地夯实。所以需要全面的梳理Java知识体系，建立<strong>思维框架</strong>。</p></blockquote></blockquote><p><img src="https://img.jinguo.tech/blog/image-20210506012953204.png?imageslim" alt="面试大纲"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32个Java常用面试点-概述</title>
      <link href="/2021/05/07/%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/05/07/%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2><p><strong>声明：</strong></p><p>本章节来自于我在拉钩教育上学习的VIP课程《32个Java面试必考点》，讲师是新浪微博资深技术专家-张磊。<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1#/detail/pc?id=1" target="_blank" rel="noopener">课程连接</a></p><p>本章节的知识内容均整理于此课程，仅用于学习记忆。若侵权，请通过本人站点进行联系，本人即刻对内容删除。<a href="https://jinguo.tech">联系站点</a></p><ul><li><p><a href="%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6.md">开篇：建立年薪50万的能力框架</a></p></li><li><p><a href="%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84.md">第一节：技术人职业发展路径</a></p></li><li><p><a href="%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">第二节：操作系统与计算机网络</a></p></li><li><p>第三节：深入浅出JVM</p></li><li><p>第四节：并发与多线程</p></li><li><p>第五节：数据结构与算法</p></li><li><p>第六节：常用工具集</p></li><li><p>第七节（上）：必会框架-Spring全家桶</p></li><li><p>第七节（下）：必会框架-RPC与ORM</p></li><li><p>第八节：高并发架构基石-缓存</p></li><li><p>第九节（上）：消息队列Kafka架构与原理</p></li><li><p>第九节（下）：MySQL调优与最佳实践</p></li><li><p>第十节：架构的演进之路与前沿技术</p></li><li><p>附录：技术人行走职场的建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术人职业发展路径</title>
      <link href="/2021/05/07/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/05/07/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="技术人职业发展路径"><a class="header-anchor" href="#技术人职业发展路径"></a>技术人职业发展路径</h2><p>在找工作之前应该对目标公司、岗位要求及面试流程有所了解，这样才可以有针对性的突破。</p><hr><h3 id="工程师发展路径"><a class="header-anchor" href="#工程师发展路径"></a>工程师发展路径</h3><p>先从工程师的职业上升空间开始讲解。“能谈谈你对未来的职业规划吗？”相信很多人面试都会被问过这个问题。技术岗和其他岗位一样，首先要对自己的职业有规划。</p><p>一般来说，技术人员对职业发展有两个发展方向，一个是技术方向，另外一个是管理方向，这两条路径侧重的能力点不同，需要根据自己的兴趣、能力优势有侧重的进行能力培养，成长路径如下图所示。</p><p><img src="https://img.jinguo.tech/blog/20210506220442.png?imageslim" alt="发展路径"></p><p>在刚入职的 1～3 年内，技术人员的发展路径比较单一，主要是从工程师往高级工程师发展，这个阶段主要目标是积累，夯实后续发展的基础，重点提高自己的工作基础能力，培养技术深度和广度，对不同方向的新技术保持强烈的好奇心和学习心。</p><p>在一路打怪升级为高级工程师之后，就会面临发展方向的选择：技术 or 管理。</p><ol><li>如果打算往技术方向深挖，上升通道有：资深工程师、技术专家、高级技术专家、研究员、科学家等。需要你重点培养技术攻坚能力，包括疑难问题的排查、大型项目的功能拆分、技术品牌的塑造等。具体的工作包括：原理、实现、注重架构能力的培养，更深一层还有：大规模、高并发场景，高可用、可扩展措施和方案、业务的抽象、架构能力、分布式服务设计原则的理解等。</li><li>另外一个方向就是管理。管理序列偏重于团队把控，需要让团队形成技术战斗力，利用一切资源推进项目，让团队完成作战目标。另外，做好团队内和跨团队的沟通、协作也是管理工作很重要的一环。</li></ol><p>在实际工作中，这两个序列没有特别明显的边界。例如做管理不表示远离架构设计；而技术专家也不是单兵作战，也需要带领团队。这两个方向区分点在于工作内容的侧重点不同：到底是更偏技术架构，还是更偏管理与项目推进。</p><p>回到最开始的面试问题，“你的职业规划是什么？”，答案并不是在面试前打个腹稿就完成任务了，而是在你进入职场，准备成为一位工程师时，心里就该有个谱的。</p><p>这里给有个面试小诀窍，也许这么回答能加分很多：“从过往的经验来看，我对项目的整体规划、管理推进比较感兴趣，在任务推进、协调沟通方面也有比较突出的表现，所以我的职业规划是成为一名优秀的技术经理，并以管理方向为发展目标。“这么接下去，面试官可能会对你的相关经历开始询问。</p><hr><h3 id="常见技术岗位划分"><a class="header-anchor" href="#常见技术岗位划分"></a>常见技术岗位划分</h3><p>除了有明确的职业规划外，想要往高处走还得了解职级划分与对应的软、硬技能要求。这样你在工作的时候可以有意识得补足欠缺，提高水平。</p><p>应聘不同公司、不同级别的岗位时，要重点提升哪方面的技能呢？答案非常简单。</p><p>对照下图，简单介绍 BAT 的技术序列的岗位划分、对应的工作年限及职级。</p><p><img src="https://img.jinguo.tech/blog/20210506220823.png?imageslim" alt="岗位划分"></p><ul><li>1～3 年的初级工程师，这个级别的岗位在阿里、百度、腾讯等大厂很少进行社招，一般是从校招生内部晋升。</li><li>高级工程师一般需要有 2～5 年的工作经验，这个岗位对应百度中的 T4、阿里的 P5，以及腾讯的 T2-2（对应腾讯最新职级体系 T7）。</li><li>资深工程师一般要求 3～6 年工作经验，这个岗位一般对应百度中的 T5、阿里的 P6，以及腾讯的 T2-3（对应腾讯最新职级体系 T8）。高级工程师和资深工程师是各个公司中的绝对技术主力，公司非常看重这部分人才的成长和培养。</li><li>技术专家、高级技术专家至少需要 5 年以上的互联网从业经验。</li></ul><hr><h3 id="面试岗位选择"><a class="header-anchor" href="#面试岗位选择"></a>面试岗位选择</h3><p>在明确发展方向和岗位级别之后，接下来该选公司和岗位了。换工作的时候你也许遇到过这种情况：一个公司有好几个技术岗位，要全都投一遍吗？手里有多个 Offer，应该怎么选，是挑钱多的，还是大平台、福利待遇好的？</p><p>建议：挑选岗位一般从公司规模、业务线或团队的重要程度以及个人条件的匹配度，这几方面来入手。</p><blockquote><p><strong>公司和团队</strong></p><p>先来看公司和团队。要有个概念：现在的每一份工作都是为下一份更好的工作<strong>蓄势</strong>。</p><p>大厂比较适合镀金提高身价，核心业务更适合长期稳定发展，进入核心团队在能力、经验上都能获得较大的成长。</p><p>如下图所示，第一象限是第一种情况，大公司的核心业务无疑是最好的选择，但也是竞争最激烈的，尽量找和自己能力<strong>匹配</strong>的，不要和众多高手竞争，耽误宝贵的求职时间和机会。第三象限，小公司的边缘业务，肯定是下下策，备选。</p><p><img src="https://img.jinguo.tech/blog/20210506221229.png?imageslim" alt="象限"></p><p>剩下的两种情况：一是大公司的边缘业务，另一个是小公司的核心业务。</p><p>这也是最让人头疼的选择，建议：对于工作 1～3 年的小伙伴，我更推荐优先选择<strong>核心业务</strong>。之前我有提到，职业生涯前期以积累知识、经验为主要任务，核心业务可以给你提供更多的<strong>历练场景</strong>，无论是<strong>应用经验</strong>还是<strong>架构经验</strong>都能获得很好的收获。</p></blockquote><blockquote><p><strong>个人匹配度</strong></p><p>另外一个因素：个人匹配度。不是每个人天生就能考上清华北大，考大学大家都要估分再报志愿，职场也是同一个道理，首先需要对自己的条件有客观的评估，再对号入座。评估范围包括岗位要求、业务方向，还有自身能力、兴趣、经验等的匹配程度。匹配程度越高，面试的成功率就会更高，也更有利于入职后个人的发展。</p><p>一句话总结就是：<strong>优先选择核心业务</strong>，以及与自己条件<strong>高度匹配</strong>的岗位。</p></blockquote><blockquote><p><strong>常见面试流程</strong></p><p>在搞清楚前面几点之后，面试流程也是找工作前必须了解的。我见过一些候选人对面试的要求都不了解，也没有进行对应轮次的面试准备就直接来了，这很可能会浪费一次机会。</p><p>对于技术岗，大部分公司的面试流程基本相同，如下图所示，分为 6 个环节。</p><p><img src="https://img.jinguo.tech/blog/20210506230829.png?imageslim" alt="常见面试流程"></p><ol><li><p>首先，可能会有一些前置的面试，假如应聘的是异地的职位，可能会先安排电话面试，大概了解候选人的情况和技术水平。还有一些公司会在正式面试前先进行笔试，或者上机编程。因此初次面试前一定要跟面试官沟通是否会先进行电话面试，是否有笔试或上机编程，是否需要自带电脑等细节。</p></li><li><p>正式面试是从技术一面开始的，可能会有 1~2 位面试官，他们很有可能就是你入职后的同组同事。一面以考察基础能力与实际应用能力为主，时长大概 1 小时左右，是纯技术面试。可能会要求手写一些小算法，例如排序、字符串处理之类的，这方面具体考点大家可以关注后面的算法面试课。</p></li><li><p>技术二面也是以技术面为主，偏重技术深度的考察，例如项目经历、架构能力、算法等，面试时长 1 小时左右，可能会要求画出项目的架构图，交互流程图等，并对项目存在的问题和改进方案等进行询问。一般技术二面的面试官就是你入职后的直属领导。</p></li><li><p>一些规模较小的公司，到二面就结束了，而大部分的公司会有技术三面。技术三面一般是半技术面试，会有一些项目经历、架构设计的题目，另外还会涉及职业规划、职业兴趣、技术视野等方面的问题，以架构能力、技术敏感度、发展潜力为主。三面的面试官一般是部门的 leader。还有少部分公司会存在技术四面，例如腾讯在较高级别岗位面试时，会有跨部门的交叉面试，面试内容与三面基本相同。</p></li><li><p>如果你很幸运通过了前面的几轮技术面试，那么就进入 HR 面试阶段，这个阶段之后基本不会再出现技术面试了，主要沟通个人的发展规划、上家公司的离职原因、价值观和薪资待遇等。如果你对这家公司特别期待，注意不要在这个环节因为纠结 1～2k 的工资而错失机会。工作前期以积累能力为主，3 年后我们再谈待遇。</p></li><li><p>HR 面试后是公司级高管面试，具体轮次看情况，一般一、二 面，非技术面为主，可能会简单询问工作经历、对公司的看法、对行业的看法、未来规划等，只要没有原则性错误，一般都能够通过。</p></li></ol><p><strong>整体总结如下：</strong></p><ul><li>面试前询问是否有电话面试、笔试、上机等前置面试；</li><li>技术一面、二面关注实际工作能力；</li><li>二面、三面偏重架构能力与发展潜力，二面与三面一般决定你的入职职级，一定要好好表现。</li></ul></blockquote><blockquote><p><strong>面试前准备工作</strong></p><p>假设你明天就有个面试，那么，前期的准备工作对面试成败起到决定性的作用。影响面试成功的三大基石是：能力、心态和沟通。</p><ol><li><p>能力。优秀的技术基本功是必要条件，毕竟公司是招你来解决问题的，没有技术能力其他的都无从谈起；</p></li><li><p>心态。注意平衡心态，过于紧张会导致平时会的内容没有回答上来；</p></li><li><p>沟通。与面试官交流顺畅，会给你的面试加分；反过来如果沟通不顺畅，就可能变成致命一刀，直接被 Pass。</p></li></ol><p>那么，如何在面试时<strong>稳定发挥</strong>？</p><ul><li><p>面试考察点是可以在短期内突击的，也是面试前需要重点准备的内容。</p><p>a 系统地复习基础知识。</p><p>b 对工作经历进行提炼，对原来负责的项目从架构方面重新审视、梳理、总结。</p><p>c 对一些典型框架的原理、使用场景及实现方式进行学习、对常考的考点进行专项突击。</p><p>d 阅读常考考点源码。</p><p>e 根据面试岗位业务有针对性的准备，比如：面试中间件方向的岗位时，可以突出自己有过存储中间件的开发经历、有过链路协议层设计经历等。</p></li><li><p>关于心态，面试前多方面搜集面试公司、岗位所属团队、平均福利等资料信息，知己知彼有助于增加自信。提示一下，有些公司喜欢压力面试，特别在面试官层级较高时发生。在不利场景下多给自己心理暗示，控制情绪，也许有意想不到的收获。例如，这个面试官以后可能再也不会遇到，就算失败了也没什么大不了。</p></li><li><p>沟通方面，几点建议</p><p>a 提前准备一个简短有特色的自我介绍，主要描述自己的技术特长和职业优势，一定不要聊兴趣爱好、家乡、星座等无关紧要的内容。</p><p>b 避免冷场，对于回答不上来的问题，可以主动坦白，并提出解题思路，或者询问面试官可不可以换个问题。</p><p>c 当没有听清，或是不理解问题时不要强行回答，可以跟面试官再次确认问题。</p><p>d 注意一些细节，例如：你的面试微表情，不要皱眉、控制坐姿和手势、说话语速不要过快或过慢、表达逻辑清晰，观点明确；不要随意打断面试官，谦虚有礼的态度等。</p><p>e 还有一个小技巧是需要注意观察面试官的反应。如果面试官突然在简历上奋笔疾书，说明你提供的信息是有用的，如果他停下来很长时间不写了，你要想想是不是跑题了；如果面试官的表情显示出不耐烦，或者深呼吸，有可能你没有领会面试官的考察意图，可以再次询问。</p></li></ul></blockquote><blockquote><p><strong>面试考察点</strong></p><p>面试的考察点非常综合，一般分为硬技能和软实力。</p><ol><li>硬技能包括：基础知识的掌握、以往的项目经验、对系统架构的设计能力，以及对不同框架、工具的综合应用能力。</li><li>软实力一般包括：逻辑思维是否灵活、沟通、表述、协作能力是否优秀、是否有较强的项目管理与推进能力、新技术的学习、总结与思考能力，以及培养潜力这几方面。</li></ol><p>前面 BAT 的职级图中提到，不同等级的岗位，能力要求肯定也不同，这里用雷达图来展示，如下图所示。</p><p><img src="https://img.jinguo.tech/blog/20210506222826.png?imageslim" alt></p><p>首先对于初、中级工程师来说，基本的要求是能完成分配的研发任务，所以面试官更看重<strong>基础知识的掌握</strong>、<strong>逻辑思维</strong>是否灵活，有没有<strong>培养潜力</strong>。其次是<strong>项目经验与学习思考能力</strong>，而架构能力、管理推进，以及沟通协作等能力，受限于工作年限，并不会对这些方面有较高的要求。</p><p>对于高级工程师，一般需要独立完成功能模块或者子项目的设计与开发，所以除了初级工程师应该具备的能力外，对项目经验、沟通协作、架构能力、学习思考、管理推进都有了更高的要求，特别是<strong>项目经验和学习思考能力</strong>。</p><p>而对于技术专家来说，要具备<strong>项目架构、项目经验、管理推进与沟通协作能力</strong>，能够独立负责一个项目，做好项目架构，完成功能模块的拆解与任务分配，推进团队内、外部的事务、协调资源，管理进度，带领技术团队完成任务目标。</p><p>温馨提示，<strong>软实力</strong>功夫做的好，对于技术工程师的职业生涯来说绝对是<strong>加分项</strong>。</p></blockquote><blockquote><p>针对硬技能考察点，提供一份系统化梳理，也是接下来重点的内容，如下图所示。</p><p><img src="https://img.jinguo.tech/blog/CgoB5l12QGeAX1jpAADXc8NHFMU588.jpg?imageslim" alt="硬技能系谱图"></p><ol><li>基础知识分为计算机基础与 Java 体系两大部分，包括了进程、线程管理；TCP、HTTP 网络协议；数据结构、经典算法；常用设计模式等。面试加分的内容，比如，新技术方面：Java 8~11 新特性，G1、ZGC 垃圾回收算法、最新网络协议 HTTP2、QUIC；知识深度方面：内存屏障、指令重排，JIT 编译器、逃逸分析等。</li><li>项目经验部分讲解如何展现自身项目经验，包括项目的描述、流程图、项目难点、项目问题分析与改进等。</li><li>应用知识部分兼顾知识的广度与重点框架的知识深度。包括常用工具、常用框架、缓存、队列及数据库等几个方面。其中工具集以知识广度与实用性为主， 例如 JVM 工具 JFR、tcpdump、Git、vmstat、iostat 等；应用框架以经典架构的常考点为主，包括 Spring、Netty 等主流框架的重点知识。缓存、队列、数据库将以应用场景为主。</li><li>架构能力以微服务架构介绍为主，讲解架构理念与应用场景，也包括一些重点机制的实现方式。例如 Docker、K8s 和 Spring Cloud 等。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与计算机网络</title>
      <link href="/2021/05/07/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2021/05/07/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统与计算机网络"><a class="header-anchor" href="#操作系统与计算机网络"></a>操作系统与计算机网络</h2><p>本节主要介绍面试中经常考察的计算机基础知识以及 Java 语言特性。其中，计算机的基础知识是工程师基本能力的体现，也是面试前必须要牢牢掌握的部分。</p><p>本节结构如下：</p><ol><li>面试中经常考察的知识点汇总，方便系统化复习；</li><li>对 TCP 协议、设计模式、Java 基础知识进行详细讲解；</li><li>从面试官角度，总结上述部分内容在面试时的考察点；</li><li>提供一些面试真题及重点题目解题思路。</li></ol><hr><h3 id="操作系统知识点"><a class="header-anchor" href="#操作系统知识点"></a>操作系统知识点</h3><p>先看操作系统相关知识的汇总，如下图所示。操作系统知识对于服务问题的排查定位十分重要，在面试时一般以了解和应用考察为主，面试题目占的比重一般不会太高。</p><p><img src="https://img.jinguo.tech/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F,.jpg?imageslim" alt="操作系统"></p><h3 id="进程与线程"><a class="header-anchor" href="#进程与线程"></a>进程与线程</h3><p>上图左上角的<strong>进程与线程</strong>部分是一个非常重要的考察点。</p><ol><li><p>首先需要掌握进程与线程的区别和联系：</p><ul><li>进程是系统<strong>资源分配</strong>的最小单位，线程是<strong>程序执行</strong>的最小单位；</li><li>进程使用<strong>独立</strong>的数据空间，而线程<strong>共享</strong>进程的数据空间。</li></ul></li><li><p>线程<strong>调度</strong>，简单了解线程的几种调度算法就可以了。比如时间片轮转调度、先来先服务调度、优先级调度、多级反馈队列调度以及高响应比优先调度。</p></li><li><p>线程切换的步骤，主要是了解线程的<strong>上下文切换</strong>，明白线程切换的代价。关于线程的知识在后面的多线程课程中还会有详细讲解，这里先略过。</p></li><li><p>在进程与线程部分还有一个比较常见的考察点，就是<strong>进程间通信</strong>，也就是 IPC。这部分在面试中间件研发的相关职位时经常会考察。如上面知识点汇总图中所示，需要了解这 6 种进程通信方式的原理与适用场景。例如，进程间数据共享的场景可以使用共享内存；进程间数据交换的场景可以使用 Unix Socket 或者消息队列。</p></li><li><p>最后<strong>协程</strong>部分，简单了解协程更轻量化，是在用户态进行调度，切换的代价比线程上下文切换要低很多就可以了，也可以了解 Java 的第三方协程框架，例如 <em>Kilim</em>、<em>Quasar</em> 等。</p></li></ol><hr><h3 id="Linux常用命令"><a class="header-anchor" href="#Linux常用命令"></a>Linux常用命令</h3><p>大部分互联网公司的服务都是在 Linux 系统上运行的，因此 Linux 命令也是面试时的常考点，这部分其实主要考察的是候选人是否有线上问题的<strong>排查</strong>经验，重点学习 <em>AWK</em>、<em>top</em>、<em>netstat</em>、<em>grep</em> 等高频使用的工具。</p><p>还有一些知识点不常考，做适当了解，例如内存分页管理与 Swap 机制、任务队列与 CPU Load 等，这些知识在分析线上问题中十分有用。</p><hr><h3 id="拓展知识"><a class="header-anchor" href="#拓展知识"></a>拓展知识</h3><p>最后是扩展知识点，例如内存屏障、指令乱序、分支预测、<em>NUMA</em> 与 <em>CPU</em> 亲和性等，如果在面试时有机会谈到的话，会在知识深度上给面试官留下比较好的印象。</p><hr><h3 id="计算机网络知识点"><a class="header-anchor" href="#计算机网络知识点"></a>计算机网络知识点</h3><p>计算机网络也是非常重要的基础知识，服务之间通过不同的网络协议进行交互，例如 <em><strong>HTTP</strong></em> 协议、<em><strong>RPC</strong></em> 协议等，在 Java 面试中网络知识被考到的几率非常大。网络知识点汇总如下图。</p><p><img src="https://img.jinguo.tech/blog/CgoB5l13hviANIAQAAJGI9kixgc615.jpg?imageslim" alt="计算机网络"></p><p>首先你应该深刻理解网络的 4/7 层模型，这是网络知识的基础。</p><ul><li>另外两个非常重要的网络协议就是 <em>HTTP</em>和 <em>TCP</em> 了，这两个协议也是服务交互中使用最多的协议。先来看 TCP 协议，TCP 协议中的<strong>三次握手建连与四次挥手断连</strong>是一个高频考点，后面会详细介绍。</li><li>TCP 的报文状态标志与链接状态，在排查网络问题时非常重要，必须要明白<strong>协议状态</strong>，才方便抓包分析。</li><li>另一个知识点是 <em><strong>Nagel</strong></em>算法和 <em><strong>ACK</strong></em> 延迟，需要了解产生的背景，是要解决小包问题，提高数据载荷比。知道对于延迟比较敏感且发送数据频率较低的场景可以关闭 Nagel 算法。</li><li>关于 TCP 的 Keepalive，是一种长时间没有数据发送的场景下，TCP 保持链接可用的机制，需要知道 TCP Keepalive 的开启和设置方式。</li><li>最后一点，需要明白 TCP 是如何通过滑动窗口机制来实现流量控制的。</li></ul><p>再来看 HTTP 协议部分。</p><ul><li><p>需要掌握 HTTP 协议的规范，知道协议中的 Method、Header、Cookies，需要了解常见状态码的含义，例如 404、503、302 等。</p></li><li><p>另外还有 HTTPS 的交互流程。</p></li><li><p>HTTP2 目前还比较新，对 HTTP2 协议的了解可以在一定程度上体现对新技术的关注程度。可以关注：HTTP2 多路复用、Stream 流式交互、流量控制、服务端推送、头部压缩等新特性</p></li></ul><p>除了 HTTP 和 TCP 外，UDP 也是一个比较常见的传输层协议，UDP 的特点是非链接、非可靠传输，但是效率非常高。</p><p>最后可以对 QUIC 协议进行一些了解，QUIC 已经被标准化为 HTTP3 协议。QUIC 是基于 UDP 协议，但 QUIC 提供了类似 TCP 的可靠性保证和流量控制。QUIC 可以有效避免 HTTP2 协议的前序包阻塞问题，能实现零 RTT 建连，提供 FEC 前向纠错能力。</p><hr><h3 id="详解-TCP-协议特点"><a class="header-anchor" href="#详解-TCP-协议特点"></a>详解 TCP 协议特点</h3><p>TCP 是传输层协议，对应 <em>OSI</em>网络模型的第四层传输层，特点如下。</p><ul><li><p>TCP 协议是基于链接的，也就是传输数据前需要先建立好链接，然后再进行传输。</p></li><li><p>TCP 链接一旦建立，就可以在链接上进行双向的通信。</p></li><li><p>TCP 的传输是基于字节流而不是报文，将数据按字节大小进行编号，接收端通过 ACK 来确认收到的数据编号，通过这种机制，TCP 协议能够保证接收数据的有序性和完整性，因此 TCP 能够提供可靠性传输。</p></li><li><p>TCP 还能提供流量控制能力，通过滑动窗口来控制数据的发送速率。滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力，在 TCP 的 Header 中动态调整窗口大小，通过 ACK 应答包通知给发送端，发送端根据窗口大小调整发送的的速度。</p></li><li><p>仅仅有了流量控制能力还不够，TCP 协议还考虑到了网络问题可能会导致大量重传，进而导致网络情况进一步恶化，因此 TCP 协议还提供拥塞控制。TCP 处理拥塞控制主要用到了慢启动、拥塞避免、拥塞发生、快速恢复四个算法，感兴趣的同学可以进一步了解。</p></li></ul><p>除了 TCP 协议的特点，还可以进一步了解 TCP 协议的报文状态、滑动窗口的工作流程、 Keepalive 的参数设置和 Nagel 算法的规则等一些细节。</p><p>另外还有典型的 TCP 协议问题，例如特定场景下 Nagel 和 ACK 延迟机制配合使用可能会出现 delay40ms 超时后才回复 ACK 包的问题。</p><hr><h3 id="详解三次握手建连"><a class="header-anchor" href="#详解三次握手建连"></a>详解三次握手建连</h3><p>接下来看 TCP 建连的三次握手。TCP 是基于链接的，所以在传输数据前需要先建立链接，TCP 在传输上是双工传输，不区分 Client 端与 Server 端，为了便于理解，我们把主动发起建连请求的一端称作 Client 端，把被动建立链接的一端称作 Server 端。</p><p>如下图，建连的时序是从上到下，左右两边的绿色字分别代表 Client 端与 Server 端当时的链接状态。</p><p><img src="https://img.jinguo.tech/blog/20210506225316.png?imageslim" alt="握手建连"></p><p>首先建立链接前需要 Server 端先监听端口，因此 Server 端建立链接前的初始状态就是 LISTEN 状态，这时 Client 端准备建立链接，先发送一个 SYN 同步包，发送完同步包后，Client 端的链接状态变成了 SYN_SENT 状态。Server 端收到 SYN 后，同意建立链接，会向 Client 端回复一个 ACK。</p><p>由于 TCP 是双工传输，Server 端也会同时向 Client 端发送一个 SYN，申请 Server 向 Client 方向建立链接。发送完 ACK 和 SYN 后，Server 端的链接状态就变成了 SYN_RCVD。</p><p>Client 收到 Server 的 ACK 后，Client 端的链接状态就变成了 ESTABLISHED 状态，同时，Client 向 Server 端发送 ACK，回复 Server 端的 SYN 请求。</p><p>Server 端收到 Client 端的 ACK 后，Server 端的链接状态也就变成了的 ESTABLISHED 状态，此时建连完成，双方随时可以进行数据传输。</p><p>在面试时需要明白三次握手是为了建立双向的链接，需要记住 Client 端和 Server 端的链接状态变化。另外回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。</p><hr><h3 id="详解四次挥手断连"><a class="header-anchor" href="#详解四次挥手断连"></a>详解四次挥手断连</h3><p>再来看看 TCP 的断连，如下图所示。</p><p><img src="https://img.jinguo.tech/blog/20210506225406.png?imageslim" alt="TCP"></p><p>TCP 链接的关闭，通信双方都可以先发起，我们暂且把先发起的一方看作 Client，从图中看出，通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态，然后 Client 先主动发起了关闭链接请求，Client 向 Server 发送了一个 FIN 包，表示 Client 端已经没有数据要发送了，然后 Client 进入了 FIN_WAIT_1 状态。</p><p>Server 端收到 FIN 后，返回 ACK，然后进入 CLOSE_WAIT 状态。此时 Server 属于半关闭状态，因为此时 Client 向 Server 方向已经不会发送数据了，可是 Server 向 Client 端可能还有数据要发送。</p><p>当 Server 端数据发送完毕后，Server 端会向 Client 端发送 FIN，表示 Server 端也没有数据要发送了，此时 Server 进入 LAST_ACK 状态，就等待 Client 的应答就可以关闭链接了。</p><p>Client 端收到 Server 端的 FIN 后，回复 ACK，然后进入 TIME_WAIT 状态。TIME_WAIT 状态下需要等待 2 倍的最大报文段生存时间，来保证链接的可靠关闭，之后才会进入 CLOSED 关闭状态。而 Server 端收到 ACK 后直接就进入 CLOSED 状态。</p><p>这里面试官可能会问为什么需要等待 2 倍最大报文段生存时间之后再关闭链接，原因有两个：</p><ol><li>保证 TCP 协议的全双工连接能够可靠关闭；</li><li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li></ol><p>从这个交互流程可以看出，无论是建连还是断链，都是需要在两个方向上进行，只不过建连时，Server 端的 SYN 和 ACK 合并为一次发送，而断链时，两个方向上数据发送停止的时间可能不同，所以不能合并发送 FIN 和 ACK。这就是建连三次握手而断链需要四次的原因。</p><p>另外回答断链的问题时，可以提到实际应用中有可能遇到大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态的问题。一般开启 <em>tcp_tw_reuse</em>和 <em>tcp_tw_recycle</em>能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/2021/04/27/%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/27/%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-dubbo在debug（调试）模式下，启动很慢的问题解决方法"><a class="header-anchor" href="#idea-dubbo在debug（调试）模式下，启动很慢的问题解决方法"></a>idea dubbo在debug（调试）模式下，启动很慢的问题解决方法</h1><p>idea 在debug模式下启动dubbo的时候，dubbo注册的时候会非常慢，但是在非调试模式下，就正常！后来在debug模式下，将所有断点都清除后，速度立马就上来了！所以在debug模式下启动，需要将断点都清除再启动！</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive实操</title>
      <link href="/2020/09/04/Hive%20%E5%AE%9E%E6%93%8D/"/>
      <url>/2020/09/04/Hive%20%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive-实操"><a class="header-anchor" href="#Hive-实操"></a>Hive 实操</h1><h2 id="一、Database"><a class="header-anchor" href="#一、Database"></a>一、Database</h2><h3 id="1-1-查看数据库列表"><a class="header-anchor" href="#1-1-查看数据库列表"></a>1.1 查看数据库列表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902204156290.png?imageslim" alt="image-20200902204156290"></p><h3 id="1-2-查看数据库列表"><a class="header-anchor" href="#1-2-查看数据库列表"></a>1.2 查看数据库列表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> database_name;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902204350677.png?imageslim" alt="image-20200902204350677"></p><h3 id="1-3-新建数据库"><a class="header-anchor" href="#1-3-新建数据库"></a>1.3 新建数据库</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>) [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name   <span class="comment">--DATABASE|SCHEMA 是等价的</span></span><br><span class="line">  [<span class="keyword">COMMENT</span> database_comment] <span class="comment">--数据库注释</span></span><br><span class="line">  [LOCATION hdfs_path] <span class="comment">--存储在 HDFS 上的位置</span></span><br><span class="line">  [<span class="keyword">WITH</span> DBPROPERTIES (property_name=property_value, ...)]; <span class="comment">--指定额外属性</span></span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> hive_test</span><br><span class="line">  <span class="keyword">COMMENT</span> <span class="string">'hive database for test'</span></span><br><span class="line">  <span class="keyword">WITH</span> DBPROPERTIES (<span class="string">'create'</span>=<span class="string">'jinguo'</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902203705654.png?imageslim" alt="image-20200902203705654"></p></li></ul><h3 id="1-4-查看数据库信息"><a class="header-anchor" href="#1-4-查看数据库信息"></a>1.4 查看数据库信息</h3><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC DATABASE [EXTENDED] db_name; <span class="comment">--EXTENDED 表示是否显示额外属性</span></span><br></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC DATABASE  EXTENDED hive_test;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903100904811.png?imageslim" alt="image-20200903100904811"></p><h3 id="1-5-删除数据库"><a class="header-anchor" href="#1-5-删除数据库"></a>1.5 删除数据库</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> (<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>) [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] database_name [RESTRICT|<span class="keyword">CASCADE</span>];</span><br></pre></td></tr></table></figure><p><em>默认行为是 <strong>RESTRICT</strong>，如果数据库中存在表则删除失败。要想删除库及其中的表，可以使用 <strong>CASCADE</strong> 级联删除。</em></p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hive_test;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903111952592.png?imageslim" alt="image-20200903111952592"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">while</span> processing statement: FAILED: Execution Error, <span class="keyword">return</span> code <span class="number">1</span> from org<span class="variable">.apache</span><span class="variable">.hadoop</span><span class="variable">.hive</span><span class="variable">.ql</span><span class="variable">.exec</span><span class="variable">.DDLTask</span>. InvalidOperationException(message:Database hive_test is <span class="keyword">not</span> empty. One <span class="keyword">or</span> more tables exist.)</span><br></pre></td></tr></table></figure><p><em>当数据库中存在表的时候，删除时需要用<strong>CASCADE</strong></em>关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hive_test <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903112539723.png?imageslim" alt="image-20200903112539723"></p><h2 id="二、创建表"><a class="header-anchor" href="#二、创建表"></a>二、创建表</h2><h3 id="2-1-建表语法"><a class="header-anchor" href="#2-1-建表语法"></a>2.1 建表语法</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">TEMPORARY</span>] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name     <span class="comment">--表名</span></span><br><span class="line">  [(col_name data_type [<span class="keyword">COMMENT</span> col_comment],</span><br><span class="line">    ... [constraint_specification])]  <span class="comment">--列名 列数据类型</span></span><br><span class="line">  [<span class="keyword">COMMENT</span> table_comment]   <span class="comment">--表描述</span></span><br><span class="line">  [PARTITIONED <span class="keyword">BY</span> (col_name data_type [<span class="keyword">COMMENT</span> col_comment], ...)]  <span class="comment">--分区表分区规则</span></span><br><span class="line">  [</span><br><span class="line">    CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...) </span><br><span class="line">   [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS</span><br><span class="line">  ]  <span class="comment">--分桶表分桶规则</span></span><br><span class="line">  [SKEWED <span class="keyword">BY</span> (col_name, col_name, ...) <span class="keyword">ON</span> ((col_value, col_value, ...), (col_value, col_value, ...), ...)  </span><br><span class="line">   [<span class="keyword">STORED</span> <span class="keyword">AS</span> DIRECTORIES] </span><br><span class="line">  ]  <span class="comment">--指定倾斜列和值</span></span><br><span class="line">  [</span><br><span class="line">   [<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> row_format]    </span><br><span class="line">   [<span class="keyword">STORED</span> <span class="keyword">AS</span> file_format]</span><br><span class="line">     | <span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'storage.handler.class.name'</span> [<span class="keyword">WITH</span> SERDEPROPERTIES (...)]  </span><br><span class="line">  ]  <span class="comment">-- 指定行分隔符、存储文件格式或采用自定义存储格式</span></span><br><span class="line">  [LOCATION hdfs_path]  <span class="comment">-- 指定表的存储位置</span></span><br><span class="line">  [TBLPROPERTIES (property_name=property_value, ...)]  <span class="comment">--指定表的属性</span></span><br><span class="line">  [<span class="keyword">AS</span> select_statement];   <span class="comment">--从查询结果创建表</span></span><br></pre></td></tr></table></figure><h3 id="2-2-创建内部表"><a class="header-anchor" href="#2-2-创建内部表"></a>2.2 创建内部表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903180953529.png?imageslim" alt="image-20200903180953529"></p><h3 id="2-3-创建外部表"><a class="header-anchor" href="#2-3-创建外部表"></a>2.3 创建外部表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_external(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_external'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903181743473.png?imageslim" alt="image-20200903181743473"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903184628794.png?imageslim" alt="image-20200903184628794"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903190348379.png?imageslim" alt="image-20200903190348379"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903185141700.png?imageslim" alt="image-20200903185141700"></p><h3 id="2-4-内部表和外部表区别"><a class="header-anchor" href="#2-4-内部表和外部表区别"></a>2.4 内部表和外部表区别</h3><p><strong>创建表时</strong></p><ul><li>创建内部表：会将数据移动到数据仓库指向的路径；</li><li>创建外部表：仅记录数据所在的路径， 不对数据的位置做任何改变。</li></ul><p><strong>删除表时</strong></p><ul><li>内部表的元数据和数据会被一起删除</li><li>外部表只删除元数据，不删除数据。外部表相对来说更加安全，数据组织更加灵活，方便共享源数据。</li></ul><p><strong>总结：</strong></p><ol><li><p>未被external修饰的是内部表【<em>managed table</em>】，被external修饰的为外部表【<em>external table</em>】。</p></li><li><p>内部表数据由Hive自身管理，外部表数据由HDFS管理。</p></li><li><p>内部表数据存储在<em>hive.metastore.warehouse.dir</em>【默认:<em>/user/hive/warehouse</em>】，外部表数据存储位置由用户自己决定。如 <em>location ‘/hive/emp_external’</em></p><p><img src="https://img.jinguo.tech/typora/image-20200904222601364.png?imageslim" alt="image-20200904222601364"></p><p><img src="https://img.jinguo.tech/typora/image-20200904222820733.png?imageslim" alt="image-20200904222820733"></p></li><li><p>删除内部表会直接删除元数据【<em>metadata</em>】及<strong>存储数据</strong>，删除外部表仅仅删除元数据，<em>HDFS</em>上的文件不会被删除。</p></li><li><p>对内部表的修改会直接同步到元数据，而对外部表的表结构和分区进行修改，则需要修改【<em>MSCK REPAIR TABLE table_name</em>】。</p></li></ol><h3 id="2-5-创建分区表"><a class="header-anchor" href="#2-5-创建分区表"></a>2.5 创建分区表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_partition(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">   )</span><br><span class="line">   PARTITIONED <span class="keyword">BY</span> (deptno <span class="built_in">INT</span>)  <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_partition'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903191518107.png?imageslim" alt="image-20200903191518107"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903193011185.png?imageslim" alt="image-20200903193011185"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192022966.png?imageslim" alt="image-20200903192022966"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903191648232.png?imageslim" alt="image-20200903191648232"></p><h3 id="2-6-分桶表"><a class="header-anchor" href="#2-6-分桶表"></a>2.6 分桶表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_bucket'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903192305213.png?imageslim" alt="image-20200903192305213"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192644607.png?imageslim" alt="image-20200903192644607"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em><img src="https://img.jinguo.tech/typora/image-20200903192505630.png?imageslim" alt="image-20200903192505630"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192829644.png?imageslim" alt="image-20200903192829644"></p><h3 id="2-7-倾斜表"><a class="header-anchor" href="#2-7-倾斜表"></a>2.7 倾斜表</h3><p><em>通过指定一个或者多个列经常出现的值（严重偏斜），<strong>Hive</strong>会自动将涉及到这些值的数据拆分为单独的文件。在查询时，如果涉及到倾斜值，它就直接从独立文件中获取数据，而不是扫描所有文件，这使得性能得到提升</em></p><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_skewed(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">   )</span><br><span class="line">   SKEWED <span class="keyword">BY</span> (empno) <span class="keyword">ON</span> (<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>)  <span class="comment">--指定 empno 的倾斜值 66,88,100</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_skewed'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903193642678.png?imageslim" alt="image-20200903193642678"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>storm心得-下</title>
      <link href="/2020/08/06/storm%E5%BF%83%E5%BE%97-%E4%B8%8B/"/>
      <url>/2020/08/06/storm%E5%BF%83%E5%BE%97-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="dubbo的引入"><a class="header-anchor" href="#dubbo的引入"></a>dubbo的引入</h2><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进<br><img src="https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim" alt="mark"></p><ul><li><p>单一应用架构<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。</p></li><li><p>垂直应用架构<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的  Web框架(MVC)  是关键。</p></li><li><p>分布式服务架构<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。</p></li><li><p>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率<br>此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。</p></li></ul><p>在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p><ol><li>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。<br>此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</li><li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。<br>这时，需要自动画出应用间的依赖关系图，以理清理关系。</li><li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？<br>为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。<br>其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</li></ol><h3 id="Dubbo的工作原理"><a class="header-anchor" href="#Dubbo的工作原理"></a>Dubbo的工作原理</h3><p><img src="https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim" alt="mark"></p><h3 id="节点角色说明："><a class="header-anchor" href="#节点角色说明："></a>节点角色说明：</h3><ul><li>Provider:  暴露服务的服务提供方。</li><li>Consumer:  调用远程服务的服务消费方。</li><li>Registry:  服务注册与发现的注册中心。</li><li>Monitor:  统计服务的调用次调和调用时间的监控中心。</li><li>Container:  服务运行容器。</li></ul><h3 id="调用关系说明："><a class="header-anchor" href="#调用关系说明："></a>调用关系说明：</h3><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="Dubbo-admin管理平台的安装"><a class="header-anchor" href="#Dubbo-admin管理平台的安装"></a>Dubbo-admin管理平台的安装</h2><h3 id="dubbo-admin-本地编译打包"><a class="header-anchor" href="#dubbo-admin-本地编译打包"></a>dubbo-admin 本地编译打包</h3><p><a href="https://github.com/alibaba/dubbo/releases" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/releases</a><br><a href="https://github.com/apache/incubator-dubbo/releases" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo/releases</a><br>解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址<br><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-ops</a></p><h3 id="克隆项目"><a class="header-anchor" href="#克隆项目"></a>克隆项目</h3><p>apache 下的dubbo-admin git仓库：<br><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-ops</a><br>先把这个项目用git克隆到本地中<br><img src="https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim" alt="mark"></p><h4 id="application-properties配置"><a class="header-anchor" href="#application-properties配置"></a>application.properties配置</h4><p><img src="https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim" alt="mark"></p><h4 id="application-test-properties配置"><a class="header-anchor" href="#application-test-properties配置"></a>application-test.properties配置</h4><p><img src="https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg" alt></p><h4 id="tomcat配置启动项"><a class="header-anchor" href="#tomcat配置启动项"></a>tomcat配置启动项</h4><p><img src="https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim" alt="mark"></p><h4 id="配置部署war包"><a class="header-anchor" href="#配置部署war包"></a>配置部署war包</h4><p><img src="https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim" alt="mark"><br><img src="https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim" alt="mark"></p><h4 id="说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。"><a class="header-anchor" href="#说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。"></a>说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。</h4><h4 id="Production-Setup"><a class="header-anchor" href="#Production-Setup"></a>Production Setup</h4><ol><li>Clone source code on develop branch git clone <a href="https://github.com/apache/incubator-dubbo-admin.git" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-admin.git</a></li><li>Specify registry address in dubbo-admin-server/src/main/resources/application.properties</li><li>Build<br>mvn clean package<br><img src="https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim" alt="mark"></li><li>Start<br>mvn --projects dubbo-admin-server spring-boot:run<br><strong>启动Zookeeper集群</strong><br><img src="https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim" alt="mark"><br><img src="https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim" alt="mark"></li><li>Visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim" alt="mark"></li></ol><h3 id="报错1"><a class="header-anchor" href="#报错1"></a>报错1</h3><p><img src="https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim" alt="mark"></p><h3 id="解决办法"><a class="header-anchor" href="#解决办法"></a>解决办法</h3><p>如果SpringBoot在子模块，直接main启动子模块会报错。<br>解决办法就是在IDEA MAVEN Projects-&gt;dubbo-admin-server-&gt;Plugins-&gt;spring-boot-&gt;spring-boot:run-&gt;run maven build<br><img src="https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim" alt="mark"></p><h3 id="报错2"><a class="header-anchor" href="#报错2"></a>报错2</h3><p><img src="https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim" alt="mark"></p><h3 id="解决办法-v2"><a class="header-anchor" href="#解决办法-v2"></a>解决办法</h3><p>taskkill /pid 8876 /f</p><p><img src="https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim" alt="mark"></p><h2 id="zookeeper与dubbo关系"><a class="header-anchor" href="#zookeeper与dubbo关系"></a>zookeeper与dubbo关系</h2><p>dubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；</p><h2 id="Netty在Dubbo中的应用"><a class="header-anchor" href="#Netty在Dubbo中的应用"></a>Netty在Dubbo中的应用</h2><p><strong>Dubbo 底层使用的是 Netty 作为网络通信</strong></p><ol><li>dubbo的Consumer消费者如何使用Netty</li></ol><h3 id="调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。"><a class="header-anchor" href="#调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。"></a>调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get remote service proxy</span></span><br><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br></pre></td></tr></table></figure><h3 id="调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存"><a class="header-anchor" href="#调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存"></a>调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">getSharedClient</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">String key=url.getAddress();</span><br><span class="line">ReferenceCountExchangeClient client=referenceClientMap.get(key);</span><br><span class="line"><span class="keyword">if</span>(client!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!=client.isClosed())&#123;</span><br><span class="line">client.incrementAndGetCount();</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">referenceClientMap.remove(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(key.intern())&#123;</span><br><span class="line"><span class="comment">//这个initClient()方法是创建Netty的client的</span></span><br><span class="line">ExchangeClient exchangeClient=initClient(url);</span><br><span class="line">client=<span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient,ghostClientMap);</span><br><span class="line">referenceClientMap.put(key,client);</span><br><span class="line">ghostClientMap.remove(key);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。"><a class="header-anchor" href="#最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。"></a>最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractClient</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    doOpen();</span><br><span class="line">    connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doOpent-方法用来创建-Netty-的-bootstrap-："><a class="header-anchor" href="#doOpent-方法用来创建-Netty-的-bootstrap-："></a>doOpent 方法用来创建 Netty 的 bootstrap ：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ClientBootstrap(channelFactory);</span><br><span class="line">    bootstrap.setOption(<span class="string">"keepAlive"</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">"connectTimeoutMillis"</span>, getTimeout());</span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="connect-方法用来连接提供者："><a class="header-anchor" href="#connect-方法用来连接提供者："></a>connect 方法用来连接提供者：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 </span></span><br><span class="line">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class="line">    <span class="keyword">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class="line">        Channel newChannel = future.getChannel();</span><br><span class="line">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。"><a class="header-anchor" href="#main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。"></a>main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line"><span class="comment">//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  </span></span><br><span class="line">    channel.send(req);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-的-Provider-提供者如何使用-Netty"><a class="header-anchor" href="#dubbo-的-Provider-提供者如何使用-Netty"></a>dubbo 的 Provider 提供者如何使用 Netty</h2><p>Provider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。</p><h3 id="NettyServer-对象的构造方法同样是-doOpen-方法。"><a class="header-anchor" href="#NettyServer-对象的构造方法同样是-doOpen-方法。"></a>NettyServer 对象的构造方法同样是 doOpen 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line"><span class="comment">//boss 线程，worker 线程，和 ServerBootstrap</span></span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"><span class="comment">//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。</span></span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Netty在Dubbo中的应用总结"><a class="header-anchor" href="#Netty在Dubbo中的应用总结"></a>Netty在Dubbo中的应用总结</h3><p>dubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。</p><h2 id="Apache-Storm分布式消息系统"><a class="header-anchor" href="#Apache-Storm分布式消息系统"></a>Apache Storm分布式消息系统</h2><p>Apache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。</p><h3 id="什么是分布式消息系统？"><a class="header-anchor" href="#什么是分布式消息系统？"></a>什么是分布式消息系统？</h3><p>分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。<br>大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。<br>一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。<br>需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。</p><p><img src="https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim" alt="mark"></p><p>下表描述了一些流行的高吞吐量消息传递系统 -<br><img src="https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim" alt="mark"><br>Thrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。<br>Apache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。<br>Storm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。</p><h2 id="Storm工作原理"><a class="header-anchor" href="#Storm工作原理"></a>Storm工作原理</h2><p><img src="https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim" alt="mark"></p><h3 id="Storm与传统关系型数据库"><a class="header-anchor" href="#Storm与传统关系型数据库"></a>Storm与传统关系型数据库</h3><p>传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存<br>传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据<br>关系型数据库重视事务，并发控制，相对来说Storm比较简陋<br>Storm与Hadoop，Spark等是流行的大数据方案<br>与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑</p><ol><li><p>topology<br>Storm集群中有两种组件节点，一种是<strong>控制节点</strong>(Nimbus节点)，另一种是<strong>工作节点</strong>(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。<br>和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去<br>数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。<br><img src="https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim" alt="mark"></p></li><li><p>zookeeper集群<br>storm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。<br>部署zookeeper有些需要注意的地方：<br>①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控<br>②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用</p></li><li><p>Component<br>Storm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口<br>全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。<br><img src="https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim" alt="mark"></p></li><li><p>Spout<br>Spout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①open()方法 – 初始化方法<br>close() – 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行<br>②ack(Object msgId) – 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放<br>③fail(Object msgId) – 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放<br>④nextTuple() – 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout</p></li><li><p>Bolt<br>Bolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成<br>prepare方法 – 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境<br>declareOutputFields方法 – 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似<br>cleanup方法 – 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。<br>execute方法 – 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。<br>Storm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException<br>通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple)</p></li><li><p>Topology运行方式<br>在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式</p></li></ol><h3 id="本地运行的提交方式"><a class="header-anchor" href="#本地运行的提交方式"></a>本地运行的提交方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster(); </span><br><span class="line">cluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); </span><br><span class="line">Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">cluster.shutdown();</span><br></pre></td></tr></table></figure><h3 id="分布式提交方式"><a class="header-anchor" href="#分布式提交方式"></a>分布式提交方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology());</span><br></pre></td></tr></table></figure><p>需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。</p><h3 id="运行的命令如下"><a class="header-anchor" href="#运行的命令如下"></a>运行的命令如下###</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar StormTopology.jar mainclass [args]</span><br></pre></td></tr></table></figure><h2 id="storm守护进程的命令"><a class="header-anchor" href="#storm守护进程的命令"></a>storm守护进程的命令</h2><p>Nimbus: storm nimbus 启动nimbus守护进程<br>Supervisor: storm supervisor 启动supervisor守护迚程<br>UI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。<br>DRPC: storm drpc 启动DRPC的守护进程</p><h2 id="storm管理命令"><a class="header-anchor" href="#storm管理命令"></a>storm管理命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAR：storm jar topology_jar topology_class [arguments...]</span><br></pre></td></tr></table></figure><p>jar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL：storm kill topology_name [-w wait_time]</span><br></pre></td></tr></table></figure><p>杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deactivate：storm deactivate topology_name</span><br></pre></td></tr></table></figure><p>停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activate：storm activate topology_name</span><br></pre></td></tr></table></figure><p>启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]...</span><br></pre></td></tr></table></figure><p>rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8</span><br></pre></td></tr></table></figure><p>还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等</p><h2 id="Storm与Hadoop的对比"><a class="header-anchor" href="#Storm与Hadoop的对比"></a>Storm与Hadoop的对比</h2><p><img src="https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim" alt="mark"></p><h2 id="DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下："><a class="header-anchor" href="#DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下："></a>DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：</h2><p>引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。</p><ol><li>接收到一个RPC调用请求；</li><li>发送请求到Storm上的<strong>拓扑</strong>；</li><li>从Storm上接收计算结果；</li><li>将计算结果返回给客户端。</li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="maven更新镜像源"><a class="header-anchor" href="#maven更新镜像源"></a>maven更新镜像源</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">         <span class="comment">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RPC和MQ对比及其适用-不适用场合"><a class="header-anchor" href="#RPC和MQ对比及其适用-不适用场合"></a>RPC和MQ对比及其适用/不适用场合</h2><h3 id="系统结构"><a class="header-anchor" href="#系统结构"></a>系统结构</h3><p><strong>RPC系统结构：</strong><br>Cosume &lt;=&gt; Provider<br>Consumer调用的Provider提供的服务</p><p><strong>Message Queue系统结构：</strong><br>Sender &lt;=&gt; Queue &lt;=&gt; Reciver<br>Sender发送消息给Queue；Receiver从Queue拿到消息来处理。</p><h3 id="功能的特点"><a class="header-anchor" href="#功能的特点"></a>功能的特点</h3><p>在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。</p><h3 id="消息的特点"><a class="header-anchor" href="#消息的特点"></a>消息的特点</h3><ul><li>Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。</li><li>Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响</li><li>Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。</li><li>所以对于有同步返回需求，用Message Queue则变得麻烦了。</li></ul><h3 id="PRC的特点"><a class="header-anchor" href="#PRC的特点"></a>PRC的特点</h3><ul><li>同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。</li><li>RPC也可以是异步调用。</li><li>由于等待结果，Consumer（Client）会有线程消耗。</li><li>如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。</li></ul><h3 id="适用场合说明"><a class="header-anchor" href="#适用场合说明"></a>适用场合说明</h3><ul><li>希望同步得到结果的场合，RPC合适。</li><li>希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。</li><li>不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。</li><li>随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。</li><li>这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。</li></ul><h3 id="不适用场合说明"><a class="header-anchor" href="#不适用场合说明"></a>不适用场合说明</h3><p>RPC同步调用使用Message Queue来传输调用信息。<br>发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>storm(心得)</title>
      <link href="/2020/01/16/storm%E5%BF%83%E5%BE%97-%E4%B8%8A/"/>
      <url>/2020/01/16/storm%E5%BF%83%E5%BE%97-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Storm入门"><a class="header-anchor" href="#Storm入门"></a>Storm入门</h1><p>Storm是一个<strong>分布式的</strong>，可靠的，容错的<strong>数据流处理系统</strong>。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。<br>Storm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等<br>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的<br>Storm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。<br>一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。<br>注：Storm中的核心术语<br><strong>spout</strong>龙卷，读取原始数据为bolt提供数据<br><strong>bolt</strong> 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果<br><strong>nimbus</strong> 雨云，主节点的守护进程，负责为工作节点分发任务<br><strong>topology</strong> 拓扑结构，Storm的一个任务单元<br><strong>define field(s)</strong> 定义域，由spout或bolt提供，被bolt接收</p><h2 id="Storm应用案例"><a class="header-anchor" href="#Storm应用案例"></a>Storm应用案例</h2><ul><li>数据处理流，Storm不需要中间队列</li><li>连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。</li><li><strong>分布式远程过程调用</strong></li><li>频繁的CPU密集型操作<strong>并行化</strong>。</li></ul><h2 id="Storm组件"><a class="header-anchor" href="#Storm组件"></a>Storm组件</h2><p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。<br>主节点运行着一个叫做<strong>Nimbus</strong>的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。<br><strong>Supervisor</strong>守护进程作为拓扑的一部分运行在工作节点上。<br>一个Storm<strong>拓扑结构</strong>在不同的机器上运行着众多的工作节点。<br>因为Storm在<strong>Zookeeper</strong>或本地磁盘上<strong>维持所有的集群状态</strong>，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康<br>在系统底层，Storm使用了<strong>zeromq</strong>，这是一种先进的，可嵌入的<strong>网络通讯库</strong>，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets</p><h3 id="注：zeromq的特性"><a class="header-anchor" href="#注：zeromq的特性"></a>注：zeromq的特性</h3><ul><li>一个并发架构的Socket库</li><li>对于集群产品和超级计算，比TCP要快</li><li>可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信</li><li>异步I / O的可扩展的多核消息传递应用程序</li><li>利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接<br>注：最新的Storm已不再必须依赖<strong>ZeroMQ</strong>，各种依赖的库和软件也已经有更新的版本。<br>最近版本的Storm支持使用<strong>netty</strong>做消息队列。<br>Netty提供<strong>异步的、事件驱动</strong>的网络应用程序框架和工具，用以快速开发<strong>高性能、高可靠性的</strong>网络服务器和客户端程序。正好是 storm所需要的。</li></ul><h2 id="Storm的特性"><a class="header-anchor" href="#Storm的特性"></a>Storm的特性</h2><ul><li>简化编程：使用Storm，实现实时处理的复杂性被大大降低了</li><li>开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发</li><li>容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。</li><li>可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。</li><li>可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。</li><li>快速：速度是驱动Storm设计的一个关键因素</li><li>事务性：可以为几乎任何计算得到恰好一次消息语义</li></ul><h2 id="安装Storm集群"><a class="header-anchor" href="#安装Storm集群"></a>安装Storm集群</h2><p>要手工安装Storm，需要先安装以下软件</p><ol><li>Zookeeper集群</li><li>Java</li><li>Python</li><li>Unzip命令</li></ol><h3 id="注："><a class="header-anchor" href="#注："></a>注：</h3><p>Nimbus和管理进程将要依赖Java、Python和unzip命令</p><h3 id="前期准备"><a class="header-anchor" href="#前期准备"></a>前期准备</h3><ol><li>准备搭建3节点集群,准备3个虚拟机node1,node2,node3</li><li>配置好hosts映射文件和互相的ssh免密登录</li><li>配置好JDK<br>注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好</li></ol><h3 id="安装storm"><a class="header-anchor" href="#安装storm"></a>安装storm</h3><ol><li>准备好storm安装包</li><li>上传解压重命名为storm到/export/server路径下</li><li>修改配置文件 storm.yaml</li></ol><h3 id="运行"><a class="header-anchor" href="#运行"></a>运行</h3><ul><li>前台启动 (前台启动会占用窗口)<br>（1）在node1上启动 nimbus进程(主节点) 和 web UI<br>（2）在 node2 和 node3 上启动 supervisor(从节点)</li><li>后台启动</li></ul><h4 id="ssh脚本实现一键启动"><a class="header-anchor" href="#ssh脚本实现一键启动"></a>ssh脚本实现一键启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.#!/bin/bash</span><br><span class="line">source /etc/profile</span><br><span class="line">nohup /export/server/storm/bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "node1 nimbus is running"</span><br><span class="line">nohup /export/server/storm/bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "node1 core is running"</span><br><span class="line">for host in node2 node3</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ssh $host "source /etc/profile;nohup /export/server/storm/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;"</span><br><span class="line">echo "$host Supervisor is running"</span><br><span class="line">&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="进入web页面查看集群"><a class="header-anchor" href="#进入web页面查看集群"></a>进入web页面查看集群</h3><h2 id="使用入门"><a class="header-anchor" href="#使用入门"></a>使用入门</h2><h3 id="MAVEN依赖"><a class="header-anchor" href="#MAVEN依赖"></a>MAVEN依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>storm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 目前&lt;scope&gt;可以使用5个值：</span></span><br><span class="line"><span class="comment">    * compile，缺省值，适用于所有阶段，会随着项目一起发布。</span></span><br><span class="line"><span class="comment">    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。</span></span><br><span class="line"><span class="comment">    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。</span></span><br><span class="line"><span class="comment">    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</span></span><br><span class="line"><span class="comment">    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理"><a class="header-anchor" href="#编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理"></a>编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Version: </span></span><br><span class="line"><span class="comment"> * Description: 读取外部文件,把一行一行的数据发送给下游的bolt</span></span><br><span class="line"><span class="comment"> *              类似于hadoop mapreduce的inputformat</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="comment">//BaseBasicSpout</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFileSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector spoutOutputCollector;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader bufferedReader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法, 类似于这个类的构造器, 只被运行一次</span></span><br><span class="line"><span class="comment">     * spout组件读取原始数据为bolt提供数据</span></span><br><span class="line"><span class="comment">     * 一般用来打开数据链接, 打开网络连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象, 一般不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//本地模式</span></span><br><span class="line">            <span class="comment">//this.bufferedReader = new BufferedReader(new FileReader(new File("D:\\wordcount.txt")));</span></span><br><span class="line">            <span class="comment">//集群模式</span></span><br><span class="line">            <span class="keyword">this</span>.bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"//root//stormdata//wordcount.txt"</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.spoutOutputCollector = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个tuple, tuple是数据传送的基本单位</span></span><br><span class="line"><span class="comment">     * 不断地往下一个组件发送tuple消息</span></span><br><span class="line"><span class="comment">     * 这里面是该spout组件的核心逻辑</span></span><br><span class="line"><span class="comment">     * 如从kafka消息队列中拿到数据</span></span><br><span class="line"><span class="comment">     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//一行一行的读取文件内容,并且一行一行的发送</span></span><br><span class="line">            line = bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (line != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//将信息封装成tuple，发送消息给下一个组件</span></span><br><span class="line">        <span class="comment">//this.collector.emit(new Value(this.words[index]));</span></span><br><span class="line"></span><br><span class="line">                spoutOutputCollector.emit(Arrays.asList(line));</span><br><span class="line"></span><br><span class="line"><span class="comment">//每发送一个消息，休眠500ms</span></span><br><span class="line">       <span class="comment">// Thread.sleep(500);</span></span><br><span class="line"><span class="comment">// Utils.sleep(500);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字段声明发出的数据是什么,tuple中的数据的字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"line"</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Bolt类对出入的内容进行单词切分"><a class="header-anchor" href="#编写Bolt类对出入的内容进行单词切分"></a>编写Bolt类对出入的内容进行单词切分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Description: 输入一行一行的数据</span></span><br><span class="line"><span class="comment"> *              对一行数据进行切割</span></span><br><span class="line"><span class="comment"> *              输出单词及单词出现的次数</span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment">//BaseBasicBolt</span></span><br><span class="line"><span class="comment">public class SplitBolt extends BaseRichBolt &#123;</span></span><br><span class="line"><span class="comment">    private OutputCollector outputCollector;</span></span><br><span class="line"><span class="comment">    /**</span></span><br><span class="line"><span class="comment">     * 初始化方法,只被运行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector 数据收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputCollector = outputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行业务逻辑的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tuple 获取的上游数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上游句子(字段:"line"),从tuple中读取数据</span></span><br><span class="line"><span class="comment">//获取nextTuple()方法emit()过来的数据</span></span><br><span class="line">        String line = tuple.getStringByField(<span class="string">"line"</span>);</span><br><span class="line">        <span class="comment">//对句子进行切割</span></span><br><span class="line">        String[] words = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//需要发送单词和单词出现的次数,总共两个字段</span></span><br><span class="line">            outputCollector.emit(Arrays.asList(word, <span class="string">"1"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明发送出去的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"num"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Bolt类对单词进行计数"><a class="header-anchor" href="#编写Bolt类对单词进行计数"></a>编写Bolt类对单词进行计数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce</span></span><br><span class="line"><span class="comment">*              输入单词及单词出现的次数</span></span><br><span class="line"><span class="comment">*              输出打印在控制台</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个map用于储存单词及其数量</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; wordCountMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector 数据收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取信息(单词, 数量)</span></span><br><span class="line">        String word = tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        String num = tuple.getStringByField(<span class="string">"num"</span>);</span><br><span class="line">        <span class="comment">//使用map进行记录</span></span><br><span class="line">        <span class="comment">//开始计数</span></span><br><span class="line">        <span class="keyword">if</span> (wordCountMap.containsKey(word))&#123;</span><br><span class="line">            <span class="comment">//如果map里已经有这个单词,就把数量进行累加</span></span><br><span class="line">            Integer integer = wordCountMap.get(word);</span><br><span class="line">            wordCountMap.put(word, integer + Integer.parseInt(num));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果map里已经没有这个单词,就把单词和数量放入map</span></span><br><span class="line">            wordCountMap.put(word, Integer.parseInt(num));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(wordCountMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于不向外发送数据,所以不用写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写启动类对程序进行整合"><a class="header-anchor" href="#编写启动类对程序进行整合"></a>编写启动类对程序进行整合</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Description: wordcount驱动类,用来提交任务</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WordCountTopology</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException</span> &#123;</span><br><span class="line">        <span class="comment">//通过TopologyBuilder 封装任务信息</span></span><br><span class="line">        TopologyBuilder topologyBuilder = <span class="keyword">new</span> TopologyBuilder();</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//设置spout获取数据</span></span><br><span class="line">        <span class="comment">//SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件</span></span><br><span class="line"><span class="comment">//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task</span></span><br><span class="line"></span><br><span class="line">        topologyBuilder.setSpout(<span class="string">"readfilesspout"</span>, <span class="keyword">new</span> ReadFileSpout(), <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置splitbolt 对句子进行切割</span></span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"splitbolt"</span>, <span class="keyword">new</span> SplitBolt(), <span class="number">4</span>).shuffleGrouping(<span class="string">"readfilesspout"</span>);</span><br><span class="line">        <span class="comment">//设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息</span></span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"wordcountbolt"</span>, <span class="keyword">new</span> WordCountBolt(), <span class="number">2</span>).shuffleGrouping(<span class="string">"splitbolt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备一个配置文件，配置一些topology在集群中运行的参数</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动2个worker!</span></span><br><span class="line">        config.setNumWorkers(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务提交有:本地模式 和 集群模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//本地模式</span></span><br><span class="line">        <span class="comment">//LocalCluster localCluster = new LocalCluster();</span></span><br><span class="line">        <span class="comment">//localCluster.submitTopology("wordcount", config, topologyBuilder.createTopology());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集群模式,参数:Topology名字, 配置文件, Topology对象</span></span><br><span class="line"><span class="comment">//用builder来创建topology</span></span><br><span class="line">        StormSubmitter.submitTopology(<span class="string">"wordcount2"</span>, config, topologyBuilder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行程序"><a class="header-anchor" href="#执行程序"></a>执行程序</h3><ol><li>选择本地模式运行<br>直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台</li><li>选择上传到集群进行执行<br>首先通过maven的package命名将程序打好jar包</li></ol><h4 id="注：-v2"><a class="header-anchor" href="#注：-v2"></a>注：</h4><p>在storm-core的依赖中加入:<scope>provided</scope><br>在上传到node2或node3上, 在指定路径下要确保存在日志文件</p><h1 id="Storm-Distributed-RPC（DRPC）"><a class="header-anchor" href="#Storm-Distributed-RPC（DRPC）"></a>Storm Distributed RPC（DRPC）</h1><h2 id="分布式远程过程调用"><a class="header-anchor" href="#分布式远程过程调用"></a>分布式远程过程调用</h2><ul><li>DRPC的主要作用就是利用Storm的<strong>实时计算</strong>能力来<strong>并行化</strong>CPU intensive的计算。</li><li>对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。</li><li>DRPC其实不能算是storm本身的一个特性，它是通过组合storm的<strong>原语</strong>spout，bolt，topology而成的一种模式(pattern)。</li><li>DRPC通过一个&quot;DRPC server&quot;来进行<strong>协调均衡</strong>。（Storm整合了DRPC server的一个实现）。</li><li>DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。</li><li>对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。</li></ul><h3 id="客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果："><a class="header-anchor" href="#客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果："></a>客户端使用DRPC来获取以&quot;<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a>&quot;为参数的&quot;reach&quot;函数的返回结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"drpc-host"</span>, <span class="number">3772</span>);</span><br><span class="line">String result = client.execute(<span class="string">"reach"</span>, <span class="string">"http://baidu.com"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim" alt="mark"></p><h4 id="1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用"><a class="header-anchor" href="#1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用"></a>1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用</h4><h4 id="2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。"><a class="header-anchor" href="#2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。"></a>2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。</h4><h4 id="3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。"><a class="header-anchor" href="#3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。"></a>3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。</h4><h4 id="4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。"><a class="header-anchor" href="#4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。"></a>4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。</h4><h4 id="5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。"><a class="header-anchor" href="#5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。"></a>5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。</h4><h2 id="LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）"><a class="header-anchor" href="#LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）"></a>LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）</h2><h3 id="Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下"><a class="header-anchor" href="#Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下"></a>Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:</h3><ol><li>建立 spout</li><li>将结果返回到DRPC server</li><li>向bolts提供了在tuples集合上进行有限聚集的功能</li></ol><h4 id="创建LinearDRPCTopologyBuilder"><a class="header-anchor" href="#创建LinearDRPCTopologyBuilder"></a>创建LinearDRPCTopologyBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclaimBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">        String input = tuple.getString(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//简单的在元组的第二个字段的值后加了一个"!"</span></span><br><span class="line">        collector.emit(<span class="keyword">new</span> Values(tuple.getValue(<span class="number">0</span>), input + <span class="string">"!"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//我们将DRPC函数名告诉给topology（本例函数名为exclamation）。</span></span><br><span class="line">  <span class="comment">//单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。</span></span><br><span class="line">  <span class="comment">//第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。</span></span><br><span class="line">    LinearDRPCTopologyBuilder builder = <span class="keyword">new</span> LinearDRPCTopologyBuilder(<span class="string">"exclamation"</span>);</span><br><span class="line">    builder.addBolt(<span class="keyword">new</span> ExclaimBolt(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Local-mode-DRPC"><a class="header-anchor" href="#创建Local-mode-DRPC"></a>创建Local mode DRPC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。</span></span><br><span class="line">LocalDRPC drpc = <span class="keyword">new</span> LocalDRPC();</span><br><span class="line"><span class="comment">//然后创建LocalCluster来以本地模式来运行该topology。</span></span><br><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line"><span class="comment">//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。</span></span><br><span class="line"><span class="comment">//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象</span></span><br><span class="line"><span class="comment">//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;</span></span><br><span class="line">cluster.submitTopology(<span class="string">"drpc-demo"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class="line"><span class="comment">//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。</span></span><br><span class="line">System.out.println(<span class="string">"Results for 'hello':"</span> + drpc.execute(<span class="string">"exclamation"</span>, <span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">cluster.shutdown();</span><br><span class="line">drpc.shutdown();</span><br></pre></td></tr></table></figure><h4 id="Remote-mode-DRPC"><a class="header-anchor" href="#Remote-mode-DRPC"></a>Remote mode DRPC</h4><ol><li>建立DRPC servers</li><li>配置DRPC servers的位置</li><li>向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：</li></ol><h5 id="1-用storm脚本建立DRPC-server："><a class="header-anchor" href="#1-用storm脚本建立DRPC-server："></a>1. 用storm脚本建立DRPC server：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/storm drpc</span><br></pre></td></tr></table></figure><h5 id="2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置"><a class="header-anchor" href="#2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置"></a>2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drpc.servers:</span><br><span class="line">  - <span class="string">"drpc1.foo.com"</span></span><br><span class="line">  - <span class="string">"drpc2.foo.com"</span></span><br></pre></td></tr></table></figure><h5 id="3-通过StormSubmitter建立DRPC-topologies"><a class="header-anchor" href="#3-通过StormSubmitter建立DRPC-topologies"></a>3. 通过StormSubmitter建立DRPC topologies</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology(<span class="string">"exclamation-drpc"</span>, conf, builder.createRemoteTopology());</span><br></pre></td></tr></table></figure><h2 id="Storm-DRPC深入"><a class="header-anchor" href="#Storm-DRPC深入"></a>Storm DRPC深入</h2><p>分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的<strong>函数调用</strong>进行<strong>并行计算</strong>。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。<br>可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。</p><h3 id="注：-v3"><a class="header-anchor" href="#注：-v3"></a>注：</h3><p>Storm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）<br>Storm只负责数据的计算，不负责数据的存储<br>2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x</p><p><img src="https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim" alt="mark"><br><strong>其中:</strong><br>Nimbus：负责资源分配和任务调度。<br>Supervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>Worker：运行具体处理组件逻辑的进程。<br>Task：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。<br><img src="https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim" alt="mark"></p><h3 id="注：-v4"><a class="header-anchor" href="#注：-v4"></a>注：</h3><p><strong>DataSource</strong>: 数据源<br><strong>Spout</strong>：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。<br><strong>Bolt</strong>：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。<br><strong>Tuple</strong>：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.<br><strong>Stream</strong>：源源不断传递的tuple就组成了stream。<br><strong>Topology</strong>：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。</p><h3 id="分组策略"><a class="header-anchor" href="#分组策略"></a>分组策略</h3><ol><li>随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用</li><li>字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。</li><li>LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。</li></ol><h2 id="zookeeper安装和使用"><a class="header-anchor" href="#zookeeper安装和使用"></a>zookeeper安装和使用</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p><h3 id="zoo-sample-cfg文件配置"><a class="header-anchor" href="#zoo-sample-cfg文件配置"></a>zoo_sample.cfg文件配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">D:\\DevelopSoftware\\zookeeper\\zookeeper-3.4.14\\data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">D:\\DevelopSoftware\\zookeeper\\zookeeper-3.4.14\\log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure><h3 id="参数解释"><a class="header-anchor" href="#参数解释"></a>参数解释</h3><ul><li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li><li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒</li><li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒</li><li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li><li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li></ul><h3 id="异常"><a class="header-anchor" href="#异常"></a>异常</h3><p>Socket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information<br>**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg</p><p>zookeeper启动成功<br><img src="https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim" alt="mark"></p><h2 id="Zookeeper伪分布式集群搭建"><a class="header-anchor" href="#Zookeeper伪分布式集群搭建"></a>Zookeeper伪分布式集群搭建</h2><ol><li>将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。</li><li>创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。</li><li>在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.</li><li>修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改</li></ol><h3 id="zoo-cfg文件如下"><a class="header-anchor" href="#zoo-cfg文件如下"></a>zoo.cfg文件如下</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># 服务器与客户端之间交互的基本时间单元（ms）</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># zookeeper所能接受的客户端数量</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># 服务器与客户端之间请求和应答的时间间隔</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 保存zookeeper数据，日志路径</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">D:/DevelopSoftware/zookeeper/zk-data/8001/data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">D:/DevelopSoftware/zookeeper/zk-data/8001/log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 这是客户端链接的端口号</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口</span></span><br><span class="line"><span class="comment"># server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。</span></span><br><span class="line"><span class="comment"># 客户端与zookeeper相互交互的端口</span></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:8001:9001</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:8002:9002</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:8003:9003</span></span><br></pre></td></tr></table></figure><h3 id="报错"><a class="header-anchor" href="#报错"></a>报错</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> [myid:<span class="number">1</span>] - WARN  [WorkerSender[myid=<span class="number">1</span>]:QuorumCnxManager@<span class="number">584</span>] - Cannot open channel to <span class="number">3</span> at election address /<span class="number">127.0</span>.0.1:<span class="number">9003</span></span><br><span class="line">java.net.ConnectException: Connection refused: connect</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:<span class="number">85</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span><br><span class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:<span class="number">172</span>)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:<span class="number">392</span>)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:<span class="number">589</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:<span class="number">558</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:<span class="number">534</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:<span class="number">454</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:<span class="number">435</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><h3 id="报错解决办法"><a class="header-anchor" href="#报错解决办法"></a>报错解决办法</h3><p>产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty(笔记)</title>
      <link href="/2020/01/16/Netty%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/16/Netty%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="业界哪些流行的开源框架用Netty作为底层通信框架"><a class="header-anchor" href="#业界哪些流行的开源框架用Netty作为底层通信框架"></a>业界哪些流行的开源框架用Netty作为底层通信框架</h2><ul><li>Dubbo： 阿里开源的高性能RPC框架</li><li>RocketMQ： 阿里出品的高性能消息队列</li><li>Spark： 炙手可热的大数据处理引擎，底层使用Netty</li><li>Elasticsearch： 分布式多用户的全文搜索引擎</li><li>Apache Cassandra：开源分布式搜索数据库</li><li>Flink:分布式高性能高可用的流处理框架</li><li>Netty-SocketIO的java服务端实现</li><li>Spring5：使用Netty作为http协议框架</li><li>Play：简单易用的http服务器</li><li>Grpc:google开源的高性能rpc通信框架</li><li>Infinispan：针对缓存的高并发键值对数据存储</li><li>HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统</li><li>Vert.x轻量级高性能能JVM应用平台<br>-<br><a href="https://netty.io/wiki/adopters.html" target="_blank" rel="noopener">完整的参考列表</a></li></ul><h2 id="业界有哪些公司在使用Netty"><a class="header-anchor" href="#业界有哪些公司在使用Netty"></a>业界有哪些公司在使用Netty</h2><p><strong>在大型企业中</strong>有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram<br><br><strong>在初创企业中</strong>有：做http长连接的<strong>Firebase</strong>、支持各种各样消息推送通知的<strong>Urban Airship</strong><br><br><br> 当然，Netty也从这些项目中<strong>受益</strong>。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。</p><h2 id="Netty是什么"><a class="header-anchor" href="#Netty是什么"></a>Netty是什么</h2><ol><li><strong>异步</strong>和<strong>事件驱动</strong>的高性能网络通信框架。</li><li>**特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。</li><li>**目的:**用于快速开发高性能服务端和客户端</li><li>**封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易</li><li>自带编解码器解决拆包粘包问题，用户只关心业务逻辑</li><li>精心设计的reactor线程模型支持高并发海量连接</li><li>自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手</li><li>**架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离–业务和网络逻辑解耦，模块化和可复用性，可测试性。</li></ol><h2 id="Netty的特性总结"><a class="header-anchor" href="#Netty的特性总结"></a>Netty的特性总结</h2><p><img src="https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim" alt="mark"></p><h2 id="Socket-Netty"><a class="header-anchor" href="#Socket-Netty"></a>Socket &amp; Netty</h2><p><img src="https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim" alt="Socket &amp; Netty"></p><h2 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h2><p><img src="https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim" alt="mark"></p><ul><li>NioEventLoop -&gt;Thread</li><li>Channel -&gt;Socket  <br>NioSocketChannel implements Channel<br>Chennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind</li><li>ByteBuf -&gt;IO Bytes<br>readBytes()、writeBytes() and so on</li><li>Pipline -&gt;Logic Chain 逻辑链</li><li>ChannelHandler -&gt;Logic处理块</li></ul><h2 id="Netty核心组件"><a class="header-anchor" href="#Netty核心组件"></a>Netty核心组件</h2><h3 id="1-Channel-Socket"><a class="header-anchor" href="#1-Channel-Socket"></a>1. Channel-Socket</h3><p>Channel是通讯的载体，其基本构造是Socket<br>是对网络底层读写和连接原语言的抽象</p><h3 id="2-EventLoop-控制流、多线程处理、并发"><a class="header-anchor" href="#2-EventLoop-控制流、多线程处理、并发"></a>2. EventLoop-控制流、多线程处理、并发</h3><p>定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件</p><h3 id="注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"><a class="header-anchor" href="#注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"></a>注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系</h3><p><img src="https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim" alt="mark">)</p><h5 id="A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"><a class="header-anchor" href="#A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"></a>A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；</h5><h5 id="B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"><a class="header-anchor" href="#B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"></a>B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定</h5><h5 id="C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"><a class="header-anchor" href="#C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"></a>C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</h5><h5 id="D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"><a class="header-anchor" href="#D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"></a>D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；</h5><h5 id="E-一个-EventLoop-可能会被分配给一个或多个-Channel"><a class="header-anchor" href="#E-一个-EventLoop-可能会被分配给一个或多个-Channel"></a>E. 一个 EventLoop 可能会被分配给一个或多个 Channel</h5><h5 id="F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"><a class="header-anchor" href="#F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"></a>F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。</h5><h3 id="3-ChannelFuture-异步通知"><a class="header-anchor" href="#3-ChannelFuture-异步通知"></a>3. ChannelFuture-异步通知</h3><p>Netty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法</p><h3 id="4-ChannelHandler和ChannelPipeline"><a class="header-anchor" href="#4-ChannelHandler和ChannelPipeline"></a>4. ChannelHandler和ChannelPipeline</h3><p>ChannelHandler负责Channel中的逻辑处理<br>其旨在简化应用程序处理逻辑的开发过程<br>充当了所有处理入站和出站数据的应用程序逻辑的容器<br>ChannelHandler子接口：<br>ChannelInboundHandler——处理入站数据以及各种状态变化<br>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作<br>ChannelInboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim" alt="mark"><br>ChannelOutboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim" alt="mark"></p><p>ChannelPipeline 提供了 ChannelHandler链的容器<br>定义了用于在该链上传播入站和出站事件流的API</p><h3 id="5-ByteBuf-Netty的数据容器"><a class="header-anchor" href="#5-ByteBuf-Netty的数据容器"></a>5. ByteBuf-Netty的数据容器</h3><p>Java NIO提供了ByteBuffer作为它的字节容器<br>Netty的ByteBuffer替代品是ByteBuf</p><h5 id="A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"><a class="header-anchor" href="#A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"></a>A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；</h5><h5 id="B-容量可以按需增长（类似于-JDK-的-StringBuilder）"><a class="header-anchor" href="#B-容量可以按需增长（类似于-JDK-的-StringBuilder）"></a>B.容量可以按需增长（类似于 JDK 的 StringBuilder）</h5><h5 id="C-读和写使用了不同的索引"><a class="header-anchor" href="#C-读和写使用了不同的索引"></a>C.读和写使用了不同的索引</h5><h5 id="D-支持方法的链式调用"><a class="header-anchor" href="#D-支持方法的链式调用"></a>D.支持方法的链式调用</h5><h5 id="E-支持引用计数"><a class="header-anchor" href="#E-支持引用计数"></a>E.支持引用计数</h5><h5 id="F-支持池化"><a class="header-anchor" href="#F-支持池化"></a>F.支持池化</h5><h3 id="6-Bootstap-引导客户端和无连接协议"><a class="header-anchor" href="#6-Bootstap-引导客户端和无连接协议"></a>6. Bootstap-引导客户端和无连接协议</h3><p>Bootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel<br><img src="http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg" alt></p><h2 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h2><p>使用EmbeddedChannel 测试 ChannelHandler</p><ol><li>测试入站消息</li><li>测试出站消息</li><li>测试异常处理</li></ol><h2 id="编解码器"><a class="header-anchor" href="#编解码器"></a>编解码器</h2><ul><li>解码器<br>将字节解码为消息<br>将一种消息类型解码为另一种</li><li>编码器<br>将消息编码为字节<br>将消息编码为消息</li></ul><h2 id="Netty服务端启动"><a class="header-anchor" href="#Netty服务端启动"></a>Netty服务端启动</h2><ol><li>创建服务端Channel</li><li>初始化服务端Channel</li><li>注册Selector</li><li>端口绑定，实现对本地端口的接听</li></ol><h2 id="预置的ChannelHandler和编解码器"><a class="header-anchor" href="#预置的ChannelHandler和编解码器"></a>预置的ChannelHandler和编解码器</h2><ol><li>通过 SSL/TLS 保护 Netty 应用程序</li><li>ChannelHandler处理 HTTP 和 HTTPS协议</li><li>支持WebSocket</li><li>ChannelHandler检测空闲连接以及超时</li><li>FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域</li><li>使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据</li><li>使用UDP广播事件</li></ol><h3 id="创建服务端Channel"><a class="header-anchor" href="#创建服务端Channel"></a>创建服务端Channel</h3><p><strong>bind()[用户代码入口] -&gt;initAndRegister()[初始化并注册] -&gt;newChannel()[创建服务端channel]</strong><br><img src="https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim" alt="mark"></p><h2 id="如何使用Netty进行RPC服务器的开发"><a class="header-anchor" href="#如何使用Netty进行RPC服务器的开发"></a>如何使用Netty进行RPC服务器的开发?</h2><ol><li>定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</li><li>服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</li><li>客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</li><li>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</li><li>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。<br><img src="https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim" alt="mark"> <strong>客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。</strong><br>Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</li><li><img src="https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim" alt="mark"><br><strong>客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</strong></li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="Netty疑问"><a class="header-anchor" href="#Netty疑问"></a>Netty疑问</h3><ol><li>Netty是什么？<br>Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。</li><li>使用Netty能够做什么？<br>①开发异步、非阻塞的TCP网络应用程序；<br>②开发异步、非阻塞的UDP网络应用程序；<br>③开发异步文件传输应用程序；<br>④开发异步HTTP服务端和客户端应用程序；<br>⑤提供对多种编解码框架的集成；<br>⑥提供形式多样的编解码基础类库；<br>⑦基于职责链模式的Pipeline-Handler机制；<br>⑧所有的IO操作都是异步的；<br>⑨IP黑白名单控制，性能统计；<br>⑩基于链路空闲事件检测的心跳检测；</li><li>Netty在哪些行业得到了应用<br>**①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。<br>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。<br>除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。<br>**②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。<br>**③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。<br>**④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。<br>**⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。</li><li>使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？<br>传统的同步阻塞IO通信存在如下几个问题：<br>**①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>**②性能差：**频繁的线程上下文切换导致CPU利用效率不高；<br>**③可靠性差：*<em>由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br><strong>采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：</strong><br>①Nio采用Reactor模式</em>，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N &lt; 进程可用的最大句柄数)；<br>②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；<br>③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。<br><strong>由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。</strong></li><li>为什么不直接基于JDK的NIO类库编程呢？<br>即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。</li><li>为什么要选择Netty框架？<br>Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。<br>Netty的优点总结如下：<br>①API使用简单，开发门槛低；<br>②功能强大，预置了多种编解码功能，支持多种主流协议；<br>③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；<br>④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；<br>⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；<br>⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；<br>⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。</li></ol><h2 id="代码"><a class="header-anchor" href="#代码"></a>代码</h2><h3 id="1-基于Netty的客户端和服务端的简单通信"><a class="header-anchor" href="#1-基于Netty的客户端和服务端的简单通信"></a>1. 基于Netty的客户端和服务端的简单通信</h3><h5 id="要点："><a class="header-anchor" href="#要点："></a>要点：</h5><p>①为初始化客户端， 创建了一个 Bootstrap 实例<br>②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；<br>③为服务器连接创建了一个 InetSocketAddress 实例；<br>④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；<br>⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；<br><img src="https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim" alt="mark"></p><p><code>&lt;!--more--&gt;</code></p><h3 id="EchoServer"><a class="header-anchor" href="#EchoServer"></a>EchoServer</h3><h3 id="EchoServerHandler"><a class="header-anchor" href="#EchoServerHandler"></a>EchoServerHandler</h3><h5 id="channelRead-—对于每个传入的消息都要调用；"><a class="header-anchor" href="#channelRead-—对于每个传入的消息都要调用；"></a>channelRead()—对于每个传入的消息都要调用；</h5><h5 id="channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"><a class="header-anchor" href="#channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"></a>channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；</h5><h5 id="exceptionCaught-—在读取操作期间，有异常抛出时会调用。"><a class="header-anchor" href="#exceptionCaught-—在读取操作期间，有异常抛出时会调用。"></a>exceptionCaught()—在读取操作期间，有异常抛出时会调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标示一个ChannelHandler可以被多个 Channel 安全地共享</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//将消息记录到控制台</span></span><br><span class="line">        System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">//将接收到的消息写给发送者，而不冲刷出站消息</span></span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将未决消息冲刷到远程节点，并且关闭该 Channel</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印异常栈跟踪</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="comment">//关闭该Channel</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EchoServer-v2"><a class="header-anchor" href="#EchoServer-v2"></a>EchoServer</h3><h5 id="绑定到服务器将在其上监听并接受传入连接请求的端口；"><a class="header-anchor" href="#绑定到服务器将在其上监听并接受传入连接请求的端口；"></a>绑定到服务器将在其上监听并接受传入连接请求的端口；</h5><h5 id="配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"><a class="header-anchor" href="#配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"></a>配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoServer.class.getSimpleName() +<span class="string">" &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span></span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//调用服务器的 start()方法</span></span><br><span class="line">        <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="comment">//(1) 创建EventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//(2) 创建ServerBootstrap</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//(3) 指定所使用的 NIO 传输 Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//(4) 使用指定的端口设置套接字地址</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    <span class="comment">//(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例</span></span><br><span class="line">                            <span class="comment">//这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，</span></span><br><span class="line">                            ch.pipeline().addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成</span></span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            System.out.println(EchoServer.class.getName() +</span><br><span class="line">                    <span class="string">" started and listening for connections on "</span> + f.channel().localAddress());</span><br><span class="line">            <span class="comment">//(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//(8) 关闭 EventLoopGroup，释放所有的资源</span></span><br><span class="line">            grop.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-ChannelHandler-实现客户端逻辑"><a class="header-anchor" href="#通过-ChannelHandler-实现客户端逻辑"></a>通过 ChannelHandler 实现客户端逻辑</h3><h5 id="channelActive-——在到服务器的连接已经建立之后将被调用；"><a class="header-anchor" href="#channelActive-——在到服务器的连接已经建立之后将被调用；"></a>channelActive()——在到服务器的连接已经建立之后将被调用；</h5><h5 id="channelRead0-——当服务器接收到一条消息时被调用"><a class="header-anchor" href="#channelRead0-——当服务器接收到一条消息时被调用"></a>channelRead0()——当服务器接收到一条消息时被调用</h5><h5 id="exceptionCaught-——在处理过程中引发异常时被调用。"><a class="header-anchor" href="#exceptionCaught-——在处理过程中引发异常时被调用。"></a>exceptionCaught()——在处理过程中引发异常时被调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="comment">//标记该类的实例可以被多个 Channel 共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当被通知 Channel是活跃的时候，发送一条消息</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty rocks!"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录已接收消息的转储</span></span><br><span class="line">        System.out.println(<span class="string">"Client received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在发生异常时，记录错误并关闭Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导客户端"><a class="header-anchor" href="#引导客户端"></a>引导客户端</h3><h5 id="客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"><a class="header-anchor" href="#客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"></a>客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建 Bootstrap</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现</span></span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//适用于 NIO 传输的Channel 类型</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置服务器的InetSocketAddress</span></span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">                    <span class="comment">//在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(</span><br><span class="line">                                    <span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//连接到远程节点，阻塞等待直到连接完成</span></span><br><span class="line">            ChannelFuture f = b.connect().sync();</span><br><span class="line">            <span class="comment">//阻塞，直到Channel 关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池并且释放所有的资源</span></span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() +</span><br><span class="line">                    <span class="string">" &lt;host&gt; &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"><a class="header-anchor" href="#2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"></a>2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架</h3><h5 id="简易RPC有如下特性："><a class="header-anchor" href="#简易RPC有如下特性："></a>简易RPC有如下特性：</h5><ul><li>服务异步调用的支持，回调函数callback的支持</li><li>客户端使用长连接（在多次调用共享连接）</li><li>服务端异步多线程处理RPC请求</li><li>服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。</li><li>通信：使用Netty作为通信框架</li><li>Spring：使用Spring配置服务，加载Bean，扫描注解</li><li>动态代理：客户端使用代理模式透明化服务调用</li><li>消息编解码：使用Protostuff序列化和反序列化消息</li></ul><h5 id="RPC介绍"><a class="header-anchor" href="#RPC介绍"></a>RPC介绍</h5><p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。</p><p><img src="https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim" alt="mark"></p><ul><li>服务端发布服务</li></ul><h5 id="服务注解："><a class="header-anchor" href="#服务注解："></a>服务注解：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务接口："><a class="header-anchor" href="#一个服务接口："></a>一个服务接口：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">hello</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务实现：使用注解标注："><a class="header-anchor" href="#一个服务实现：使用注解标注："></a>一个服务实现：使用注解标注：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RpcService</span>(HelloService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + person.getFirstName() + <span class="string">" "</span> + person.getLastName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务在启动的时候扫描得到所有的服务接口及其实现："><a class="header-anchor" href="#服务在启动的时候扫描得到所有的服务接口及其实现："></a>服务在启动的时候扫描得到所有的服务接口及其实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">      <span class="keyword">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class="line">            handlerMap.put(interfaceName, serviceBean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="在Zookeeper集群上注册服务地址："><a class="header-anchor" href="#在Zookeeper集群上注册服务地址："></a>在Zookeeper集群上注册服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedExceptin ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端使用代理模式调用服务："><a class="header-anchor" href="#客户端使用代理模式调用服务："></a>客户端使用代理模式调用服务：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Zookeeper上获取服务地址："><a class="header-anchor" href="#从Zookeeper上获取服务地址："></a>从Zookeeper上获取服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceDiscovery</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">        ZooKeeper zk = connectServer();</span><br><span class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">            watchNode(zk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = dataList.size();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">                data = dataList.get(<span class="number">0</span>);</span><br><span class="line">                LOGGER.debug(<span class="string">"using only data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class="line">                LOGGER.debug(<span class="string">"using random data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watchNode</span><span class="params">(<span class="keyword">final</span> ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        watchNode(zk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : nodeList) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class="string">"/"</span> + node, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                dataList.add(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(<span class="string">"node data: &#123;&#125;"</span>, dataList);</span><br><span class="line">            <span class="keyword">this</span>.dataList = dataList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterrupteException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息编码-请求消息："><a class="header-anchor" href="#消息编码-请求消息："></a>消息编码 请求消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameterTypes</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getParameters() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(Object[] parameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="响应消息："><a class="header-anchor" href="#响应消息："></a>响应消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息序列化和反序列化工具：（基于-Protostuff-实现）"><a class="header-anchor" href="#消息序列化和反序列化工具：（基于-Protostuff-实现）"></a>消息序列化和反序列化工具：（基于 Protostuff 实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Objenesis objenesis = <span class="keyword">new</span> ObjenesisStd(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializationUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Schema&lt;T&gt; <span class="title">getSchema</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class="line">        <span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</span><br><span class="line">            schema = RuntimeSchema.createFrom(cls);</span><br><span class="line">            <span class="keyword">if</span> (schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedSchema.put(cls, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化（对象 -&gt; 字节数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();</span><br><span class="line">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化（字节数组 -&gt; 对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T message = (T) objenesis.newInstance(cls);</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(data, message, schema);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStatexception(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能改进-服务端请求异步处理"><a class="header-anchor" href="#性能改进-服务端请求异步处理"></a>性能改进 服务端请求异步处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,<span class="keyword">final</span> RpcRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcServer.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                LOGGER.debug(<span class="string">"Receive request "</span> + request.getRequestId());</span><br><span class="line">                RpcResponse response = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                response.setRequestId(request.getRequestId());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object result = handle(request);</span><br><span class="line">                    response.setResult(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    response.setError(t.toString());</span><br><span class="line">                    LOGGER.error(<span class="string">"RPC Server handle request error"</span>,t);</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        LOGGER.debug(<span class="string">"Send response for request "</span> + request.getRequestId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="服务端长连接的管理"><a class="header-anchor" href="#服务端长连接的管理"></a>服务端长连接的管理</h5><p>客户端保持和服务进行<strong>长连接</strong>，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。<br>通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。</p><h5 id="客户端请求异步处理"><a class="header-anchor" href="#客户端请求异步处理"></a>客户端请求异步处理</h5><p><strong>客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);</span><br><span class="line">RPCFuture helloFuture = client.call(<span class="string">"hello"</span>, Integer.toString(i));</span><br><span class="line">String result = (String) helloFuture.get(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(上)</title>
      <link href="/2020/01/16/RocketMQ-%E4%B8%8A/"/>
      <url>/2020/01/16/RocketMQ-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RocketMQ-是什么"><a class="header-anchor" href="#1-RocketMQ-是什么"></a>1. RocketMQ 是什么</h2><h4 id="RocketMQ是一款、、、易于使用的消息中间件"><a class="header-anchor" href="#RocketMQ是一款、、、易于使用的消息中间件"></a>RocketMQ是一款<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、易于使用的消息中间件</h4><h4 id="RocketMQ具有以下特性"><a class="header-anchor" href="#RocketMQ具有以下特性"></a>RocketMQ具有以下特性</h4><ul><li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li><li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li><li>支持拉（pull）和推（push）两种消息模式</li><li>单一队列百万消息的堆积能力</li><li>支持多种消息协议，如 JMS、MQTT 等</li><li>分布式高可用的部署架构,满足至少一次消息传递语义</li><li>提供 docker 镜像用于隔离测试和云集群部署</li><li>提供配置、指标和监控等功能丰富的 Dashboard</li></ul><blockquote><h3 id="Producer"><a class="header-anchor" href="#Producer"></a>Producer</h3><p><strong>消息生产者</strong>，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。</p><h3 id="Producer-Group"><a class="header-anchor" href="#Producer-Group"></a>Producer Group</h3><p><strong>生产者组</strong>，就是多个发送同一类消息的生产者称之为一个生产者组。</p></blockquote><blockquote><h3 id="Consumer"><a class="header-anchor" href="#Consumer"></a>Consumer</h3><p><strong>消息消费者</strong>，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p><h3 id="Consumer-Group"><a class="header-anchor" href="#Consumer-Group"></a>Consumer Group</h3><p><strong>消费者组</strong>，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></blockquote><blockquote><h3 id="Topic"><a class="header-anchor" href="#Topic"></a>Topic</h3><p><em>Topic</em> 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推</p><h3 id="Message"><a class="header-anchor" href="#Message"></a>Message</h3><p><em>Message</em>是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p></blockquote><blockquote><h3 id="Tag"><a class="header-anchor" href="#Tag"></a>Tag</h3><p><em>Tag</em><strong>标签</strong>可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息</p><h3 id="Broker"><a class="header-anchor" href="#Broker"></a>Broker</h3><p><em>Broker</em>是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备</p><h3 id="Name-Server"><a class="header-anchor" href="#Name-Server"></a>Name Server</h3><p><em>Name Server</em> 为 producer 和 consumer 提供路由信息。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>响应时间低，比如一个网页在几秒内打开，越短表示延迟越低 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>指的是运行时间能够满足预计时间的一个系统或组件 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
