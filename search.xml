<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>32个Java常用面试点-Java能力框架及学习路径</title>
      <link href="/2021/05/07/%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/05/07/%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Java能力框架及学习路径"><a class="header-anchor" href="#Java能力框架及学习路径"></a>Java能力框架及学习路径</h2><p>衡量每位工程师水平高低的标准，90%比拼的是技术能力，还有一小部分是软实力。建立完整的知识框架，会在职场中表现自己的优势，不再迷茫。在面试过程中可以把它分为基础知识、应用知识、综合能力三大模块的考核。</p><ul><li>基础模块包括：常见技术岗与面试流程、计算机基础JVM原理、多线程、设计模式、数据结构与算法等</li><li>应用模块包括：常用工具集、常用框架、缓存、队列、数据库等</li><li>综合模块包括：项目介绍、系统架构设计、微服务架构、容器化等</li></ul><table><thead><tr><th style="text-align:center">基础模块</th><th style="text-align:center">应用模块</th><th style="text-align:center">综合模块</th></tr></thead><tbody><tr><td style="text-align:center">技术岗位与面试流程</td><td style="text-align:center">常用工具集</td><td style="text-align:center">系统架构设计</td></tr><tr><td style="text-align:center">计算机基础</td><td style="text-align:center">常用框架</td><td style="text-align:center">微服务架构</td></tr><tr><td style="text-align:center">JVM原理</td><td style="text-align:center">缓存</td><td style="text-align:center">容器化</td></tr><tr><td style="text-align:center">多线程</td><td style="text-align:center">队列</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">设计模式</td><td style="text-align:center">数据库</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据结构与算法</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><blockquote><p>不论是应届生，初中级工程师，还是高级/资深工程师，经常会出现自身能力还不错，工作学习也很勤奋，却在找工作时铩羽而归的情况，换工作难的原因有三：</p><ul><li>不知道简历要写什么</li></ul><blockquote><p>​简历不好意味着没有面试机会。技术候选人大约有80%的简历通不过初筛，常见的原因有四种：</p><ol><li><p>工作/项目经验描述得不到位</p></li><li><p>不懂得如何包装自己的技术特长</p></li><li><p>学历不占优势，却放在了最显眼的位置</p></li><li><p>排版太乱，废话太多</p><p><strong>首先看看简历是不是有这些问题</strong>，另外，很多候选人在换工作的时候，按自己的喜好<strong>海投</strong>，从不看岗位的要求，也不会多准备几份简历，这种盲目的投递行为是导致失败的罪魁祸首。简历中的<strong>工作年限、对口经验、学历，甚至简历的美观度、逻辑是否清晰</strong>，都可能是道坎。</p></li></ol></blockquote></blockquote><blockquote><ul><li>不知道面试官要考什么</li></ul><blockquote><p>​很多人接到面试电话，第二天糊里糊涂就去，这种失败率极高。首先，不清楚侧重点、岗位要求。不同行业领域与工作年限对候选人的要求是不一样的，考察点也有所侧重。</p><p>​比如，从行业角度来看，社交门户类考查的是<strong>大规模高并发场景的应用与架构能力</strong>；O2O行业侧重于<strong>综合能力</strong>的考察；而互联网金融更喜欢逻辑缜密，对高可用安全领域有丰富经验的候选人。</p><p>​而针对不同的工作年限，校招面试更多的是对<strong>基础知识与逻辑思维</strong>方面的考察，以培养潜力的考察为主；初中级工程师则需要多关注<strong>知识的广度与基础知识的应用</strong>；而高级或者资深工程师需要深入理解基本原理，能对各种知识灵活运用，以综合的能力考查为主。</p><p>​其次，没有get到面试官的考查意图。举个简单的例子：面试官问使用过某某框架吗？很多人会回答说用过，然后就冷场了。其实，这个问题是想考察<strong>这个框架的使用场景、解决什么样的问题、有什么特点、有何同类型的其他框架</strong>等一系列的问题，如果仅仅回答“是”或者“否”的话，显然没有get到我的意图。同时，也能发现这些候选人在<strong>沟通表达</strong>上有待提高，恐怕会影响到将来的团队协作。</p><p>​    建议在面试前简单对公司<strong>业务岗位职责</strong>做一些功课，做一些有针对性的准备，才能事半功倍。</p></blockquote><ul><li>不知道如何提升晋级</li></ul><blockquote><p>​新技术的<strong>升级换代</strong>非常快，没跟上就可能被淘汰。<strong>不断学习</strong>是非常必要的。很多人都有一个不太好的习惯：东学一点西学一点。当时觉得很有用，可时间长了，发现我的技术并没有因此而提高。究其原因，要么是不成体系很快就遗忘，要么是和现实工作相差太远，无法灵活地运用，遇到了实际案例问题还是无从下手。</p><p>​学习首先要有一个框架，就像书的<strong>目录</strong>一样，<strong>先梗概后细节</strong>，先建立一套<strong>知识体系</strong>再一块一块地夯实。所以需要全面的梳理Java知识体系，建立<strong>思维框架</strong>。</p></blockquote></blockquote><p><img src="https://img.jinguo.tech/blog/image-20210506012953204.png?imageslim" alt="面试大纲"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32个Java常用面试点-概述</title>
      <link href="/2021/05/07/%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/05/07/%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2><p><strong>声明：</strong></p><p>本章节来自于我在拉钩教育上学习的VIP课程《32个Java面试必考点》，讲师是新浪微博资深技术专家-张磊。<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1#/detail/pc?id=1" target="_blank" rel="noopener">课程连接</a></p><p>本章节的知识内容均整理于此课程，仅用于学习记忆。若侵权，请通过本人站点进行联系，本人即刻对内容删除。<a href="https://jinguo.tech">联系站点</a></p><ul><li><p><a href="%E5%BC%80%E7%AF%87%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%B9%B4%E8%96%AA50%E4%B8%87%E7%9A%84%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6.md">开篇：建立年薪50万的能力框架</a></p></li><li><p><a href="%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84.md">第一节：技术人职业发展路径</a></p></li><li><p><a href="%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">第二节：操作系统与计算机网络</a></p></li><li><p>第三节：深入浅出JVM</p></li><li><p>第四节：并发与多线程</p></li><li><p>第五节：数据结构与算法</p></li><li><p>第六节：常用工具集</p></li><li><p>第七节（上）：必会框架-Spring全家桶</p></li><li><p>第七节（下）：必会框架-RPC与ORM</p></li><li><p>第八节：高并发架构基石-缓存</p></li><li><p>第九节（上）：消息队列Kafka架构与原理</p></li><li><p>第九节（下）：MySQL调优与最佳实践</p></li><li><p>第十节：架构的演进之路与前沿技术</p></li><li><p>附录：技术人行走职场的建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32个Java常用面试点-技术人职业发展路径</title>
      <link href="/2021/05/07/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/05/07/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BA%BA%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="技术人职业发展路径"><a class="header-anchor" href="#技术人职业发展路径"></a>技术人职业发展路径</h2><p>在找工作之前应该对目标公司、岗位要求及面试流程有所了解，这样才可以有针对性的突破。</p><hr><h3 id="工程师发展路径"><a class="header-anchor" href="#工程师发展路径"></a>工程师发展路径</h3><p>先从工程师的职业上升空间开始讲解。“能谈谈你对未来的职业规划吗？”相信很多人面试都会被问过这个问题。技术岗和其他岗位一样，首先要对自己的职业有规划。</p><p>一般来说，技术人员对职业发展有两个发展方向，一个是技术方向，另外一个是管理方向，这两条路径侧重的能力点不同，需要根据自己的兴趣、能力优势有侧重的进行能力培养，成长路径如下图所示。</p><p><img src="https://img.jinguo.tech/blog/20210506220442.png?imageslim" alt="发展路径"></p><p>在刚入职的 1～3 年内，技术人员的发展路径比较单一，主要是从工程师往高级工程师发展，这个阶段主要目标是积累，夯实后续发展的基础，重点提高自己的工作基础能力，培养技术深度和广度，对不同方向的新技术保持强烈的好奇心和学习心。</p><p>在一路打怪升级为高级工程师之后，就会面临发展方向的选择：技术 or 管理。</p><ol><li>如果打算往技术方向深挖，上升通道有：资深工程师、技术专家、高级技术专家、研究员、科学家等。需要你重点培养技术攻坚能力，包括疑难问题的排查、大型项目的功能拆分、技术品牌的塑造等。具体的工作包括：原理、实现、注重架构能力的培养，更深一层还有：大规模、高并发场景，高可用、可扩展措施和方案、业务的抽象、架构能力、分布式服务设计原则的理解等。</li><li>另外一个方向就是管理。管理序列偏重于团队把控，需要让团队形成技术战斗力，利用一切资源推进项目，让团队完成作战目标。另外，做好团队内和跨团队的沟通、协作也是管理工作很重要的一环。</li></ol><p>在实际工作中，这两个序列没有特别明显的边界。例如做管理不表示远离架构设计；而技术专家也不是单兵作战，也需要带领团队。这两个方向区分点在于工作内容的侧重点不同：到底是更偏技术架构，还是更偏管理与项目推进。</p><p>回到最开始的面试问题，“你的职业规划是什么？”，答案并不是在面试前打个腹稿就完成任务了，而是在你进入职场，准备成为一位工程师时，心里就该有个谱的。</p><p>这里给有个面试小诀窍，也许这么回答能加分很多：“从过往的经验来看，我对项目的整体规划、管理推进比较感兴趣，在任务推进、协调沟通方面也有比较突出的表现，所以我的职业规划是成为一名优秀的技术经理，并以管理方向为发展目标。“这么接下去，面试官可能会对你的相关经历开始询问。</p><hr><h3 id="常见技术岗位划分"><a class="header-anchor" href="#常见技术岗位划分"></a>常见技术岗位划分</h3><p>除了有明确的职业规划外，想要往高处走还得了解职级划分与对应的软、硬技能要求。这样你在工作的时候可以有意识得补足欠缺，提高水平。</p><p>应聘不同公司、不同级别的岗位时，要重点提升哪方面的技能呢？答案非常简单。</p><p>对照下图，简单介绍 BAT 的技术序列的岗位划分、对应的工作年限及职级。</p><p><img src="https://img.jinguo.tech/blog/20210506220823.png?imageslim" alt="岗位划分"></p><ul><li>1～3 年的初级工程师，这个级别的岗位在阿里、百度、腾讯等大厂很少进行社招，一般是从校招生内部晋升。</li><li>高级工程师一般需要有 2～5 年的工作经验，这个岗位对应百度中的 T4、阿里的 P5，以及腾讯的 T2-2（对应腾讯最新职级体系 T7）。</li><li>资深工程师一般要求 3～6 年工作经验，这个岗位一般对应百度中的 T5、阿里的 P6，以及腾讯的 T2-3（对应腾讯最新职级体系 T8）。高级工程师和资深工程师是各个公司中的绝对技术主力，公司非常看重这部分人才的成长和培养。</li><li>技术专家、高级技术专家至少需要 5 年以上的互联网从业经验。</li></ul><hr><h3 id="面试岗位选择"><a class="header-anchor" href="#面试岗位选择"></a>面试岗位选择</h3><p>在明确发展方向和岗位级别之后，接下来该选公司和岗位了。换工作的时候你也许遇到过这种情况：一个公司有好几个技术岗位，要全都投一遍吗？手里有多个 Offer，应该怎么选，是挑钱多的，还是大平台、福利待遇好的？</p><p>建议：挑选岗位一般从公司规模、业务线或团队的重要程度以及个人条件的匹配度，这几方面来入手。</p><blockquote><p><strong>公司和团队</strong></p><p>先来看公司和团队。要有个概念：现在的每一份工作都是为下一份更好的工作<strong>蓄势</strong>。</p><p>大厂比较适合镀金提高身价，核心业务更适合长期稳定发展，进入核心团队在能力、经验上都能获得较大的成长。</p><p>如下图所示，第一象限是第一种情况，大公司的核心业务无疑是最好的选择，但也是竞争最激烈的，尽量找和自己能力<strong>匹配</strong>的，不要和众多高手竞争，耽误宝贵的求职时间和机会。第三象限，小公司的边缘业务，肯定是下下策，备选。</p><p><img src="https://img.jinguo.tech/blog/20210506221229.png?imageslim" alt="象限"></p><p>剩下的两种情况：一是大公司的边缘业务，另一个是小公司的核心业务。</p><p>这也是最让人头疼的选择，建议：对于工作 1～3 年的小伙伴，我更推荐优先选择<strong>核心业务</strong>。之前我有提到，职业生涯前期以积累知识、经验为主要任务，核心业务可以给你提供更多的<strong>历练场景</strong>，无论是<strong>应用经验</strong>还是<strong>架构经验</strong>都能获得很好的收获。</p></blockquote><blockquote><p><strong>个人匹配度</strong></p><p>另外一个因素：个人匹配度。不是每个人天生就能考上清华北大，考大学大家都要估分再报志愿，职场也是同一个道理，首先需要对自己的条件有客观的评估，再对号入座。评估范围包括岗位要求、业务方向，还有自身能力、兴趣、经验等的匹配程度。匹配程度越高，面试的成功率就会更高，也更有利于入职后个人的发展。</p><p>一句话总结就是：<strong>优先选择核心业务</strong>，以及与自己条件<strong>高度匹配</strong>的岗位。</p></blockquote><blockquote><p><strong>常见面试流程</strong></p><p>在搞清楚前面几点之后，面试流程也是找工作前必须了解的。我见过一些候选人对面试的要求都不了解，也没有进行对应轮次的面试准备就直接来了，这很可能会浪费一次机会。</p><p>对于技术岗，大部分公司的面试流程基本相同，如下图所示，分为 6 个环节。</p><p><img src="https://img.jinguo.tech/blog/20210506230829.png?imageslim" alt="常见面试流程"></p><ol><li><p>首先，可能会有一些前置的面试，假如应聘的是异地的职位，可能会先安排电话面试，大概了解候选人的情况和技术水平。还有一些公司会在正式面试前先进行笔试，或者上机编程。因此初次面试前一定要跟面试官沟通是否会先进行电话面试，是否有笔试或上机编程，是否需要自带电脑等细节。</p></li><li><p>正式面试是从技术一面开始的，可能会有 1~2 位面试官，他们很有可能就是你入职后的同组同事。一面以考察基础能力与实际应用能力为主，时长大概 1 小时左右，是纯技术面试。可能会要求手写一些小算法，例如排序、字符串处理之类的，这方面具体考点大家可以关注后面的算法面试课。</p></li><li><p>技术二面也是以技术面为主，偏重技术深度的考察，例如项目经历、架构能力、算法等，面试时长 1 小时左右，可能会要求画出项目的架构图，交互流程图等，并对项目存在的问题和改进方案等进行询问。一般技术二面的面试官就是你入职后的直属领导。</p></li><li><p>一些规模较小的公司，到二面就结束了，而大部分的公司会有技术三面。技术三面一般是半技术面试，会有一些项目经历、架构设计的题目，另外还会涉及职业规划、职业兴趣、技术视野等方面的问题，以架构能力、技术敏感度、发展潜力为主。三面的面试官一般是部门的 leader。还有少部分公司会存在技术四面，例如腾讯在较高级别岗位面试时，会有跨部门的交叉面试，面试内容与三面基本相同。</p></li><li><p>如果你很幸运通过了前面的几轮技术面试，那么就进入 HR 面试阶段，这个阶段之后基本不会再出现技术面试了，主要沟通个人的发展规划、上家公司的离职原因、价值观和薪资待遇等。如果你对这家公司特别期待，注意不要在这个环节因为纠结 1～2k 的工资而错失机会。工作前期以积累能力为主，3 年后我们再谈待遇。</p></li><li><p>HR 面试后是公司级高管面试，具体轮次看情况，一般一、二 面，非技术面为主，可能会简单询问工作经历、对公司的看法、对行业的看法、未来规划等，只要没有原则性错误，一般都能够通过。</p></li></ol><p><strong>整体总结如下：</strong></p><ul><li>面试前询问是否有电话面试、笔试、上机等前置面试；</li><li>技术一面、二面关注实际工作能力；</li><li>二面、三面偏重架构能力与发展潜力，二面与三面一般决定你的入职职级，一定要好好表现。</li></ul></blockquote><blockquote><p><strong>面试前准备工作</strong></p><p>假设你明天就有个面试，那么，前期的准备工作对面试成败起到决定性的作用。影响面试成功的三大基石是：能力、心态和沟通。</p><ol><li><p>能力。优秀的技术基本功是必要条件，毕竟公司是招你来解决问题的，没有技术能力其他的都无从谈起；</p></li><li><p>心态。注意平衡心态，过于紧张会导致平时会的内容没有回答上来；</p></li><li><p>沟通。与面试官交流顺畅，会给你的面试加分；反过来如果沟通不顺畅，就可能变成致命一刀，直接被 Pass。</p></li></ol><p>那么，如何在面试时<strong>稳定发挥</strong>？</p><ul><li><p>面试考察点是可以在短期内突击的，也是面试前需要重点准备的内容。</p><p>a 系统地复习基础知识。</p><p>b 对工作经历进行提炼，对原来负责的项目从架构方面重新审视、梳理、总结。</p><p>c 对一些典型框架的原理、使用场景及实现方式进行学习、对常考的考点进行专项突击。</p><p>d 阅读常考考点源码。</p><p>e 根据面试岗位业务有针对性的准备，比如：面试中间件方向的岗位时，可以突出自己有过存储中间件的开发经历、有过链路协议层设计经历等。</p></li><li><p>关于心态，面试前多方面搜集面试公司、岗位所属团队、平均福利等资料信息，知己知彼有助于增加自信。提示一下，有些公司喜欢压力面试，特别在面试官层级较高时发生。在不利场景下多给自己心理暗示，控制情绪，也许有意想不到的收获。例如，这个面试官以后可能再也不会遇到，就算失败了也没什么大不了。</p></li><li><p>沟通方面，几点建议</p><p>a 提前准备一个简短有特色的自我介绍，主要描述自己的技术特长和职业优势，一定不要聊兴趣爱好、家乡、星座等无关紧要的内容。</p><p>b 避免冷场，对于回答不上来的问题，可以主动坦白，并提出解题思路，或者询问面试官可不可以换个问题。</p><p>c 当没有听清，或是不理解问题时不要强行回答，可以跟面试官再次确认问题。</p><p>d 注意一些细节，例如：你的面试微表情，不要皱眉、控制坐姿和手势、说话语速不要过快或过慢、表达逻辑清晰，观点明确；不要随意打断面试官，谦虚有礼的态度等。</p><p>e 还有一个小技巧是需要注意观察面试官的反应。如果面试官突然在简历上奋笔疾书，说明你提供的信息是有用的，如果他停下来很长时间不写了，你要想想是不是跑题了；如果面试官的表情显示出不耐烦，或者深呼吸，有可能你没有领会面试官的考察意图，可以再次询问。</p></li></ul></blockquote><blockquote><p><strong>面试考察点</strong></p><p>面试的考察点非常综合，一般分为硬技能和软实力。</p><ol><li>硬技能包括：基础知识的掌握、以往的项目经验、对系统架构的设计能力，以及对不同框架、工具的综合应用能力。</li><li>软实力一般包括：逻辑思维是否灵活、沟通、表述、协作能力是否优秀、是否有较强的项目管理与推进能力、新技术的学习、总结与思考能力，以及培养潜力这几方面。</li></ol><p>前面 BAT 的职级图中提到，不同等级的岗位，能力要求肯定也不同，这里用雷达图来展示，如下图所示。</p><p><img src="https://img.jinguo.tech/blog/20210506222826.png?imageslim" alt></p><p>首先对于初、中级工程师来说，基本的要求是能完成分配的研发任务，所以面试官更看重<strong>基础知识的掌握</strong>、<strong>逻辑思维</strong>是否灵活，有没有<strong>培养潜力</strong>。其次是<strong>项目经验与学习思考能力</strong>，而架构能力、管理推进，以及沟通协作等能力，受限于工作年限，并不会对这些方面有较高的要求。</p><p>对于高级工程师，一般需要独立完成功能模块或者子项目的设计与开发，所以除了初级工程师应该具备的能力外，对项目经验、沟通协作、架构能力、学习思考、管理推进都有了更高的要求，特别是<strong>项目经验和学习思考能力</strong>。</p><p>而对于技术专家来说，要具备<strong>项目架构、项目经验、管理推进与沟通协作能力</strong>，能够独立负责一个项目，做好项目架构，完成功能模块的拆解与任务分配，推进团队内、外部的事务、协调资源，管理进度，带领技术团队完成任务目标。</p><p>温馨提示，<strong>软实力</strong>功夫做的好，对于技术工程师的职业生涯来说绝对是<strong>加分项</strong>。</p></blockquote><blockquote><p>针对硬技能考察点，提供一份系统化梳理，也是接下来重点的内容，如下图所示。</p><p><img src="https://img.jinguo.tech/blog/CgoB5l12QGeAX1jpAADXc8NHFMU588.jpg?imageslim" alt="硬技能系谱图"></p><ol><li>基础知识分为计算机基础与 Java 体系两大部分，包括了进程、线程管理；TCP、HTTP 网络协议；数据结构、经典算法；常用设计模式等。面试加分的内容，比如，新技术方面：Java 8~11 新特性，G1、ZGC 垃圾回收算法、最新网络协议 HTTP2、QUIC；知识深度方面：内存屏障、指令重排，JIT 编译器、逃逸分析等。</li><li>项目经验部分讲解如何展现自身项目经验，包括项目的描述、流程图、项目难点、项目问题分析与改进等。</li><li>应用知识部分兼顾知识的广度与重点框架的知识深度。包括常用工具、常用框架、缓存、队列及数据库等几个方面。其中工具集以知识广度与实用性为主， 例如 JVM 工具 JFR、tcpdump、Git、vmstat、iostat 等；应用框架以经典架构的常考点为主，包括 Spring、Netty 等主流框架的重点知识。缓存、队列、数据库将以应用场景为主。</li><li>架构能力以微服务架构介绍为主，讲解架构理念与应用场景，也包括一些重点机制的实现方式。例如 Docker、K8s 和 Spring Cloud 等。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32个Java常用面试点-操作系统与计算机网络</title>
      <link href="/2021/05/07/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2021/05/07/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统与计算机网络"><a class="header-anchor" href="#操作系统与计算机网络"></a>操作系统与计算机网络</h2><p>本节主要介绍面试中经常考察的计算机基础知识以及 Java 语言特性。其中，计算机的基础知识是工程师基本能力的体现，也是面试前必须要牢牢掌握的部分。</p><p>本节结构如下：</p><ol><li>面试中经常考察的知识点汇总，方便系统化复习；</li><li>对 TCP 协议、设计模式、Java 基础知识进行详细讲解；</li><li>从面试官角度，总结上述部分内容在面试时的考察点；</li><li>提供一些面试真题及重点题目解题思路。</li></ol><hr><h3 id="操作系统知识点"><a class="header-anchor" href="#操作系统知识点"></a>操作系统知识点</h3><p>先看操作系统相关知识的汇总，如下图所示。操作系统知识对于服务问题的排查定位十分重要，在面试时一般以了解和应用考察为主，面试题目占的比重一般不会太高。</p><p><img src="https://img.jinguo.tech/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F,.jpg?imageslim" alt="操作系统"></p><h3 id="进程与线程"><a class="header-anchor" href="#进程与线程"></a>进程与线程</h3><p>上图左上角的<strong>进程与线程</strong>部分是一个非常重要的考察点。</p><ol><li><p>首先需要掌握进程与线程的区别和联系：</p><ul><li>进程是系统<strong>资源分配</strong>的最小单位，线程是<strong>程序执行</strong>的最小单位；</li><li>进程使用<strong>独立</strong>的数据空间，而线程<strong>共享</strong>进程的数据空间。</li></ul></li><li><p>线程<strong>调度</strong>，简单了解线程的几种调度算法就可以了。比如时间片轮转调度、先来先服务调度、优先级调度、多级反馈队列调度以及高响应比优先调度。</p></li><li><p>线程切换的步骤，主要是了解线程的<strong>上下文切换</strong>，明白线程切换的代价。关于线程的知识在后面的多线程课程中还会有详细讲解，这里先略过。</p></li><li><p>在进程与线程部分还有一个比较常见的考察点，就是<strong>进程间通信</strong>，也就是 IPC。这部分在面试中间件研发的相关职位时经常会考察。如上面知识点汇总图中所示，需要了解这 6 种进程通信方式的原理与适用场景。例如，进程间数据共享的场景可以使用共享内存；进程间数据交换的场景可以使用 Unix Socket 或者消息队列。</p></li><li><p>最后<strong>协程</strong>部分，简单了解协程更轻量化，是在用户态进行调度，切换的代价比线程上下文切换要低很多就可以了，也可以了解 Java 的第三方协程框架，例如 <em>Kilim</em>、<em>Quasar</em> 等。</p></li></ol><hr><h3 id="Linux常用命令"><a class="header-anchor" href="#Linux常用命令"></a>Linux常用命令</h3><p>大部分互联网公司的服务都是在 Linux 系统上运行的，因此 Linux 命令也是面试时的常考点，这部分其实主要考察的是候选人是否有线上问题的<strong>排查</strong>经验，重点学习 <em>AWK</em>、<em>top</em>、<em>netstat</em>、<em>grep</em> 等高频使用的工具。</p><p>还有一些知识点不常考，做适当了解，例如内存分页管理与 Swap 机制、任务队列与 CPU Load 等，这些知识在分析线上问题中十分有用。</p><hr><h3 id="拓展知识"><a class="header-anchor" href="#拓展知识"></a>拓展知识</h3><p>最后是扩展知识点，例如内存屏障、指令乱序、分支预测、<em>NUMA</em> 与 <em>CPU</em> 亲和性等，如果在面试时有机会谈到的话，会在知识深度上给面试官留下比较好的印象。</p><hr><h3 id="计算机网络知识点"><a class="header-anchor" href="#计算机网络知识点"></a>计算机网络知识点</h3><p>计算机网络也是非常重要的基础知识，服务之间通过不同的网络协议进行交互，例如 <em><strong>HTTP</strong></em> 协议、<em><strong>RPC</strong></em> 协议等，在 Java 面试中网络知识被考到的几率非常大。网络知识点汇总如下图。</p><p><img src="https://img.jinguo.tech/blog/CgoB5l13hviANIAQAAJGI9kixgc615.jpg?imageslim" alt="计算机网络"></p><p>首先你应该深刻理解网络的 4/7 层模型，这是网络知识的基础。</p><ul><li>另外两个非常重要的网络协议就是 <em>HTTP</em>和 <em>TCP</em> 了，这两个协议也是服务交互中使用最多的协议。先来看 TCP 协议，TCP 协议中的<strong>三次握手建连与四次挥手断连</strong>是一个高频考点，后面会详细介绍。</li><li>TCP 的报文状态标志与链接状态，在排查网络问题时非常重要，必须要明白<strong>协议状态</strong>，才方便抓包分析。</li><li>另一个知识点是 <em><strong>Nagel</strong></em>算法和 <em><strong>ACK</strong></em> 延迟，需要了解产生的背景，是要解决小包问题，提高数据载荷比。知道对于延迟比较敏感且发送数据频率较低的场景可以关闭 Nagel 算法。</li><li>关于 TCP 的 Keepalive，是一种长时间没有数据发送的场景下，TCP 保持链接可用的机制，需要知道 TCP Keepalive 的开启和设置方式。</li><li>最后一点，需要明白 TCP 是如何通过滑动窗口机制来实现流量控制的。</li></ul><p>再来看 HTTP 协议部分。</p><ul><li><p>需要掌握 HTTP 协议的规范，知道协议中的 Method、Header、Cookies，需要了解常见状态码的含义，例如 404、503、302 等。</p></li><li><p>另外还有 HTTPS 的交互流程。</p></li><li><p>HTTP2 目前还比较新，对 HTTP2 协议的了解可以在一定程度上体现对新技术的关注程度。可以关注：HTTP2 多路复用、Stream 流式交互、流量控制、服务端推送、头部压缩等新特性</p></li></ul><p>除了 HTTP 和 TCP 外，UDP 也是一个比较常见的传输层协议，UDP 的特点是非链接、非可靠传输，但是效率非常高。</p><p>最后可以对 QUIC 协议进行一些了解，QUIC 已经被标准化为 HTTP3 协议。QUIC 是基于 UDP 协议，但 QUIC 提供了类似 TCP 的可靠性保证和流量控制。QUIC 可以有效避免 HTTP2 协议的前序包阻塞问题，能实现零 RTT 建连，提供 FEC 前向纠错能力。</p><hr><h3 id="详解-TCP-协议特点"><a class="header-anchor" href="#详解-TCP-协议特点"></a>详解 TCP 协议特点</h3><p>TCP 是传输层协议，对应 <em>OSI</em>网络模型的第四层传输层，特点如下。</p><ul><li><p>TCP 协议是基于链接的，也就是传输数据前需要先建立好链接，然后再进行传输。</p></li><li><p>TCP 链接一旦建立，就可以在链接上进行双向的通信。</p></li><li><p>TCP 的传输是基于字节流而不是报文，将数据按字节大小进行编号，接收端通过 ACK 来确认收到的数据编号，通过这种机制，TCP 协议能够保证接收数据的有序性和完整性，因此 TCP 能够提供可靠性传输。</p></li><li><p>TCP 还能提供流量控制能力，通过滑动窗口来控制数据的发送速率。滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力，在 TCP 的 Header 中动态调整窗口大小，通过 ACK 应答包通知给发送端，发送端根据窗口大小调整发送的的速度。</p></li><li><p>仅仅有了流量控制能力还不够，TCP 协议还考虑到了网络问题可能会导致大量重传，进而导致网络情况进一步恶化，因此 TCP 协议还提供拥塞控制。TCP 处理拥塞控制主要用到了慢启动、拥塞避免、拥塞发生、快速恢复四个算法，感兴趣的同学可以进一步了解。</p></li></ul><p>除了 TCP 协议的特点，还可以进一步了解 TCP 协议的报文状态、滑动窗口的工作流程、 Keepalive 的参数设置和 Nagel 算法的规则等一些细节。</p><p>另外还有典型的 TCP 协议问题，例如特定场景下 Nagel 和 ACK 延迟机制配合使用可能会出现 delay40ms 超时后才回复 ACK 包的问题。</p><hr><h3 id="详解三次握手建连"><a class="header-anchor" href="#详解三次握手建连"></a>详解三次握手建连</h3><p>接下来看 TCP 建连的三次握手。TCP 是基于链接的，所以在传输数据前需要先建立链接，TCP 在传输上是双工传输，不区分 Client 端与 Server 端，为了便于理解，我们把主动发起建连请求的一端称作 Client 端，把被动建立链接的一端称作 Server 端。</p><p>如下图，建连的时序是从上到下，左右两边的绿色字分别代表 Client 端与 Server 端当时的链接状态。</p><p><img src="https://img.jinguo.tech/blog/20210506225316.png?imageslim" alt="握手建连"></p><p>首先建立链接前需要 Server 端先监听端口，因此 Server 端建立链接前的初始状态就是 LISTEN 状态，这时 Client 端准备建立链接，先发送一个 SYN 同步包，发送完同步包后，Client 端的链接状态变成了 SYN_SENT 状态。Server 端收到 SYN 后，同意建立链接，会向 Client 端回复一个 ACK。</p><p>由于 TCP 是双工传输，Server 端也会同时向 Client 端发送一个 SYN，申请 Server 向 Client 方向建立链接。发送完 ACK 和 SYN 后，Server 端的链接状态就变成了 SYN_RCVD。</p><p>Client 收到 Server 的 ACK 后，Client 端的链接状态就变成了 ESTABLISHED 状态，同时，Client 向 Server 端发送 ACK，回复 Server 端的 SYN 请求。</p><p>Server 端收到 Client 端的 ACK 后，Server 端的链接状态也就变成了的 ESTABLISHED 状态，此时建连完成，双方随时可以进行数据传输。</p><p>在面试时需要明白三次握手是为了建立双向的链接，需要记住 Client 端和 Server 端的链接状态变化。另外回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。</p><hr><h3 id="详解四次挥手断连"><a class="header-anchor" href="#详解四次挥手断连"></a>详解四次挥手断连</h3><p>再来看看 TCP 的断连，如下图所示。</p><p><img src="https://img.jinguo.tech/blog/20210506225406.png?imageslim" alt="TCP"></p><p>TCP 链接的关闭，通信双方都可以先发起，我们暂且把先发起的一方看作 Client，从图中看出，通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态，然后 Client 先主动发起了关闭链接请求，Client 向 Server 发送了一个 FIN 包，表示 Client 端已经没有数据要发送了，然后 Client 进入了 FIN_WAIT_1 状态。</p><p>Server 端收到 FIN 后，返回 ACK，然后进入 CLOSE_WAIT 状态。此时 Server 属于半关闭状态，因为此时 Client 向 Server 方向已经不会发送数据了，可是 Server 向 Client 端可能还有数据要发送。</p><p>当 Server 端数据发送完毕后，Server 端会向 Client 端发送 FIN，表示 Server 端也没有数据要发送了，此时 Server 进入 LAST_ACK 状态，就等待 Client 的应答就可以关闭链接了。</p><p>Client 端收到 Server 端的 FIN 后，回复 ACK，然后进入 TIME_WAIT 状态。TIME_WAIT 状态下需要等待 2 倍的最大报文段生存时间，来保证链接的可靠关闭，之后才会进入 CLOSED 关闭状态。而 Server 端收到 ACK 后直接就进入 CLOSED 状态。</p><p>这里面试官可能会问为什么需要等待 2 倍最大报文段生存时间之后再关闭链接，原因有两个：</p><ol><li>保证 TCP 协议的全双工连接能够可靠关闭；</li><li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li></ol><p>从这个交互流程可以看出，无论是建连还是断链，都是需要在两个方向上进行，只不过建连时，Server 端的 SYN 和 ACK 合并为一次发送，而断链时，两个方向上数据发送停止的时间可能不同，所以不能合并发送 FIN 和 ACK。这就是建连三次握手而断链需要四次的原因。</p><p>另外回答断链的问题时，可以提到实际应用中有可能遇到大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态的问题。一般开启 <em>tcp_tw_reuse</em>和 <em>tcp_tw_recycle</em>能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 32个Java常用面试点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32个java常用知识点</title>
      <link href="/2021/05/04/32%E4%B8%AAjava%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2021/05/04/32%E4%B8%AAjava%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="/cookbook/index.html">Java面试</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/2021/04/27/%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/27/%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-dubbo在debug（调试）模式下，启动很慢的问题解决方法"><a class="header-anchor" href="#idea-dubbo在debug（调试）模式下，启动很慢的问题解决方法"></a>idea dubbo在debug（调试）模式下，启动很慢的问题解决方法</h1><p>idea 在debug模式下启动dubbo的时候，dubbo注册的时候会非常慢，但是在非调试模式下，就正常！后来在debug模式下，将所有断点都清除后，速度立马就上来了！所以在debug模式下启动，需要将断点都清除再启动！</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive实操</title>
      <link href="/2020/09/04/Hive%20%E5%AE%9E%E6%93%8D/"/>
      <url>/2020/09/04/Hive%20%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive-实操"><a class="header-anchor" href="#Hive-实操"></a>Hive 实操</h1><h2 id="一、Database"><a class="header-anchor" href="#一、Database"></a>一、Database</h2><h3 id="1-1-查看数据库列表"><a class="header-anchor" href="#1-1-查看数据库列表"></a>1.1 查看数据库列表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902204156290.png?imageslim" alt="image-20200902204156290"></p><h3 id="1-2-查看数据库列表"><a class="header-anchor" href="#1-2-查看数据库列表"></a>1.2 查看数据库列表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> database_name;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902204350677.png?imageslim" alt="image-20200902204350677"></p><h3 id="1-3-新建数据库"><a class="header-anchor" href="#1-3-新建数据库"></a>1.3 新建数据库</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>) [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name   <span class="comment">--DATABASE|SCHEMA 是等价的</span></span><br><span class="line">  [<span class="keyword">COMMENT</span> database_comment] <span class="comment">--数据库注释</span></span><br><span class="line">  [LOCATION hdfs_path] <span class="comment">--存储在 HDFS 上的位置</span></span><br><span class="line">  [<span class="keyword">WITH</span> DBPROPERTIES (property_name=property_value, ...)]; <span class="comment">--指定额外属性</span></span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> hive_test</span><br><span class="line">  <span class="keyword">COMMENT</span> <span class="string">'hive database for test'</span></span><br><span class="line">  <span class="keyword">WITH</span> DBPROPERTIES (<span class="string">'create'</span>=<span class="string">'jinguo'</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200902203705654.png?imageslim" alt="image-20200902203705654"></p></li></ul><h3 id="1-4-查看数据库信息"><a class="header-anchor" href="#1-4-查看数据库信息"></a>1.4 查看数据库信息</h3><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC DATABASE [EXTENDED] db_name; <span class="comment">--EXTENDED 表示是否显示额外属性</span></span><br></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC DATABASE  EXTENDED hive_test;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903100904811.png?imageslim" alt="image-20200903100904811"></p><h3 id="1-5-删除数据库"><a class="header-anchor" href="#1-5-删除数据库"></a>1.5 删除数据库</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> (<span class="keyword">DATABASE</span>|<span class="keyword">SCHEMA</span>) [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] database_name [RESTRICT|<span class="keyword">CASCADE</span>];</span><br></pre></td></tr></table></figure><p><em>默认行为是 <strong>RESTRICT</strong>，如果数据库中存在表则删除失败。要想删除库及其中的表，可以使用 <strong>CASCADE</strong> 级联删除。</em></p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hive_test;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903111952592.png?imageslim" alt="image-20200903111952592"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">while</span> processing statement: FAILED: Execution Error, <span class="keyword">return</span> code <span class="number">1</span> from org<span class="variable">.apache</span><span class="variable">.hadoop</span><span class="variable">.hive</span><span class="variable">.ql</span><span class="variable">.exec</span><span class="variable">.DDLTask</span>. InvalidOperationException(message:Database hive_test is <span class="keyword">not</span> empty. One <span class="keyword">or</span> more tables exist.)</span><br></pre></td></tr></table></figure><p><em>当数据库中存在表的时候，删除时需要用<strong>CASCADE</strong></em>关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> hive_test <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903112539723.png?imageslim" alt="image-20200903112539723"></p><h2 id="二、创建表"><a class="header-anchor" href="#二、创建表"></a>二、创建表</h2><h3 id="2-1-建表语法"><a class="header-anchor" href="#2-1-建表语法"></a>2.1 建表语法</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">TEMPORARY</span>] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name     <span class="comment">--表名</span></span><br><span class="line">  [(col_name data_type [<span class="keyword">COMMENT</span> col_comment],</span><br><span class="line">    ... [constraint_specification])]  <span class="comment">--列名 列数据类型</span></span><br><span class="line">  [<span class="keyword">COMMENT</span> table_comment]   <span class="comment">--表描述</span></span><br><span class="line">  [PARTITIONED <span class="keyword">BY</span> (col_name data_type [<span class="keyword">COMMENT</span> col_comment], ...)]  <span class="comment">--分区表分区规则</span></span><br><span class="line">  [</span><br><span class="line">    CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...) </span><br><span class="line">   [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS</span><br><span class="line">  ]  <span class="comment">--分桶表分桶规则</span></span><br><span class="line">  [SKEWED <span class="keyword">BY</span> (col_name, col_name, ...) <span class="keyword">ON</span> ((col_value, col_value, ...), (col_value, col_value, ...), ...)  </span><br><span class="line">   [<span class="keyword">STORED</span> <span class="keyword">AS</span> DIRECTORIES] </span><br><span class="line">  ]  <span class="comment">--指定倾斜列和值</span></span><br><span class="line">  [</span><br><span class="line">   [<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> row_format]    </span><br><span class="line">   [<span class="keyword">STORED</span> <span class="keyword">AS</span> file_format]</span><br><span class="line">     | <span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'storage.handler.class.name'</span> [<span class="keyword">WITH</span> SERDEPROPERTIES (...)]  </span><br><span class="line">  ]  <span class="comment">-- 指定行分隔符、存储文件格式或采用自定义存储格式</span></span><br><span class="line">  [LOCATION hdfs_path]  <span class="comment">-- 指定表的存储位置</span></span><br><span class="line">  [TBLPROPERTIES (property_name=property_value, ...)]  <span class="comment">--指定表的属性</span></span><br><span class="line">  [<span class="keyword">AS</span> select_statement];   <span class="comment">--从查询结果创建表</span></span><br></pre></td></tr></table></figure><h3 id="2-2-创建内部表"><a class="header-anchor" href="#2-2-创建内部表"></a>2.2 创建内部表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903180953529.png?imageslim" alt="image-20200903180953529"></p><h3 id="2-3-创建外部表"><a class="header-anchor" href="#2-3-创建外部表"></a>2.3 创建外部表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_external(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_external'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903181743473.png?imageslim" alt="image-20200903181743473"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903184628794.png?imageslim" alt="image-20200903184628794"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903190348379.png?imageslim" alt="image-20200903190348379"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903185141700.png?imageslim" alt="image-20200903185141700"></p><h3 id="2-4-内部表和外部表区别"><a class="header-anchor" href="#2-4-内部表和外部表区别"></a>2.4 内部表和外部表区别</h3><p><strong>创建表时</strong></p><ul><li>创建内部表：会将数据移动到数据仓库指向的路径；</li><li>创建外部表：仅记录数据所在的路径， 不对数据的位置做任何改变。</li></ul><p><strong>删除表时</strong></p><ul><li>内部表的元数据和数据会被一起删除</li><li>外部表只删除元数据，不删除数据。外部表相对来说更加安全，数据组织更加灵活，方便共享源数据。</li></ul><p><strong>总结：</strong></p><ol><li><p>未被external修饰的是内部表【<em>managed table</em>】，被external修饰的为外部表【<em>external table</em>】。</p></li><li><p>内部表数据由Hive自身管理，外部表数据由HDFS管理。</p></li><li><p>内部表数据存储在<em>hive.metastore.warehouse.dir</em>【默认:<em>/user/hive/warehouse</em>】，外部表数据存储位置由用户自己决定。如 <em>location ‘/hive/emp_external’</em></p><p><img src="https://img.jinguo.tech/typora/image-20200904222601364.png?imageslim" alt="image-20200904222601364"></p><p><img src="https://img.jinguo.tech/typora/image-20200904222820733.png?imageslim" alt="image-20200904222820733"></p></li><li><p>删除内部表会直接删除元数据【<em>metadata</em>】及<strong>存储数据</strong>，删除外部表仅仅删除元数据，<em>HDFS</em>上的文件不会被删除。</p></li><li><p>对内部表的修改会直接同步到元数据，而对外部表的表结构和分区进行修改，则需要修改【<em>MSCK REPAIR TABLE table_name</em>】。</p></li></ol><h3 id="2-5-创建分区表"><a class="header-anchor" href="#2-5-创建分区表"></a>2.5 创建分区表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_partition(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">   )</span><br><span class="line">   PARTITIONED <span class="keyword">BY</span> (deptno <span class="built_in">INT</span>)  <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_partition'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903191518107.png?imageslim" alt="image-20200903191518107"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903193011185.png?imageslim" alt="image-20200903193011185"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192022966.png?imageslim" alt="image-20200903192022966"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903191648232.png?imageslim" alt="image-20200903191648232"></p><h3 id="2-6-分桶表"><a class="header-anchor" href="#2-6-分桶表"></a>2.6 分桶表</h3><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   deptno <span class="built_in">INT</span>)</span><br><span class="line">   CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_bucket'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903192305213.png?imageslim" alt="image-20200903192305213"></p><p><em>用<strong>DESC TABLENAME</strong>查看表格信息</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192644607.png?imageslim" alt="image-20200903192644607"></p><p><em>用<strong>DESC FORMATTED TABLENAME</strong>命令可以查看表的详细信息</em><img src="https://img.jinguo.tech/typora/image-20200903192505630.png?imageslim" alt="image-20200903192505630"></p><p><em>通过<strong>hdfs dfs -ls</strong>命令可以看到Location的外部表已经存在</em></p><p><img src="https://img.jinguo.tech/typora/image-20200903192829644.png?imageslim" alt="image-20200903192829644"></p><h3 id="2-7-倾斜表"><a class="header-anchor" href="#2-7-倾斜表"></a>2.7 倾斜表</h3><p><em>通过指定一个或者多个列经常出现的值（严重偏斜），<strong>Hive</strong>会自动将涉及到这些值的数据拆分为单独的文件。在查询时，如果涉及到倾斜值，它就直接从独立文件中获取数据，而不是扫描所有文件，这使得性能得到提升</em></p><ul><li>示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_skewed(</span><br><span class="line">   empno <span class="built_in">INT</span>,</span><br><span class="line">   ename <span class="keyword">STRING</span>,</span><br><span class="line">   job <span class="keyword">STRING</span>,</span><br><span class="line">   mgr <span class="built_in">INT</span>,</span><br><span class="line">   hiredate <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">   sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">   )</span><br><span class="line">   SKEWED <span class="keyword">BY</span> (empno) <span class="keyword">ON</span> (<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>)  <span class="comment">--指定 empno 的倾斜值 66,88,100</span></span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">"\t"</span></span><br><span class="line">   LOCATION <span class="string">'/hive/emp_skewed'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/typora/image-20200903193642678.png?imageslim" alt="image-20200903193642678"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>storm心得-下</title>
      <link href="/2020/08/06/storm%E5%BF%83%E5%BE%97-%E4%B8%8B/"/>
      <url>/2020/08/06/storm%E5%BF%83%E5%BE%97-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="dubbo的引入"><a class="header-anchor" href="#dubbo的引入"></a>dubbo的引入</h2><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进<br><img src="https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim" alt="mark"></p><ul><li><p>单一应用架构<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。</p></li><li><p>垂直应用架构<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的  Web框架(MVC)  是关键。</p></li><li><p>分布式服务架构<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。</p></li><li><p>流动计算架构<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率<br>此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。</p></li></ul><p>在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p><ol><li>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。<br>此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</li><li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。<br>这时，需要自动画出应用间的依赖关系图，以理清理关系。</li><li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？<br>为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。<br>其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</li></ol><h3 id="Dubbo的工作原理"><a class="header-anchor" href="#Dubbo的工作原理"></a>Dubbo的工作原理</h3><p><img src="https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim" alt="mark"></p><h3 id="节点角色说明："><a class="header-anchor" href="#节点角色说明："></a>节点角色说明：</h3><ul><li>Provider:  暴露服务的服务提供方。</li><li>Consumer:  调用远程服务的服务消费方。</li><li>Registry:  服务注册与发现的注册中心。</li><li>Monitor:  统计服务的调用次调和调用时间的监控中心。</li><li>Container:  服务运行容器。</li></ul><h3 id="调用关系说明："><a class="header-anchor" href="#调用关系说明："></a>调用关系说明：</h3><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="Dubbo-admin管理平台的安装"><a class="header-anchor" href="#Dubbo-admin管理平台的安装"></a>Dubbo-admin管理平台的安装</h2><h3 id="dubbo-admin-本地编译打包"><a class="header-anchor" href="#dubbo-admin-本地编译打包"></a>dubbo-admin 本地编译打包</h3><p><a href="https://github.com/alibaba/dubbo/releases" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/releases</a><br><a href="https://github.com/apache/incubator-dubbo/releases" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo/releases</a><br>解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址<br><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-ops</a></p><h3 id="克隆项目"><a class="header-anchor" href="#克隆项目"></a>克隆项目</h3><p>apache 下的dubbo-admin git仓库：<br><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-ops</a><br>先把这个项目用git克隆到本地中<br><img src="https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim" alt="mark"></p><h4 id="application-properties配置"><a class="header-anchor" href="#application-properties配置"></a>application.properties配置</h4><p><img src="https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim" alt="mark"></p><h4 id="application-test-properties配置"><a class="header-anchor" href="#application-test-properties配置"></a>application-test.properties配置</h4><p><img src="https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg" alt></p><h4 id="tomcat配置启动项"><a class="header-anchor" href="#tomcat配置启动项"></a>tomcat配置启动项</h4><p><img src="https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim" alt="mark"></p><h4 id="配置部署war包"><a class="header-anchor" href="#配置部署war包"></a>配置部署war包</h4><p><img src="https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim" alt="mark"><br><img src="https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim" alt="mark"></p><h4 id="说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。"><a class="header-anchor" href="#说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。"></a>说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。</h4><h4 id="Production-Setup"><a class="header-anchor" href="#Production-Setup"></a>Production Setup</h4><ol><li>Clone source code on develop branch git clone <a href="https://github.com/apache/incubator-dubbo-admin.git" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-admin.git</a></li><li>Specify registry address in dubbo-admin-server/src/main/resources/application.properties</li><li>Build<br>mvn clean package<br><img src="https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim" alt="mark"></li><li>Start<br>mvn --projects dubbo-admin-server spring-boot:run<br><strong>启动Zookeeper集群</strong><br><img src="https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim" alt="mark"><br><img src="https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim" alt="mark"></li><li>Visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim" alt="mark"></li></ol><h3 id="报错1"><a class="header-anchor" href="#报错1"></a>报错1</h3><p><img src="https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim" alt="mark"></p><h3 id="解决办法"><a class="header-anchor" href="#解决办法"></a>解决办法</h3><p>如果SpringBoot在子模块，直接main启动子模块会报错。<br>解决办法就是在IDEA MAVEN Projects-&gt;dubbo-admin-server-&gt;Plugins-&gt;spring-boot-&gt;spring-boot:run-&gt;run maven build<br><img src="https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim" alt="mark"></p><h3 id="报错2"><a class="header-anchor" href="#报错2"></a>报错2</h3><p><img src="https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim" alt="mark"></p><h3 id="解决办法-v2"><a class="header-anchor" href="#解决办法-v2"></a>解决办法</h3><p>taskkill /pid 8876 /f</p><p><img src="https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim" alt="mark"></p><h2 id="zookeeper与dubbo关系"><a class="header-anchor" href="#zookeeper与dubbo关系"></a>zookeeper与dubbo关系</h2><p>dubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；</p><h2 id="Netty在Dubbo中的应用"><a class="header-anchor" href="#Netty在Dubbo中的应用"></a>Netty在Dubbo中的应用</h2><p><strong>Dubbo 底层使用的是 Netty 作为网络通信</strong></p><ol><li>dubbo的Consumer消费者如何使用Netty</li></ol><h3 id="调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。"><a class="header-anchor" href="#调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。"></a>调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get remote service proxy</span></span><br><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br></pre></td></tr></table></figure><h3 id="调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存"><a class="header-anchor" href="#调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存"></a>调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">getSharedClient</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">String key=url.getAddress();</span><br><span class="line">ReferenceCountExchangeClient client=referenceClientMap.get(key);</span><br><span class="line"><span class="keyword">if</span>(client!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!=client.isClosed())&#123;</span><br><span class="line">client.incrementAndGetCount();</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">referenceClientMap.remove(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(key.intern())&#123;</span><br><span class="line"><span class="comment">//这个initClient()方法是创建Netty的client的</span></span><br><span class="line">ExchangeClient exchangeClient=initClient(url);</span><br><span class="line">client=<span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient,ghostClientMap);</span><br><span class="line">referenceClientMap.put(key,client);</span><br><span class="line">ghostClientMap.remove(key);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。"><a class="header-anchor" href="#最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。"></a>最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractClient</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    doOpen();</span><br><span class="line">    connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doOpent-方法用来创建-Netty-的-bootstrap-："><a class="header-anchor" href="#doOpent-方法用来创建-Netty-的-bootstrap-："></a>doOpent 方法用来创建 Netty 的 bootstrap ：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ClientBootstrap(channelFactory);</span><br><span class="line">    bootstrap.setOption(<span class="string">"keepAlive"</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">"connectTimeoutMillis"</span>, getTimeout());</span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="connect-方法用来连接提供者："><a class="header-anchor" href="#connect-方法用来连接提供者："></a>connect 方法用来连接提供者：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 </span></span><br><span class="line">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class="line">    <span class="keyword">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class="line">        Channel newChannel = future.getChannel();</span><br><span class="line">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。"><a class="header-anchor" href="#main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。"></a>main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line"><span class="comment">//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  </span></span><br><span class="line">    channel.send(req);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dubbo-的-Provider-提供者如何使用-Netty"><a class="header-anchor" href="#dubbo-的-Provider-提供者如何使用-Netty"></a>dubbo 的 Provider 提供者如何使用 Netty</h2><p>Provider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。</p><h3 id="NettyServer-对象的构造方法同样是-doOpen-方法。"><a class="header-anchor" href="#NettyServer-对象的构造方法同样是-doOpen-方法。"></a>NettyServer 对象的构造方法同样是 doOpen 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line"><span class="comment">//boss 线程，worker 线程，和 ServerBootstrap</span></span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"><span class="comment">//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。</span></span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Netty在Dubbo中的应用总结"><a class="header-anchor" href="#Netty在Dubbo中的应用总结"></a>Netty在Dubbo中的应用总结</h3><p>dubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。</p><h2 id="Apache-Storm分布式消息系统"><a class="header-anchor" href="#Apache-Storm分布式消息系统"></a>Apache Storm分布式消息系统</h2><p>Apache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。</p><h3 id="什么是分布式消息系统？"><a class="header-anchor" href="#什么是分布式消息系统？"></a>什么是分布式消息系统？</h3><p>分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。<br>大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。<br>一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。<br>需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。</p><p><img src="https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim" alt="mark"></p><p>下表描述了一些流行的高吞吐量消息传递系统 -<br><img src="https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim" alt="mark"><br>Thrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。<br>Apache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。<br>Storm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。</p><h2 id="Storm工作原理"><a class="header-anchor" href="#Storm工作原理"></a>Storm工作原理</h2><p><img src="https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim" alt="mark"></p><h3 id="Storm与传统关系型数据库"><a class="header-anchor" href="#Storm与传统关系型数据库"></a>Storm与传统关系型数据库</h3><p>传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存<br>传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据<br>关系型数据库重视事务，并发控制，相对来说Storm比较简陋<br>Storm与Hadoop，Spark等是流行的大数据方案<br>与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑</p><ol><li><p>topology<br>Storm集群中有两种组件节点，一种是<strong>控制节点</strong>(Nimbus节点)，另一种是<strong>工作节点</strong>(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。<br>和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去<br>数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。<br><img src="https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim" alt="mark"></p></li><li><p>zookeeper集群<br>storm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。<br>部署zookeeper有些需要注意的地方：<br>①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控<br>②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用</p></li><li><p>Component<br>Storm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口<br>全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。<br><img src="https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim" alt="mark"></p></li><li><p>Spout<br>Spout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①open()方法 – 初始化方法<br>close() – 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行<br>②ack(Object msgId) – 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放<br>③fail(Object msgId) – 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放<br>④nextTuple() – 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout</p></li><li><p>Bolt<br>Bolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成<br>prepare方法 – 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境<br>declareOutputFields方法 – 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似<br>cleanup方法 – 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。<br>execute方法 – 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。<br>Storm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException<br>通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple)</p></li><li><p>Topology运行方式<br>在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式</p></li></ol><h3 id="本地运行的提交方式"><a class="header-anchor" href="#本地运行的提交方式"></a>本地运行的提交方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster(); </span><br><span class="line">cluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); </span><br><span class="line">Thread.sleep(<span class="number">2000</span>); </span><br><span class="line">cluster.shutdown();</span><br></pre></td></tr></table></figure><h3 id="分布式提交方式"><a class="header-anchor" href="#分布式提交方式"></a>分布式提交方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology());</span><br></pre></td></tr></table></figure><p>需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。</p><h3 id="运行的命令如下"><a class="header-anchor" href="#运行的命令如下"></a>运行的命令如下###</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar StormTopology.jar mainclass [args]</span><br></pre></td></tr></table></figure><h2 id="storm守护进程的命令"><a class="header-anchor" href="#storm守护进程的命令"></a>storm守护进程的命令</h2><p>Nimbus: storm nimbus 启动nimbus守护进程<br>Supervisor: storm supervisor 启动supervisor守护迚程<br>UI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。<br>DRPC: storm drpc 启动DRPC的守护进程</p><h2 id="storm管理命令"><a class="header-anchor" href="#storm管理命令"></a>storm管理命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAR：storm jar topology_jar topology_class [arguments...]</span><br></pre></td></tr></table></figure><p>jar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL：storm kill topology_name [-w wait_time]</span><br></pre></td></tr></table></figure><p>杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deactivate：storm deactivate topology_name</span><br></pre></td></tr></table></figure><p>停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activate：storm activate topology_name</span><br></pre></td></tr></table></figure><p>启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]...</span><br></pre></td></tr></table></figure><p>rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8</span><br></pre></td></tr></table></figure><p>还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等</p><h2 id="Storm与Hadoop的对比"><a class="header-anchor" href="#Storm与Hadoop的对比"></a>Storm与Hadoop的对比</h2><p><img src="https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim" alt="mark"></p><h2 id="DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下："><a class="header-anchor" href="#DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下："></a>DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：</h2><p>引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。</p><ol><li>接收到一个RPC调用请求；</li><li>发送请求到Storm上的<strong>拓扑</strong>；</li><li>从Storm上接收计算结果；</li><li>将计算结果返回给客户端。</li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="maven更新镜像源"><a class="header-anchor" href="#maven更新镜像源"></a>maven更新镜像源</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">         <span class="comment">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="RPC和MQ对比及其适用-不适用场合"><a class="header-anchor" href="#RPC和MQ对比及其适用-不适用场合"></a>RPC和MQ对比及其适用/不适用场合</h2><h3 id="系统结构"><a class="header-anchor" href="#系统结构"></a>系统结构</h3><p><strong>RPC系统结构：</strong><br>Cosume &lt;=&gt; Provider<br>Consumer调用的Provider提供的服务</p><p><strong>Message Queue系统结构：</strong><br>Sender &lt;=&gt; Queue &lt;=&gt; Reciver<br>Sender发送消息给Queue；Receiver从Queue拿到消息来处理。</p><h3 id="功能的特点"><a class="header-anchor" href="#功能的特点"></a>功能的特点</h3><p>在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。</p><h3 id="消息的特点"><a class="header-anchor" href="#消息的特点"></a>消息的特点</h3><ul><li>Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。</li><li>Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响</li><li>Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。</li><li>所以对于有同步返回需求，用Message Queue则变得麻烦了。</li></ul><h3 id="PRC的特点"><a class="header-anchor" href="#PRC的特点"></a>PRC的特点</h3><ul><li>同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。</li><li>RPC也可以是异步调用。</li><li>由于等待结果，Consumer（Client）会有线程消耗。</li><li>如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。</li></ul><h3 id="适用场合说明"><a class="header-anchor" href="#适用场合说明"></a>适用场合说明</h3><ul><li>希望同步得到结果的场合，RPC合适。</li><li>希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。</li><li>不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。</li><li>随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。</li><li>这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。</li></ul><h3 id="不适用场合说明"><a class="header-anchor" href="#不适用场合说明"></a>不适用场合说明</h3><p>RPC同步调用使用Message Queue来传输调用信息。<br>发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>storm(心得)</title>
      <link href="/2020/01/16/storm%E5%BF%83%E5%BE%97-%E4%B8%8A/"/>
      <url>/2020/01/16/storm%E5%BF%83%E5%BE%97-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Storm入门"><a class="header-anchor" href="#Storm入门"></a>Storm入门</h1><p>Storm是一个<strong>分布式的</strong>，可靠的，容错的<strong>数据流处理系统</strong>。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。<br>Storm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等<br>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的<br>Storm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。<br>一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。<br>注：Storm中的核心术语<br><strong>spout</strong>龙卷，读取原始数据为bolt提供数据<br><strong>bolt</strong> 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果<br><strong>nimbus</strong> 雨云，主节点的守护进程，负责为工作节点分发任务<br><strong>topology</strong> 拓扑结构，Storm的一个任务单元<br><strong>define field(s)</strong> 定义域，由spout或bolt提供，被bolt接收</p><h2 id="Storm应用案例"><a class="header-anchor" href="#Storm应用案例"></a>Storm应用案例</h2><ul><li>数据处理流，Storm不需要中间队列</li><li>连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。</li><li><strong>分布式远程过程调用</strong></li><li>频繁的CPU密集型操作<strong>并行化</strong>。</li></ul><h2 id="Storm组件"><a class="header-anchor" href="#Storm组件"></a>Storm组件</h2><p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。<br>主节点运行着一个叫做<strong>Nimbus</strong>的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。<br><strong>Supervisor</strong>守护进程作为拓扑的一部分运行在工作节点上。<br>一个Storm<strong>拓扑结构</strong>在不同的机器上运行着众多的工作节点。<br>因为Storm在<strong>Zookeeper</strong>或本地磁盘上<strong>维持所有的集群状态</strong>，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康<br>在系统底层，Storm使用了<strong>zeromq</strong>，这是一种先进的，可嵌入的<strong>网络通讯库</strong>，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets</p><h3 id="注：zeromq的特性"><a class="header-anchor" href="#注：zeromq的特性"></a>注：zeromq的特性</h3><ul><li>一个并发架构的Socket库</li><li>对于集群产品和超级计算，比TCP要快</li><li>可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信</li><li>异步I / O的可扩展的多核消息传递应用程序</li><li>利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接<br>注：最新的Storm已不再必须依赖<strong>ZeroMQ</strong>，各种依赖的库和软件也已经有更新的版本。<br>最近版本的Storm支持使用<strong>netty</strong>做消息队列。<br>Netty提供<strong>异步的、事件驱动</strong>的网络应用程序框架和工具，用以快速开发<strong>高性能、高可靠性的</strong>网络服务器和客户端程序。正好是 storm所需要的。</li></ul><h2 id="Storm的特性"><a class="header-anchor" href="#Storm的特性"></a>Storm的特性</h2><ul><li>简化编程：使用Storm，实现实时处理的复杂性被大大降低了</li><li>开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发</li><li>容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。</li><li>可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。</li><li>可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。</li><li>快速：速度是驱动Storm设计的一个关键因素</li><li>事务性：可以为几乎任何计算得到恰好一次消息语义</li></ul><h2 id="安装Storm集群"><a class="header-anchor" href="#安装Storm集群"></a>安装Storm集群</h2><p>要手工安装Storm，需要先安装以下软件</p><ol><li>Zookeeper集群</li><li>Java</li><li>Python</li><li>Unzip命令</li></ol><h3 id="注："><a class="header-anchor" href="#注："></a>注：</h3><p>Nimbus和管理进程将要依赖Java、Python和unzip命令</p><h3 id="前期准备"><a class="header-anchor" href="#前期准备"></a>前期准备</h3><ol><li>准备搭建3节点集群,准备3个虚拟机node1,node2,node3</li><li>配置好hosts映射文件和互相的ssh免密登录</li><li>配置好JDK<br>注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好</li></ol><h3 id="安装storm"><a class="header-anchor" href="#安装storm"></a>安装storm</h3><ol><li>准备好storm安装包</li><li>上传解压重命名为storm到/export/server路径下</li><li>修改配置文件 storm.yaml</li></ol><h3 id="运行"><a class="header-anchor" href="#运行"></a>运行</h3><ul><li>前台启动 (前台启动会占用窗口)<br>（1）在node1上启动 nimbus进程(主节点) 和 web UI<br>（2）在 node2 和 node3 上启动 supervisor(从节点)</li><li>后台启动</li></ul><h4 id="ssh脚本实现一键启动"><a class="header-anchor" href="#ssh脚本实现一键启动"></a>ssh脚本实现一键启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.#!/bin/bash</span><br><span class="line">source /etc/profile</span><br><span class="line">nohup /export/server/storm/bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "node1 nimbus is running"</span><br><span class="line">nohup /export/server/storm/bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">echo "node1 core is running"</span><br><span class="line">for host in node2 node3</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ssh $host "source /etc/profile;nohup /export/server/storm/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;"</span><br><span class="line">echo "$host Supervisor is running"</span><br><span class="line">&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="进入web页面查看集群"><a class="header-anchor" href="#进入web页面查看集群"></a>进入web页面查看集群</h3><h2 id="使用入门"><a class="header-anchor" href="#使用入门"></a>使用入门</h2><h3 id="MAVEN依赖"><a class="header-anchor" href="#MAVEN依赖"></a>MAVEN依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>storm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 目前&lt;scope&gt;可以使用5个值：</span></span><br><span class="line"><span class="comment">    * compile，缺省值，适用于所有阶段，会随着项目一起发布。</span></span><br><span class="line"><span class="comment">    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。</span></span><br><span class="line"><span class="comment">    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。</span></span><br><span class="line"><span class="comment">    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</span></span><br><span class="line"><span class="comment">    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理"><a class="header-anchor" href="#编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理"></a>编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Version: </span></span><br><span class="line"><span class="comment"> * Description: 读取外部文件,把一行一行的数据发送给下游的bolt</span></span><br><span class="line"><span class="comment"> *              类似于hadoop mapreduce的inputformat</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="comment">//BaseBasicSpout</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFileSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector spoutOutputCollector;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader bufferedReader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法, 类似于这个类的构造器, 只被运行一次</span></span><br><span class="line"><span class="comment">     * spout组件读取原始数据为bolt提供数据</span></span><br><span class="line"><span class="comment">     * 一般用来打开数据链接, 打开网络连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象, 一般不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//本地模式</span></span><br><span class="line">            <span class="comment">//this.bufferedReader = new BufferedReader(new FileReader(new File("D:\\wordcount.txt")));</span></span><br><span class="line">            <span class="comment">//集群模式</span></span><br><span class="line">            <span class="keyword">this</span>.bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"//root//stormdata//wordcount.txt"</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.spoutOutputCollector = spoutOutputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个tuple, tuple是数据传送的基本单位</span></span><br><span class="line"><span class="comment">     * 不断地往下一个组件发送tuple消息</span></span><br><span class="line"><span class="comment">     * 这里面是该spout组件的核心逻辑</span></span><br><span class="line"><span class="comment">     * 如从kafka消息队列中拿到数据</span></span><br><span class="line"><span class="comment">     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//一行一行的读取文件内容,并且一行一行的发送</span></span><br><span class="line">            line = bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (line != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//将信息封装成tuple，发送消息给下一个组件</span></span><br><span class="line">        <span class="comment">//this.collector.emit(new Value(this.words[index]));</span></span><br><span class="line"></span><br><span class="line">                spoutOutputCollector.emit(Arrays.asList(line));</span><br><span class="line"></span><br><span class="line"><span class="comment">//每发送一个消息，休眠500ms</span></span><br><span class="line">       <span class="comment">// Thread.sleep(500);</span></span><br><span class="line"><span class="comment">// Utils.sleep(500);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字段声明发出的数据是什么,tuple中的数据的字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"line"</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Bolt类对出入的内容进行单词切分"><a class="header-anchor" href="#编写Bolt类对出入的内容进行单词切分"></a>编写Bolt类对出入的内容进行单词切分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Description: 输入一行一行的数据</span></span><br><span class="line"><span class="comment"> *              对一行数据进行切割</span></span><br><span class="line"><span class="comment"> *              输出单词及单词出现的次数</span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment">//BaseBasicBolt</span></span><br><span class="line"><span class="comment">public class SplitBolt extends BaseRichBolt &#123;</span></span><br><span class="line"><span class="comment">    private OutputCollector outputCollector;</span></span><br><span class="line"><span class="comment">    /**</span></span><br><span class="line"><span class="comment">     * 初始化方法,只被运行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector 数据收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputCollector = outputCollector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行业务逻辑的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tuple 获取的上游数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上游句子(字段:"line"),从tuple中读取数据</span></span><br><span class="line"><span class="comment">//获取nextTuple()方法emit()过来的数据</span></span><br><span class="line">        String line = tuple.getStringByField(<span class="string">"line"</span>);</span><br><span class="line">        <span class="comment">//对句子进行切割</span></span><br><span class="line">        String[] words = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//需要发送单词和单词出现的次数,总共两个字段</span></span><br><span class="line">            outputCollector.emit(Arrays.asList(word, <span class="string">"1"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明发送出去的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"num"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Bolt类对单词进行计数"><a class="header-anchor" href="#编写Bolt类对单词进行计数"></a>编写Bolt类对单词进行计数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce</span></span><br><span class="line"><span class="comment">*              输入单词及单词出现的次数</span></span><br><span class="line"><span class="comment">*              输出打印在控制台</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个map用于储存单词及其数量</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; wordCountMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 配置文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topologyContext 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputCollector 数据收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取信息(单词, 数量)</span></span><br><span class="line">        String word = tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        String num = tuple.getStringByField(<span class="string">"num"</span>);</span><br><span class="line">        <span class="comment">//使用map进行记录</span></span><br><span class="line">        <span class="comment">//开始计数</span></span><br><span class="line">        <span class="keyword">if</span> (wordCountMap.containsKey(word))&#123;</span><br><span class="line">            <span class="comment">//如果map里已经有这个单词,就把数量进行累加</span></span><br><span class="line">            Integer integer = wordCountMap.get(word);</span><br><span class="line">            wordCountMap.put(word, integer + Integer.parseInt(num));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果map里已经没有这个单词,就把单词和数量放入map</span></span><br><span class="line">            wordCountMap.put(word, Integer.parseInt(num));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(wordCountMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于不向外发送数据,所以不用写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写启动类对程序进行整合"><a class="header-anchor" href="#编写启动类对程序进行整合"></a>编写启动类对程序进行整合</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Description: wordcount驱动类,用来提交任务</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WordCountTopology</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException</span> &#123;</span><br><span class="line">        <span class="comment">//通过TopologyBuilder 封装任务信息</span></span><br><span class="line">        TopologyBuilder topologyBuilder = <span class="keyword">new</span> TopologyBuilder();</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//设置spout获取数据</span></span><br><span class="line">        <span class="comment">//SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件</span></span><br><span class="line"><span class="comment">//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task</span></span><br><span class="line"></span><br><span class="line">        topologyBuilder.setSpout(<span class="string">"readfilesspout"</span>, <span class="keyword">new</span> ReadFileSpout(), <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置splitbolt 对句子进行切割</span></span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"splitbolt"</span>, <span class="keyword">new</span> SplitBolt(), <span class="number">4</span>).shuffleGrouping(<span class="string">"readfilesspout"</span>);</span><br><span class="line">        <span class="comment">//设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息</span></span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"wordcountbolt"</span>, <span class="keyword">new</span> WordCountBolt(), <span class="number">2</span>).shuffleGrouping(<span class="string">"splitbolt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备一个配置文件，配置一些topology在集群中运行的参数</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动2个worker!</span></span><br><span class="line">        config.setNumWorkers(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务提交有:本地模式 和 集群模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//本地模式</span></span><br><span class="line">        <span class="comment">//LocalCluster localCluster = new LocalCluster();</span></span><br><span class="line">        <span class="comment">//localCluster.submitTopology("wordcount", config, topologyBuilder.createTopology());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集群模式,参数:Topology名字, 配置文件, Topology对象</span></span><br><span class="line"><span class="comment">//用builder来创建topology</span></span><br><span class="line">        StormSubmitter.submitTopology(<span class="string">"wordcount2"</span>, config, topologyBuilder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行程序"><a class="header-anchor" href="#执行程序"></a>执行程序</h3><ol><li>选择本地模式运行<br>直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台</li><li>选择上传到集群进行执行<br>首先通过maven的package命名将程序打好jar包</li></ol><h4 id="注：-v2"><a class="header-anchor" href="#注：-v2"></a>注：</h4><p>在storm-core的依赖中加入:<scope>provided</scope><br>在上传到node2或node3上, 在指定路径下要确保存在日志文件</p><h1 id="Storm-Distributed-RPC（DRPC）"><a class="header-anchor" href="#Storm-Distributed-RPC（DRPC）"></a>Storm Distributed RPC（DRPC）</h1><h2 id="分布式远程过程调用"><a class="header-anchor" href="#分布式远程过程调用"></a>分布式远程过程调用</h2><ul><li>DRPC的主要作用就是利用Storm的<strong>实时计算</strong>能力来<strong>并行化</strong>CPU intensive的计算。</li><li>对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。</li><li>DRPC其实不能算是storm本身的一个特性，它是通过组合storm的<strong>原语</strong>spout，bolt，topology而成的一种模式(pattern)。</li><li>DRPC通过一个&quot;DRPC server&quot;来进行<strong>协调均衡</strong>。（Storm整合了DRPC server的一个实现）。</li><li>DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。</li><li>对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。</li></ul><h3 id="客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果："><a class="header-anchor" href="#客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果："></a>客户端使用DRPC来获取以&quot;<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a>&quot;为参数的&quot;reach&quot;函数的返回结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"drpc-host"</span>, <span class="number">3772</span>);</span><br><span class="line">String result = client.execute(<span class="string">"reach"</span>, <span class="string">"http://baidu.com"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim" alt="mark"></p><h4 id="1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用"><a class="header-anchor" href="#1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用"></a>1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用</h4><h4 id="2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。"><a class="header-anchor" href="#2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。"></a>2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。</h4><h4 id="3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。"><a class="header-anchor" href="#3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。"></a>3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。</h4><h4 id="4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。"><a class="header-anchor" href="#4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。"></a>4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。</h4><h4 id="5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。"><a class="header-anchor" href="#5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。"></a>5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。</h4><h2 id="LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）"><a class="header-anchor" href="#LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）"></a>LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）</h2><h3 id="Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下"><a class="header-anchor" href="#Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下"></a>Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:</h3><ol><li>建立 spout</li><li>将结果返回到DRPC server</li><li>向bolts提供了在tuples集合上进行有限聚集的功能</li></ol><h4 id="创建LinearDRPCTopologyBuilder"><a class="header-anchor" href="#创建LinearDRPCTopologyBuilder"></a>创建LinearDRPCTopologyBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclaimBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">        String input = tuple.getString(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//简单的在元组的第二个字段的值后加了一个"!"</span></span><br><span class="line">        collector.emit(<span class="keyword">new</span> Values(tuple.getValue(<span class="number">0</span>), input + <span class="string">"!"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//我们将DRPC函数名告诉给topology（本例函数名为exclamation）。</span></span><br><span class="line">  <span class="comment">//单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。</span></span><br><span class="line">  <span class="comment">//第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。</span></span><br><span class="line">    LinearDRPCTopologyBuilder builder = <span class="keyword">new</span> LinearDRPCTopologyBuilder(<span class="string">"exclamation"</span>);</span><br><span class="line">    builder.addBolt(<span class="keyword">new</span> ExclaimBolt(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Local-mode-DRPC"><a class="header-anchor" href="#创建Local-mode-DRPC"></a>创建Local mode DRPC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。</span></span><br><span class="line">LocalDRPC drpc = <span class="keyword">new</span> LocalDRPC();</span><br><span class="line"><span class="comment">//然后创建LocalCluster来以本地模式来运行该topology。</span></span><br><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line"><span class="comment">//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。</span></span><br><span class="line"><span class="comment">//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象</span></span><br><span class="line"><span class="comment">//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;</span></span><br><span class="line">cluster.submitTopology(<span class="string">"drpc-demo"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class="line"><span class="comment">//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。</span></span><br><span class="line">System.out.println(<span class="string">"Results for 'hello':"</span> + drpc.execute(<span class="string">"exclamation"</span>, <span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">cluster.shutdown();</span><br><span class="line">drpc.shutdown();</span><br></pre></td></tr></table></figure><h4 id="Remote-mode-DRPC"><a class="header-anchor" href="#Remote-mode-DRPC"></a>Remote mode DRPC</h4><ol><li>建立DRPC servers</li><li>配置DRPC servers的位置</li><li>向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：</li></ol><h5 id="1-用storm脚本建立DRPC-server："><a class="header-anchor" href="#1-用storm脚本建立DRPC-server："></a>1. 用storm脚本建立DRPC server：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/storm drpc</span><br></pre></td></tr></table></figure><h5 id="2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置"><a class="header-anchor" href="#2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置"></a>2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drpc.servers:</span><br><span class="line">  - <span class="string">"drpc1.foo.com"</span></span><br><span class="line">  - <span class="string">"drpc2.foo.com"</span></span><br></pre></td></tr></table></figure><h5 id="3-通过StormSubmitter建立DRPC-topologies"><a class="header-anchor" href="#3-通过StormSubmitter建立DRPC-topologies"></a>3. 通过StormSubmitter建立DRPC topologies</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology(<span class="string">"exclamation-drpc"</span>, conf, builder.createRemoteTopology());</span><br></pre></td></tr></table></figure><h2 id="Storm-DRPC深入"><a class="header-anchor" href="#Storm-DRPC深入"></a>Storm DRPC深入</h2><p>分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的<strong>函数调用</strong>进行<strong>并行计算</strong>。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。<br>可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。</p><h3 id="注：-v3"><a class="header-anchor" href="#注：-v3"></a>注：</h3><p>Storm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）<br>Storm只负责数据的计算，不负责数据的存储<br>2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x</p><p><img src="https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim" alt="mark"><br><strong>其中:</strong><br>Nimbus：负责资源分配和任务调度。<br>Supervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>Worker：运行具体处理组件逻辑的进程。<br>Task：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。<br><img src="https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim" alt="mark"></p><h3 id="注：-v4"><a class="header-anchor" href="#注：-v4"></a>注：</h3><p><strong>DataSource</strong>: 数据源<br><strong>Spout</strong>：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。<br><strong>Bolt</strong>：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。<br><strong>Tuple</strong>：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.<br><strong>Stream</strong>：源源不断传递的tuple就组成了stream。<br><strong>Topology</strong>：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。</p><h3 id="分组策略"><a class="header-anchor" href="#分组策略"></a>分组策略</h3><ol><li>随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用</li><li>字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。</li><li>LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。</li></ol><h2 id="zookeeper安装和使用"><a class="header-anchor" href="#zookeeper安装和使用"></a>zookeeper安装和使用</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p><h3 id="zoo-sample-cfg文件配置"><a class="header-anchor" href="#zoo-sample-cfg文件配置"></a>zoo_sample.cfg文件配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">D:\\DevelopSoftware\\zookeeper\\zookeeper-3.4.14\\data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">D:\\DevelopSoftware\\zookeeper\\zookeeper-3.4.14\\log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure><h3 id="参数解释"><a class="header-anchor" href="#参数解释"></a>参数解释</h3><ul><li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li><li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒</li><li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒</li><li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li><li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li></ul><h3 id="异常"><a class="header-anchor" href="#异常"></a>异常</h3><p>Socket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information<br>**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg</p><p>zookeeper启动成功<br><img src="https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim" alt="mark"></p><h2 id="Zookeeper伪分布式集群搭建"><a class="header-anchor" href="#Zookeeper伪分布式集群搭建"></a>Zookeeper伪分布式集群搭建</h2><ol><li>将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。</li><li>创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。</li><li>在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.</li><li>修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改</li></ol><h3 id="zoo-cfg文件如下"><a class="header-anchor" href="#zoo-cfg文件如下"></a>zoo.cfg文件如下</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># 服务器与客户端之间交互的基本时间单元（ms）</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># zookeeper所能接受的客户端数量</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># 服务器与客户端之间请求和应答的时间间隔</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 保存zookeeper数据，日志路径</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">D:/DevelopSoftware/zookeeper/zk-data/8001/data</span></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">D:/DevelopSoftware/zookeeper/zk-data/8001/log</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 这是客户端链接的端口号</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口</span></span><br><span class="line"><span class="comment"># server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。</span></span><br><span class="line"><span class="comment"># 客户端与zookeeper相互交互的端口</span></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:8001:9001</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:8002:9002</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:8003:9003</span></span><br></pre></td></tr></table></figure><h3 id="报错"><a class="header-anchor" href="#报错"></a>报错</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> [myid:<span class="number">1</span>] - WARN  [WorkerSender[myid=<span class="number">1</span>]:QuorumCnxManager@<span class="number">584</span>] - Cannot open channel to <span class="number">3</span> at election address /<span class="number">127.0</span>.0.1:<span class="number">9003</span></span><br><span class="line">java.net.ConnectException: Connection refused: connect</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:<span class="number">85</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span><br><span class="line">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:<span class="number">172</span>)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:<span class="number">392</span>)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:<span class="number">589</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:<span class="number">558</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:<span class="number">534</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:<span class="number">454</span>)</span><br><span class="line">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:<span class="number">435</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><h3 id="报错解决办法"><a class="header-anchor" href="#报错解决办法"></a>报错解决办法</h3><p>产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty(笔记)</title>
      <link href="/2020/01/16/Netty%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/16/Netty%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="业界哪些流行的开源框架用Netty作为底层通信框架"><a class="header-anchor" href="#业界哪些流行的开源框架用Netty作为底层通信框架"></a>业界哪些流行的开源框架用Netty作为底层通信框架</h2><ul><li>Dubbo： 阿里开源的高性能RPC框架</li><li>RocketMQ： 阿里出品的高性能消息队列</li><li>Spark： 炙手可热的大数据处理引擎，底层使用Netty</li><li>Elasticsearch： 分布式多用户的全文搜索引擎</li><li>Apache Cassandra：开源分布式搜索数据库</li><li>Flink:分布式高性能高可用的流处理框架</li><li>Netty-SocketIO的java服务端实现</li><li>Spring5：使用Netty作为http协议框架</li><li>Play：简单易用的http服务器</li><li>Grpc:google开源的高性能rpc通信框架</li><li>Infinispan：针对缓存的高并发键值对数据存储</li><li>HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统</li><li>Vert.x轻量级高性能能JVM应用平台<br>-<br><a href="https://netty.io/wiki/adopters.html" target="_blank" rel="noopener">完整的参考列表</a></li></ul><h2 id="业界有哪些公司在使用Netty"><a class="header-anchor" href="#业界有哪些公司在使用Netty"></a>业界有哪些公司在使用Netty</h2><p><strong>在大型企业中</strong>有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram<br><br><strong>在初创企业中</strong>有：做http长连接的<strong>Firebase</strong>、支持各种各样消息推送通知的<strong>Urban Airship</strong><br><br><br> 当然，Netty也从这些项目中<strong>受益</strong>。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。</p><h2 id="Netty是什么"><a class="header-anchor" href="#Netty是什么"></a>Netty是什么</h2><ol><li><strong>异步</strong>和<strong>事件驱动</strong>的高性能网络通信框架。</li><li>**特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。</li><li>**目的:**用于快速开发高性能服务端和客户端</li><li>**封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易</li><li>自带编解码器解决拆包粘包问题，用户只关心业务逻辑</li><li>精心设计的reactor线程模型支持高并发海量连接</li><li>自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手</li><li>**架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离–业务和网络逻辑解耦，模块化和可复用性，可测试性。</li></ol><h2 id="Netty的特性总结"><a class="header-anchor" href="#Netty的特性总结"></a>Netty的特性总结</h2><p><img src="https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim" alt="mark"></p><h2 id="Socket-Netty"><a class="header-anchor" href="#Socket-Netty"></a>Socket &amp; Netty</h2><p><img src="https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim" alt="Socket &amp; Netty"></p><h2 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h2><p><img src="https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim" alt="mark"></p><ul><li>NioEventLoop -&gt;Thread</li><li>Channel -&gt;Socket  <br>NioSocketChannel implements Channel<br>Chennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind</li><li>ByteBuf -&gt;IO Bytes<br>readBytes()、writeBytes() and so on</li><li>Pipline -&gt;Logic Chain 逻辑链</li><li>ChannelHandler -&gt;Logic处理块</li></ul><h2 id="Netty核心组件"><a class="header-anchor" href="#Netty核心组件"></a>Netty核心组件</h2><h3 id="1-Channel-Socket"><a class="header-anchor" href="#1-Channel-Socket"></a>1. Channel-Socket</h3><p>Channel是通讯的载体，其基本构造是Socket<br>是对网络底层读写和连接原语言的抽象</p><h3 id="2-EventLoop-控制流、多线程处理、并发"><a class="header-anchor" href="#2-EventLoop-控制流、多线程处理、并发"></a>2. EventLoop-控制流、多线程处理、并发</h3><p>定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件</p><h3 id="注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"><a class="header-anchor" href="#注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系"></a>注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系</h3><p><img src="https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim" alt="mark">)</p><h5 id="A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"><a class="header-anchor" href="#A-一个-EventLoopGroup-包含一个或者多个-EventLoop；"></a>A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；</h5><h5 id="B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"><a class="header-anchor" href="#B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定"></a>B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定</h5><h5 id="C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"><a class="header-anchor" href="#C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；"></a>C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</h5><h5 id="D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"><a class="header-anchor" href="#D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；"></a>D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；</h5><h5 id="E-一个-EventLoop-可能会被分配给一个或多个-Channel"><a class="header-anchor" href="#E-一个-EventLoop-可能会被分配给一个或多个-Channel"></a>E. 一个 EventLoop 可能会被分配给一个或多个 Channel</h5><h5 id="F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"><a class="header-anchor" href="#F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。"></a>F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。</h5><h3 id="3-ChannelFuture-异步通知"><a class="header-anchor" href="#3-ChannelFuture-异步通知"></a>3. ChannelFuture-异步通知</h3><p>Netty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法</p><h3 id="4-ChannelHandler和ChannelPipeline"><a class="header-anchor" href="#4-ChannelHandler和ChannelPipeline"></a>4. ChannelHandler和ChannelPipeline</h3><p>ChannelHandler负责Channel中的逻辑处理<br>其旨在简化应用程序处理逻辑的开发过程<br>充当了所有处理入站和出站数据的应用程序逻辑的容器<br>ChannelHandler子接口：<br>ChannelInboundHandler——处理入站数据以及各种状态变化<br>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作<br>ChannelInboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim" alt="mark"><br>ChannelOutboundHandler的方法:<br><img src="https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim" alt="mark"></p><p>ChannelPipeline 提供了 ChannelHandler链的容器<br>定义了用于在该链上传播入站和出站事件流的API</p><h3 id="5-ByteBuf-Netty的数据容器"><a class="header-anchor" href="#5-ByteBuf-Netty的数据容器"></a>5. ByteBuf-Netty的数据容器</h3><p>Java NIO提供了ByteBuffer作为它的字节容器<br>Netty的ByteBuffer替代品是ByteBuf</p><h5 id="A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"><a class="header-anchor" href="#A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；"></a>A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；</h5><h5 id="B-容量可以按需增长（类似于-JDK-的-StringBuilder）"><a class="header-anchor" href="#B-容量可以按需增长（类似于-JDK-的-StringBuilder）"></a>B.容量可以按需增长（类似于 JDK 的 StringBuilder）</h5><h5 id="C-读和写使用了不同的索引"><a class="header-anchor" href="#C-读和写使用了不同的索引"></a>C.读和写使用了不同的索引</h5><h5 id="D-支持方法的链式调用"><a class="header-anchor" href="#D-支持方法的链式调用"></a>D.支持方法的链式调用</h5><h5 id="E-支持引用计数"><a class="header-anchor" href="#E-支持引用计数"></a>E.支持引用计数</h5><h5 id="F-支持池化"><a class="header-anchor" href="#F-支持池化"></a>F.支持池化</h5><h3 id="6-Bootstap-引导客户端和无连接协议"><a class="header-anchor" href="#6-Bootstap-引导客户端和无连接协议"></a>6. Bootstap-引导客户端和无连接协议</h3><p>Bootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel<br><img src="http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg" alt></p><h2 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h2><p>使用EmbeddedChannel 测试 ChannelHandler</p><ol><li>测试入站消息</li><li>测试出站消息</li><li>测试异常处理</li></ol><h2 id="编解码器"><a class="header-anchor" href="#编解码器"></a>编解码器</h2><ul><li>解码器<br>将字节解码为消息<br>将一种消息类型解码为另一种</li><li>编码器<br>将消息编码为字节<br>将消息编码为消息</li></ul><h2 id="Netty服务端启动"><a class="header-anchor" href="#Netty服务端启动"></a>Netty服务端启动</h2><ol><li>创建服务端Channel</li><li>初始化服务端Channel</li><li>注册Selector</li><li>端口绑定，实现对本地端口的接听</li></ol><h2 id="预置的ChannelHandler和编解码器"><a class="header-anchor" href="#预置的ChannelHandler和编解码器"></a>预置的ChannelHandler和编解码器</h2><ol><li>通过 SSL/TLS 保护 Netty 应用程序</li><li>ChannelHandler处理 HTTP 和 HTTPS协议</li><li>支持WebSocket</li><li>ChannelHandler检测空闲连接以及超时</li><li>FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域</li><li>使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据</li><li>使用UDP广播事件</li></ol><h3 id="创建服务端Channel"><a class="header-anchor" href="#创建服务端Channel"></a>创建服务端Channel</h3><p><strong>bind()[用户代码入口] -&gt;initAndRegister()[初始化并注册] -&gt;newChannel()[创建服务端channel]</strong><br><img src="https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim" alt="mark"></p><p><img src="https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim" alt="mark"></p><h2 id="如何使用Netty进行RPC服务器的开发"><a class="header-anchor" href="#如何使用Netty进行RPC服务器的开发"></a>如何使用Netty进行RPC服务器的开发?</h2><ol><li>定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</li><li>服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</li><li>客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</li><li>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</li><li>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。<br><img src="https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim" alt="mark"> <strong>客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。</strong><br>Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</li><li><img src="https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim" alt="mark"><br><strong>客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</strong></li></ol><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="Netty疑问"><a class="header-anchor" href="#Netty疑问"></a>Netty疑问</h3><ol><li>Netty是什么？<br>Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。</li><li>使用Netty能够做什么？<br>①开发异步、非阻塞的TCP网络应用程序；<br>②开发异步、非阻塞的UDP网络应用程序；<br>③开发异步文件传输应用程序；<br>④开发异步HTTP服务端和客户端应用程序；<br>⑤提供对多种编解码框架的集成；<br>⑥提供形式多样的编解码基础类库；<br>⑦基于职责链模式的Pipeline-Handler机制；<br>⑧所有的IO操作都是异步的；<br>⑨IP黑白名单控制，性能统计；<br>⑩基于链路空闲事件检测的心跳检测；</li><li>Netty在哪些行业得到了应用<br>**①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。<br>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。<br>除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。<br>**②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。<br>**③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。<br>**④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。<br>**⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。</li><li>使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？<br>传统的同步阻塞IO通信存在如下几个问题：<br>**①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>**②性能差：**频繁的线程上下文切换导致CPU利用效率不高；<br>**③可靠性差：*<em>由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br><strong>采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：</strong><br>①Nio采用Reactor模式</em>，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N &lt; 进程可用的最大句柄数)；<br>②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；<br>③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。<br><strong>由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。</strong></li><li>为什么不直接基于JDK的NIO类库编程呢？<br>即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。</li><li>为什么要选择Netty框架？<br>Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。<br>Netty的优点总结如下：<br>①API使用简单，开发门槛低；<br>②功能强大，预置了多种编解码功能，支持多种主流协议；<br>③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；<br>④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；<br>⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；<br>⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；<br>⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。</li></ol><h2 id="代码"><a class="header-anchor" href="#代码"></a>代码</h2><h3 id="1-基于Netty的客户端和服务端的简单通信"><a class="header-anchor" href="#1-基于Netty的客户端和服务端的简单通信"></a>1. 基于Netty的客户端和服务端的简单通信</h3><h5 id="要点："><a class="header-anchor" href="#要点："></a>要点：</h5><p>①为初始化客户端， 创建了一个 Bootstrap 实例<br>②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；<br>③为服务器连接创建了一个 InetSocketAddress 实例；<br>④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；<br>⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；<br><img src="https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim" alt="mark"></p><p><code>&lt;!--more--&gt;</code></p><h3 id="EchoServer"><a class="header-anchor" href="#EchoServer"></a>EchoServer</h3><h3 id="EchoServerHandler"><a class="header-anchor" href="#EchoServerHandler"></a>EchoServerHandler</h3><h5 id="channelRead-—对于每个传入的消息都要调用；"><a class="header-anchor" href="#channelRead-—对于每个传入的消息都要调用；"></a>channelRead()—对于每个传入的消息都要调用；</h5><h5 id="channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"><a class="header-anchor" href="#channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；"></a>channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；</h5><h5 id="exceptionCaught-—在读取操作期间，有异常抛出时会调用。"><a class="header-anchor" href="#exceptionCaught-—在读取操作期间，有异常抛出时会调用。"></a>exceptionCaught()—在读取操作期间，有异常抛出时会调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标示一个ChannelHandler可以被多个 Channel 安全地共享</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//将消息记录到控制台</span></span><br><span class="line">        System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">//将接收到的消息写给发送者，而不冲刷出站消息</span></span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将未决消息冲刷到远程节点，并且关闭该 Channel</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印异常栈跟踪</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="comment">//关闭该Channel</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EchoServer-v2"><a class="header-anchor" href="#EchoServer-v2"></a>EchoServer</h3><h5 id="绑定到服务器将在其上监听并接受传入连接请求的端口；"><a class="header-anchor" href="#绑定到服务器将在其上监听并接受传入连接请求的端口；"></a>绑定到服务器将在其上监听并接受传入连接请求的端口；</h5><h5 id="配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"><a class="header-anchor" href="#配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。"></a>配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoServer.class.getSimpleName() +<span class="string">" &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span></span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//调用服务器的 start()方法</span></span><br><span class="line">        <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="comment">//(1) 创建EventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//(2) 创建ServerBootstrap</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//(3) 指定所使用的 NIO 传输 Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//(4) 使用指定的端口设置套接字地址</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    <span class="comment">//(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例</span></span><br><span class="line">                            <span class="comment">//这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，</span></span><br><span class="line">                            ch.pipeline().addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成</span></span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            System.out.println(EchoServer.class.getName() +</span><br><span class="line">                    <span class="string">" started and listening for connections on "</span> + f.channel().localAddress());</span><br><span class="line">            <span class="comment">//(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//(8) 关闭 EventLoopGroup，释放所有的资源</span></span><br><span class="line">            grop.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-ChannelHandler-实现客户端逻辑"><a class="header-anchor" href="#通过-ChannelHandler-实现客户端逻辑"></a>通过 ChannelHandler 实现客户端逻辑</h3><h5 id="channelActive-——在到服务器的连接已经建立之后将被调用；"><a class="header-anchor" href="#channelActive-——在到服务器的连接已经建立之后将被调用；"></a>channelActive()——在到服务器的连接已经建立之后将被调用；</h5><h5 id="channelRead0-——当服务器接收到一条消息时被调用"><a class="header-anchor" href="#channelRead0-——当服务器接收到一条消息时被调用"></a>channelRead0()——当服务器接收到一条消息时被调用</h5><h5 id="exceptionCaught-——在处理过程中引发异常时被调用。"><a class="header-anchor" href="#exceptionCaught-——在处理过程中引发异常时被调用。"></a>exceptionCaught()——在处理过程中引发异常时被调用。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="comment">//标记该类的实例可以被多个 Channel 共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当被通知 Channel是活跃的时候，发送一条消息</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty rocks!"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录已接收消息的转储</span></span><br><span class="line">        System.out.println(<span class="string">"Client received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在发生异常时，记录错误并关闭Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引导客户端"><a class="header-anchor" href="#引导客户端"></a>引导客户端</h3><h5 id="客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"><a class="header-anchor" href="#客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口"></a>客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建 Bootstrap</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现</span></span><br><span class="line">            b.group(group)</span><br><span class="line">                    <span class="comment">//适用于 NIO 传输的Channel 类型</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置服务器的InetSocketAddress</span></span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">                    <span class="comment">//在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(</span><br><span class="line">                                    <span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//连接到远程节点，阻塞等待直到连接完成</span></span><br><span class="line">            ChannelFuture f = b.connect().sync();</span><br><span class="line">            <span class="comment">//阻塞，直到Channel 关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池并且释放所有的资源</span></span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() +</span><br><span class="line">                    <span class="string">" &lt;host&gt; &lt;port&gt;"</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"><a class="header-anchor" href="#2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架"></a>2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架</h3><h5 id="简易RPC有如下特性："><a class="header-anchor" href="#简易RPC有如下特性："></a>简易RPC有如下特性：</h5><ul><li>服务异步调用的支持，回调函数callback的支持</li><li>客户端使用长连接（在多次调用共享连接）</li><li>服务端异步多线程处理RPC请求</li><li>服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。</li><li>通信：使用Netty作为通信框架</li><li>Spring：使用Spring配置服务，加载Bean，扫描注解</li><li>动态代理：客户端使用代理模式透明化服务调用</li><li>消息编解码：使用Protostuff序列化和反序列化消息</li></ul><h5 id="RPC介绍"><a class="header-anchor" href="#RPC介绍"></a>RPC介绍</h5><p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。</p><p><img src="https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim" alt="mark"></p><ul><li>服务端发布服务</li></ul><h5 id="服务注解："><a class="header-anchor" href="#服务注解："></a>服务注解：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">    Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务接口："><a class="header-anchor" href="#一个服务接口："></a>一个服务接口：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">hello</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一个服务实现：使用注解标注："><a class="header-anchor" href="#一个服务实现：使用注解标注："></a>一个服务实现：使用注解标注：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RpcService</span>(HelloService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! "</span> + person.getFirstName() + <span class="string">" "</span> + person.getLastName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务在启动的时候扫描得到所有的服务接口及其实现："><a class="header-anchor" href="#服务在启动的时候扫描得到所有的服务接口及其实现："></a>服务在启动的时候扫描得到所有的服务接口及其实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">      <span class="keyword">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class="line">            handlerMap.put(interfaceName, serviceBean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="在Zookeeper集群上注册服务地址："><a class="header-anchor" href="#在Zookeeper集群上注册服务地址："></a>在Zookeeper集群上注册服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedExceptin ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端使用代理模式调用服务："><a class="header-anchor" href="#客户端使用代理模式调用服务："></a>客户端使用代理模式调用服务：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceRegistry</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZooKeeper zk = connectServer();</span><br><span class="line">            <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AddRootNode(zk); <span class="comment">// Add root node if not exist</span></span><br><span class="line">                createNode(zk, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRootNode</span><span class="params">(ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zk.create(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            LOGGER.debug(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Zookeeper上获取服务地址："><a class="header-anchor" href="#从Zookeeper上获取服务地址："></a>从Zookeeper上获取服务地址：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceDiscovery</span><span class="params">(String registryAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registryAddress = registryAddress;</span><br><span class="line">        ZooKeeper zk = connectServer();</span><br><span class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span>) &#123;</span><br><span class="line">            watchNode(zk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = dataList.size();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">                data = dataList.get(<span class="number">0</span>);</span><br><span class="line">                LOGGER.debug(<span class="string">"using only data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class="line">                LOGGER.debug(<span class="string">"using random data: &#123;&#125;"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">connectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watchNode</span><span class="params">(<span class="keyword">final</span> ZooKeeper zk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                        watchNode(zk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : nodeList) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class="string">"/"</span> + node, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                dataList.add(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(<span class="string">"node data: &#123;&#125;"</span>, dataList);</span><br><span class="line">            <span class="keyword">this</span>.dataList = dataList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterrupteException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息编码-请求消息："><a class="header-anchor" href="#消息编码-请求消息："></a>消息编码 请求消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameterTypes</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getParameters() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(Object[] parameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="响应消息："><a class="header-anchor" href="#响应消息："></a>响应消息：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestId = requestId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息序列化和反序列化工具：（基于-Protostuff-实现）"><a class="header-anchor" href="#消息序列化和反序列化工具：（基于-Protostuff-实现）"></a>消息序列化和反序列化工具：（基于 Protostuff 实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Objenesis objenesis = <span class="keyword">new</span> ObjenesisStd(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializationUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Schema&lt;T&gt; <span class="title">getSchema</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class="line">        <span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</span><br><span class="line">            schema = RuntimeSchema.createFrom(cls);</span><br><span class="line">            <span class="keyword">if</span> (schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedSchema.put(cls, schema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化（对象 -&gt; 字节数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();</span><br><span class="line">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化（字节数组 -&gt; 对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] data, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T message = (T) objenesis.newInstance(cls);</span><br><span class="line">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(data, message, schema);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStatexception(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能改进-服务端请求异步处理"><a class="header-anchor" href="#性能改进-服务端请求异步处理"></a>性能改进 服务端请求异步处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,<span class="keyword">final</span> RpcRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcServer.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                LOGGER.debug(<span class="string">"Receive request "</span> + request.getRequestId());</span><br><span class="line">                RpcResponse response = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                response.setRequestId(request.getRequestId());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object result = handle(request);</span><br><span class="line">                    response.setResult(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    response.setError(t.toString());</span><br><span class="line">                    LOGGER.error(<span class="string">"RPC Server handle request error"</span>,t);</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        LOGGER.debug(<span class="string">"Send response for request "</span> + request.getRequestId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="服务端长连接的管理"><a class="header-anchor" href="#服务端长连接的管理"></a>服务端长连接的管理</h5><p>客户端保持和服务进行<strong>长连接</strong>，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。<br>通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。</p><h5 id="客户端请求异步处理"><a class="header-anchor" href="#客户端请求异步处理"></a>客户端请求异步处理</h5><p><strong>客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);</span><br><span class="line">RPCFuture helloFuture = client.call(<span class="string">"hello"</span>, Integer.toString(i));</span><br><span class="line">String result = (String) helloFuture.get(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(上)</title>
      <link href="/2020/01/16/RocketMQ-%E4%B8%8A/"/>
      <url>/2020/01/16/RocketMQ-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RocketMQ-是什么"><a class="header-anchor" href="#1-RocketMQ-是什么"></a>1. RocketMQ 是什么</h2><h4 id="RocketMQ是一款、、、易于使用的消息中间件"><a class="header-anchor" href="#RocketMQ是一款、、、易于使用的消息中间件"></a>RocketMQ是一款<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、易于使用的消息中间件</h4><h4 id="RocketMQ具有以下特性"><a class="header-anchor" href="#RocketMQ具有以下特性"></a>RocketMQ具有以下特性</h4><ul><li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li><li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li><li>支持拉（pull）和推（push）两种消息模式</li><li>单一队列百万消息的堆积能力</li><li>支持多种消息协议，如 JMS、MQTT 等</li><li>分布式高可用的部署架构,满足至少一次消息传递语义</li><li>提供 docker 镜像用于隔离测试和云集群部署</li><li>提供配置、指标和监控等功能丰富的 Dashboard</li></ul><blockquote><h3 id="Producer"><a class="header-anchor" href="#Producer"></a>Producer</h3><p><strong>消息生产者</strong>，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。</p><h3 id="Producer-Group"><a class="header-anchor" href="#Producer-Group"></a>Producer Group</h3><p><strong>生产者组</strong>，就是多个发送同一类消息的生产者称之为一个生产者组。</p></blockquote><blockquote><h3 id="Consumer"><a class="header-anchor" href="#Consumer"></a>Consumer</h3><p><strong>消息消费者</strong>，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p><h3 id="Consumer-Group"><a class="header-anchor" href="#Consumer-Group"></a>Consumer Group</h3><p><strong>消费者组</strong>，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></blockquote><blockquote><h3 id="Topic"><a class="header-anchor" href="#Topic"></a>Topic</h3><p><em>Topic</em> 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推</p><h3 id="Message"><a class="header-anchor" href="#Message"></a>Message</h3><p><em>Message</em>是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p></blockquote><blockquote><h3 id="Tag"><a class="header-anchor" href="#Tag"></a>Tag</h3><p><em>Tag</em><strong>标签</strong>可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息</p><h3 id="Broker"><a class="header-anchor" href="#Broker"></a>Broker</h3><p><em>Broker</em>是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备</p><h3 id="Name-Server"><a class="header-anchor" href="#Name-Server"></a>Name Server</h3><p><em>Name Server</em> 为 producer 和 consumer 提供路由信息。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>响应时间低，比如一个网页在几秒内打开，越短表示延迟越低 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>指的是运行时间能够满足预计时间的一个系统或组件 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
