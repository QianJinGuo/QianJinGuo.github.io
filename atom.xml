<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>架构师成长之旅</title>
  
  <subtitle>刻意练习，从新手到领域大牛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jinguo.tech/"/>
  <updated>2021-12-13T16:19:17.643Z</updated>
  <id>https://jinguo.tech/</id>
  
  <author>
    <name>Qian JinGuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/"/>
    <id>https://jinguo.tech/2022/01/14/%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%A6%99%E7%94%A8/</id>
    <published>2022-01-13T18:02:14.399Z</published>
    <updated>2021-12-13T16:19:17.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节数组"><a class="header-anchor" href="#字节数组"></a>字节数组</h1><p>#字节 #字节数组 #缓存</p><h1 id="字节属于最小单位"><a class="header-anchor" href="#字节属于最小单位"></a>字节属于最小单位</h1><p>例如在Java中，int占用4个字节，long占用8个字节等。基本上所有基本类型(包括String)都可以转换成字节，那么这到底有何作用。<br>在实际开发中，经常会用到本地缓存，或使用<code>Redis</code>或者<code>Memcached</code>来作分布式缓存,Java一般存入缓存中的对象无非是以下几种:</p><ul><li>序列化的Java对象：一个Java对象序列化后所占用的字节是按对象中属性个数，方法个数，以及属性的值决定，最小也需要几百个字节来存储，大的话可能需要几万个字节</li><li>String(可能是json串)：占用字节由字符串的长度决定</li><li>规则的byte[]数组：占用字节由数组长度决定，相比较于String来说，基本类型转换成固定字节的数组，而不是转换成内容长度的String，故字节数组所占用的字节比String更少</li></ul><blockquote><ol><li>在大量的缓存数据(亿级以上)的情况下，为了提高空间利用率，切勿将<strong>Java对象</strong>当做缓存的内容</li><li>字节数组所需空间最少</li></ol></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/665f4dd77f30" target="_blank" rel="noopener">字节数组的妙用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字节数组&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#字节数组&quot;&gt;&lt;/a&gt;字节数组&lt;/h1&gt;
&lt;p&gt;#字节 #字节数组 #缓存&lt;/p&gt;
&lt;h1 id=&quot;字节属于最小单位&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#字节属
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>https://jinguo.tech/2022/01/14/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2022-01-13T18:02:14.393Z</published>
    <updated>2021-12-13T13:58:53.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程中断"><a class="header-anchor" href="#线程中断"></a>线程中断</h1><p>#线程 #并发</p><h2 id="Thread类详解"><a class="header-anchor" href="#Thread类详解"></a>Thread类详解</h2><ul><li>interrupt</li><li>interrupted</li><li>isInterrupted</li><li>join</li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/xingele0917/p/3994468.html" target="_blank" rel="noopener">并发编程实践</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程中断&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线程中断&quot;&gt;&lt;/a&gt;线程中断&lt;/h1&gt;
&lt;p&gt;#线程 #并发&lt;/p&gt;
&lt;h2 id=&quot;Thread类详解&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Thread类详
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://jinguo.tech/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-01-13T18:02:14.387Z</published>
    <updated>2021-12-13T13:35:51.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程执行顺序"><a class="header-anchor" href="#线程执行顺序"></a>线程执行顺序</h1><p>#线程 #jvm</p><h2 id="线程执行顺序-v2"><a class="header-anchor" href="#线程执行顺序-v2"></a>线程执行顺序</h2><blockquote><p>jvm为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证[^1]<br><code>1.《深入理解Java虚拟机：JVM高级特性与最佳实践》 — 周志明</code></p></blockquote><p>如果程序没有正确同步，那么可能会存在数据竞争。JMM对数据竞争的定义如下：</p><blockquote><p>在一个线程中写一个变量，在另一个线程中读取同一个变量，而且写和读没有通过同步来排序</p></blockquote><p>顺序一致性模型有以下<strong>两大特性</strong>：</p><ol><li>一个线程中的所有操作必须按照==程序的顺序==来执行</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致内存模型中，每一个操作都必须是原子执行且立即对所有线程可见。</li></ol><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以把顺序顺序一致模型理解为一个单摆，每一个时刻单摆只能到一个位置，对应过来，任何时刻最多只能有一个线程才能连接到内存。</span><br><span class="line">由于重排序的影响，实际指令的执行顺序是不可知的，但是不管如何排序，每个操作能够立即对其他线程可见，所以所有线程看到的都是一样的执行顺序。</span><br><span class="line">但是在JMM中是没有这个规定的，就是说其他线程看到执行顺序与除自己外的线程看到的执行顺序可能是不一致的。</span><br><span class="line">比如，当前线程把写过的数据缓存缓存到写缓存中，在没有刷新到主内存（计算机系统的DRAM）之前，这个写操作对其他线程是不可见的，意味着其他线程认为该线程根本没有执行写操作。</span><br><span class="line">那么何时才能可见呢？只有在当前线程把写缓存中数据刷新到主内存的时候，对其他内存才是可见的。</span><br></pre></td></tr></table></figure><p><strong>如何控制多线程的执行顺序</strong>？</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/hello_worldee/article/details/77823426" target="_blank" rel="noopener">多线程-重排序与顺序一致性</a><br>![[并发编程以及锁.pptx]]![[java多线程相关分享.pptx]]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程执行顺序&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线程执行顺序&quot;&gt;&lt;/a&gt;线程执行顺序&lt;/h1&gt;
&lt;p&gt;#线程 #jvm&lt;/p&gt;
&lt;h2 id=&quot;线程执行顺序-v2&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://jinguo.tech/2022/01/14/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-13T18:02:14.382Z</published>
    <updated>2021-12-13T16:00:33.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池实现原理"><a class="header-anchor" href="#线程池实现原理"></a>线程池实现原理</h1><p>#线程 #线程池 #并发</p><h2 id="线程池是什么"><a class="header-anchor" href="#线程池是什么"></a>线程池是什么</h2><p>线程池（Thread Pool）是一种基于==池化==思想管理线程的工具，经常出现在多线程服务器中，如MySQL。<br>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><h2 id="线程池解决的问题是什么"><a class="header-anchor" href="#线程池解决的问题是什么"></a>线程池解决的问题是什么</h2><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。<br>为解决资源分配这个问题，线程池采用了“==池化==”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</li></ol><blockquote><p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p></blockquote><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。<br>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ol><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ol><h2 id="线程池核心设计与实现"><a class="header-anchor" href="#线程池核心设计与实现"></a>线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。</p><h2 id="线程池在业务中的实践"><a class="header-anchor" href="#线程池在业务中的实践"></a>线程池在业务中的实践</h2><p><strong>场景1：快速响应用户请求</strong><br><strong>场景2：快速处理批量任务</strong></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a><br><a href="https://www.cnblogs.com/xiaoxi/p/7692250.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程池实现原理&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线程池实现原理&quot;&gt;&lt;/a&gt;线程池实现原理&lt;/h1&gt;
&lt;p&gt;#线程 #线程池 #并发&lt;/p&gt;
&lt;h2 id=&quot;线程池是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98/"/>
    <id>https://jinguo.tech/2022/01/14/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98/</id>
    <published>2022-01-13T18:02:14.375Z</published>
    <updated>2021-12-13T17:11:44.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先更新数据库还是先更新缓存"><a class="header-anchor" href="#先更新数据库还是先更新缓存"></a>先更新数据库还是先更新缓存</h1><p>#缓存  #redis #数据库</p><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><p>在系统中引入缓存后，当向数据库中写入数据时，是先写数据库还是先写缓存呢？先写数据库和先写缓存有什么区别吗？</p><blockquote><p>从本质上讲，无论是先写数据库还是先写缓存，都是为了保证数据库和缓存的数据一致，也就是我们常说的数据一致性。<br>随着互联网的高速发展，当今时代已然从IT时代进入到DT时代。互联网系统架构也已经由最初的单体架构转变为分布式、微服务架构模式。从数据体量上来看，各系统存储的数据量越来越大，数据的查询性能越来越低。此时，就需要我们不断的进行优化，一种常用的优化手段就是引入缓存。而引入缓存后，我们在向数据库插入数据时，到底是先更新数据库还是先更新缓存呢？</p></blockquote><h2 id="缓存的一般使用"><a class="header-anchor" href="#缓存的一般使用"></a>缓存的一般使用</h2><p>缓存，从本质上讲，是为了更好的协调两个速度差异比较大的组件而引入的一种中间缓存层。例如，如果需要将数据读入CPU进行计算处理，由于CPU的运算速度是非常快的，而磁盘的IO处理相比于CPU来说，慢了很多数量级，每次从磁盘读取数据，势会造成CPU长时间并且频繁等待磁盘IO。此时，我们就可以通过内存来缓和CPU和磁盘之间的速度差异。</p><h2 id="缓存更新策略"><a class="header-anchor" href="#缓存更新策略"></a>缓存更新策略</h2><p>从理论上来说，给缓存设置过期时间，其实是一中最终一致性的表现。这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。这也是一般情况下，使用的最多的一种方式。</p><h2 id="应用"><a class="header-anchor" href="#应用"></a>应用</h2><p>火车票中转</p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://juejin.cn/post/6985187835145879588?utm_source=gold_browser_extension" target="_blank" rel="noopener">先更新数据库还是先更新缓存</a><br><a href="https://www.jianshu.com/p/dc1e5091a0d8" target="_blank" rel="noopener">Redis缓存双删</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;先更新数据库还是先更新缓存&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#先更新数据库还是先更新缓存&quot;&gt;&lt;/a&gt;先更新数据库还是先更新缓存&lt;/h1&gt;
&lt;p&gt;#缓存  #redis #数据库&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a class=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E5%90%8C%E6%AD%A5%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E6%A0%87%E6%B3%A8/"/>
    <id>https://jinguo.tech/2022/01/14/%E5%90%8C%E6%AD%A5%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E6%A0%87%E6%B3%A8/</id>
    <published>2022-01-13T18:02:14.368Z</published>
    <updated>2021-12-14T11:58:55.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步注解与并发性标注"><a class="header-anchor" href="#同步注解与并发性标注"></a>同步注解与并发性标注</h1><p>#spring #注解 #线程</p><h2 id="同步注解"><a class="header-anchor" href="#同步注解"></a>同步注解</h2><ul><li>@GuardedBy( “this” ) 受对象内部锁保护</li><li>@GuardedBy( “fieldName” ) 受 与fieldName引用相关联的锁保护</li><li>@GuardedBy( “ClassName.fieldName” ) 受一个类的静态field的锁保护。</li><li>@GuardedBy( “methodName()” ) 锁对象是 methodName() 方法的返值，受这个锁保护。</li><li>@GuardedBy( “ClassName.class” ) 受 ClassName类的直接锁对象保护。而不是这个类的某个实例的锁对象。</li></ul><h2 id="并发性标注"><a class="header-anchor" href="#并发性标注"></a>并发性标注</h2><p>@GuardedBy @NotThreadSafe @ThreadSafe<br>这三个类级别的标注可以描述类的线程安全保证性,属于类公开文档的一部分.它只是标注了该类是否是线程安全的,但实际上没法保证线程安全.</p><ul><li>@Immutable<br>表示类是不可变得既是final修饰的,它是线程安全的</li><li>@ThreadSafe<br>类是线程安全的</li><li>@NotThreadSafe<br>类不是线程安全的，如果类未加任何注解，则不能确定是否线程安全，认为是非线程安全的</li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/u010870167/article/details/88059219" target="_blank" rel="noopener">并发性标注</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;同步注解与并发性标注&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#同步注解与并发性标注&quot;&gt;&lt;/a&gt;同步注解与并发性标注&lt;/h1&gt;
&lt;p&gt;#spring #注解 #线程&lt;/p&gt;
&lt;h2 id=&quot;同步注解&quot;&gt;&lt;a class=&quot;header-an
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%BD%AF%E4%BB%B6/"/>
    <id>https://jinguo.tech/2022/01/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%BD%AF%E4%BB%B6/</id>
    <published>2022-01-13T18:02:14.362Z</published>
    <updated>2021-12-14T14:45:31.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="科学上网"><a class="header-anchor" href="#科学上网"></a>科学上网</h1><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/367821925" target="_blank" rel="noopener">五分钟注册美区Apple ID</a><br><a href="https://v2xtls.org/just-my-socks-ios%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Just My Socks配置</a><br><a href="https://v2xtls.org/shadowsocks-ss-ios%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/" target="_blank" rel="noopener">Shadowsocks客户端</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;科学上网&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#科学上网&quot;&gt;&lt;/a&gt;科学上网&lt;/h1&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://jinguo.tech/2022/01/14/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-01-13T18:02:14.355Z</published>
    <updated>2021-12-13T16:10:17.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关闭线程池"><a class="header-anchor" href="#关闭线程池"></a>关闭线程池</h1><p>#线程池 #dubbo</p><h2 id="dubbo优雅关闭线程池"><a class="header-anchor" href="#dubbo优雅关闭线程池"></a>dubbo优雅关闭线程池</h2><ul><li>shutDown：通知线程池启动有序关闭，执行线程池之前已经提交的任务，但是不再接受新的任务。调用shutDown后再提交任务将会抛出RejectedExecutionException异常。</li><li>shutDownNow：尝试立即停止所有已经提交的任务，并会返回正在等待执行（未执行）的任务列表。shutDownNow通过向线程池中的线程发送一个中断请求而中止线程，如果线程池中运行了会抛出InterruptedException的程序，将会抛出一个InterruptedException。如过这个线程不能响应中断那么可能永远无法被终止。</li><li>isTerminated：所有的任务都被关闭返回true，否则返回false。只有调用了shutDown或者shutDownNow，isTerminated才可能为true。</li><li>awaitTermination(long timeout,TimeUnit unit)throws InterruptedException：阻塞当前线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor shutdownExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>),</span><br><span class="line">            <span class="keyword">new</span> NamedThreadFactory(<span class="string">"Close-ExecutorService-Timer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ExecutorService) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((ExecutorService) executor).isTerminated()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use the shutdown pattern from:</span></span><br><span class="line"><span class="comment">     *  https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the Executor to shutdown</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the timeout in milliseconds before termination</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gracefulShutdown</span><span class="params">(Executor executor, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Disable new tasks from being submitted</span></span><br><span class="line">            es.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Wait a while for existing tasks to terminate</span></span><br><span class="line">            <span class="keyword">if</span> (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                es.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            es.shutdownNow();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            newThreadToCloseExecutor(es);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownNow</span><span class="params">(Executor executor, <span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(executor <span class="keyword">instanceof</span> ExecutorService) || isTerminated(executor)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = (ExecutorService) executor;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            es.shutdownNow();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            es.awaitTermination(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            newThreadToCloseExecutor(es);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newThreadToCloseExecutor</span><span class="params">(<span class="keyword">final</span> ExecutorService es)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isTerminated(es)) &#123;</span><br><span class="line">            shutdownExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                            es.shutdownNow();</span><br><span class="line">                            <span class="keyword">if</span> (es.awaitTermination(<span class="number">10</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://developer.aliyun.com/article/756816" target="_blank" rel="noopener">学习dubbo如何优雅关闭线程池</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关闭线程池&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#关闭线程池&quot;&gt;&lt;/a&gt;关闭线程池&lt;/h1&gt;
&lt;p&gt;#线程池 #dubbo&lt;/p&gt;
&lt;h2 id=&quot;dubbo优雅关闭线程池&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E8%BF%94%E5%9B%9E%E7%A9%BAList%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://jinguo.tech/2022/01/14/%E8%BF%94%E5%9B%9E%E7%A9%BAList%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-01-13T18:02:14.349Z</published>
    <updated>2021-12-13T13:37:54.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空list"><a class="header-anchor" href="#空list"></a>空list</h1><p>#list #jdk8 #stream</p><h2 id="返回空List的方式"><a class="header-anchor" href="#返回空List的方式"></a>返回空List的方式</h2><ol><li><code>new ArrayList()</code></li><li><code>new ArrayList(0)</code></li><li><code>Collections.emptyList()</code></li><li><code>Lists.newArrayList()</code></li></ol><p><a href="https://blog.csdn.net/yangguosb/article/details/84573635" target="_blank" rel="noopener">返回空List的方式</a></p><p>因为返回空集合的替代方法通常是返回null;<br>然后呼叫者必须添加针对NullPointerException的警卫。如果返回空集合，则会减轻错误类别。在Java 8+中，还有一个Optional类型，它可以在没有Collection的情况下实现相同的目的。</p><h2 id="返回null-还是-空集合？-推荐空集合"><a class="header-anchor" href="#返回null-还是-空集合？-推荐空集合"></a>返回null 还是 空集合？ 推荐空集合</h2><p>null ?? []<br><strong>返回null 还是 空对象？</strong><br>如果您打算指示没有可用数据，则返回null通常是最好的主意。<br><strong>空对象表示已返回数据，而返回null则表示未返回任何内容。</strong></p><p>此外，如果尝试访问<strong>对象中的成员</strong>，则返回null将会导致<strong>null异常</strong>，这对于突出显示错误代码很有用-尝试不访问任何成员是没有意义的。访问空对象的成员不会失败，这意味着错误可能会被发现。<br>map类似 Stream 的 map方法。处理完之后，返回的还是一个 Optional 对象，所以可以做链式调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">String name = Optional.of(user).map(User::getName).orElse(<span class="string">"佚名"</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure><p>如上，取出user对象的name值，若name为空，返回一个默认值“佚名”（神奇的名字）。<br>这里，直接调用map方法，就不需要对user对象进行预先判空了。因为在map方法里边，会调用isPresent方法帮我们处理user为null的情况。<br>到这里，脑袋转圈快的小伙伴，是不是对开头的坑已经有启发了。<br>没错，我们可以通过 <strong>Optional 的链式调用</strong>，通过 map，orElse 等操作改写。如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getUserAddr1</span><span class="params">(Optional&lt;User&gt; user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先获取address对象</span></span><br><span class="line">    <span class="keyword">return</span> user.map((u)-&gt;u.getAddress())</span><br><span class="line">            <span class="comment">//再获取details值，</span></span><br><span class="line">            .map(e -&gt; e.getDetails())</span><br><span class="line">            <span class="comment">//若detail为null，则返回一个默认值</span></span><br><span class="line">            .orElse(<span class="string">"地址信息未填写"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<a href="https://segmentfault.com/a/1190000023912618" target="_blank" rel="noopener">JDK8新特性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;空list&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#空list&quot;&gt;&lt;/a&gt;空list&lt;/h1&gt;
&lt;p&gt;#list #jdk8 #stream&lt;/p&gt;
&lt;h2 id=&quot;返回空List的方式&quot;&gt;&lt;a class=&quot;header-anchor&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
    <id>https://jinguo.tech/2022/01/14/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%BF%9E%E9%80%9A%E6%80%A7/</id>
    <published>2022-01-13T18:02:14.342Z</published>
    <updated>2021-12-13T16:53:04.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试端口连通性"><a class="header-anchor" href="#测试端口连通性"></a>测试端口连通性</h1><p>#centos #端口</p><h2 id="如何测试端口通不通"><a class="header-anchor" href="#如何测试端口通不通"></a>如何测试端口通不通</h2><ul><li><strong>使用telnet判断</strong></li></ul><p><code>telnet ip post</code></p><ul><li><strong>使用ssh判断</strong></li></ul><p><code>ssh -v -p port username@ip</code></p><blockquote><p>-v 调试模式(会打印日志).<br>-p 指定端口</p></blockquote><ul><li><p><strong>使用wget判断</strong><br><code>wget ip:port</code></p></li><li><p><strong>使用端口扫描工具</strong></p></li><li><p><strong>使用专用工具tcping进行访问：</strong></p></li></ul><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/swazer_z/article/details/64442730" target="_blank" rel="noopener">如何测试端口通不通</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;测试端口连通性&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#测试端口连通性&quot;&gt;&lt;/a&gt;测试端口连通性&lt;/h1&gt;
&lt;p&gt;#centos #端口&lt;/p&gt;
&lt;h2 id=&quot;如何测试端口通不通&quot;&gt;&lt;a class=&quot;header-anchor&quot; hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://jinguo.tech/2022/01/14/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-01-13T18:02:14.324Z</published>
    <updated>2021-12-14T14:32:41.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue基础语法"><a class="header-anchor" href="#Vue基础语法"></a>Vue基础语法</h1><p>#vue #js</p><h2 id="v-if与v-show的区别以及使用场景"><a class="header-anchor" href="#v-if与v-show的区别以及使用场景"></a>v-if与v-show的区别以及使用场景</h2><p>如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><h2 id="v-model和-model的区别"><a class="header-anchor" href="#v-model和-model的区别"></a>v-model和:model的区别</h2><p><strong>v-model是vue.js中内置的双向数据绑定指令</strong>，用于表单控件以外的标签是不起作用的(即<strong>只对表单控件标签的数据双向绑定有效</strong>)。<br><strong>:model相当于v-bind:model的缩写</strong>，v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，这种只是<strong>将父组件的数据传递到了子组件</strong>，并没有实现子组件和父组件数据的双向绑定。<br>当然引用类型除外，子组件改变引用类型的数据的话，父组件也会改变的。<br><code>&lt;input v-model=&quot;message&quot;&gt; = &lt;input v-bind:value=&quot;message&quot; v-on:input=&quot;message = $event.target.value&quot; /&gt;</code><br>上面这个例子中，v-bind:value=“message” 只是将message变量的值赋给了input的value，并没有双向绑定，在此声明一下以防混淆</p><h2 id="nextTick"><a class="header-anchor" href="#nextTick"></a>nextTick</h2><p><code>Vue</code> 实现响应式并不是数据发生变化之后 <code>DOM</code> 立即变化，而是按一定的策略进行 <code>DOM</code> 的更新<br>简单来说，<code>Vue</code> 在修改数据后，视图不会立刻更新，而是等<strong>同一事件循环</strong>中的所有数据变化完成之后，再统一进行视图更新。<br><code>Vue</code> 中 <code>data</code> 的数据变化是<strong>同步</strong>的，更新完就能拿到；但是 <code>dom</code> 的更新是<strong>异步</strong>的，需要用<code>nextTick</code> 去即时获取<br><strong>说白了就是因为</strong> <code>**Vue**</code> <strong>是异步执行</strong> <code>**DOM**</code> <strong>更新的，想立即操作更新后的</strong> <code>**DOM**</code> <strong>就需要使用</strong> <code>**$nextTick**</code><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/1136954/1629425520217-dd07b909-c560-4281-82a5-354bc43d7003.webp" alt="nextTick"></p><blockquote><p>在 <code>created</code> 和 <code>mounted</code> 阶段，如果需要操作渲染后的视图，也要使用 <code>nextTick</code> 方法。<br>官方文档说明：注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue中数组赋值，push和“-”有什么区别？"><a class="header-anchor" href="#vue中数组赋值，push和“-”有什么区别？"></a>vue中数组赋值，push和“=”有什么区别？</h2><p>push是向数组中==追加数据==，不删除数组原有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">res.push(<span class="number">5</span>);</span><br><span class="line">res.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 输出[2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><p>&quot;=&quot;等于号是一个数组，==覆盖==原数组的数据进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> tmp = [<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">res = tmp;</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 输出[5,6]</span></span><br></pre></td></tr></table></figure><h2 id="日期计算"><a class="header-anchor" href="#日期计算"></a>日期计算</h2><h3 id="计算结束日期与当前时间相差天数"><a class="header-anchor" href="#计算结束日期与当前时间相差天数"></a>计算结束日期与当前时间相差天数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateDiffer(Date_end)&#123;</span><br><span class="line">   <span class="comment">//date1结束时间</span></span><br><span class="line">   <span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(Date_end);</span><br><span class="line">   <span class="comment">//date2当前时间</span></span><br><span class="line">   <span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">   date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(date1.getFullYear(), date1.getMonth(), date1.getDate());</span><br><span class="line">   date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(date2.getFullYear(), date2.getMonth(), date2.getDate());</span><br><span class="line">   <span class="keyword">const</span> diff = date1.getTime() - date2.getTime(); <span class="comment">//目标时间减去当前时间</span></span><br><span class="line">   <span class="keyword">const</span> diffDate = diff / (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);  <span class="comment">//计算当前时间与结束时间之间相差天数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算传入日期的最近三个月"><a class="header-anchor" href="#计算传入日期的最近三个月"></a>计算传入日期的最近三个月</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recently3Month(date) &#123;</span><br><span class="line">  <span class="keyword">let</span> reportDate = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">  <span class="keyword">let</span> cutoffDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  cutoffDate.setMonth(cutoffDate.getMonth() - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> reportDate.getTime() &gt; cutoffDate.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date与String相互转换"><a class="header-anchor" href="#Date与String相互转换"></a>Date与String相互转换</h3><blockquote><p>时间转换获取时间戳 : var res = moment(Date.now(), ‘YYYY-MM-DD HH:mm:ss’).valueOf();<br>时间转换获取格式时间: <strong>var</strong> res = moment(Date.now()).format(<strong>‘YYYY-MM-DD HH:mm:ss’</strong>);<br>String转换Date时间戳：var datelong = moment(this.habit.startTime,“YYYY-MM-DD”);</p></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.jianshu.com/p/7af8554d8f08" target="_blank" rel="noopener">v-if与v-show的区别以及使用场景</a><br><a href="https://blog.csdn.net/u012155729/article/details/87857414" target="_blank" rel="noopener">v-model和:model的区别</a><br><a href="https://juejin.cn/post/6970877981778509838" target="_blank" rel="noopener">nextTick方法</a><br><a href="https://blog.csdn.net/qq_31759203/article/details/109072551" target="_blank" rel="noopener">vue中数组赋值</a><br><a href="https://blog.csdn.net/jie520191/article/details/100011426" target="_blank" rel="noopener">vue moment时间戳Date</a><br><a href="https://blog.csdn.net/weixin_46074961/article/details/106421566" target="_blank" rel="noopener">this.$set的正确使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue基础语法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Vue基础语法&quot;&gt;&lt;/a&gt;Vue基础语法&lt;/h1&gt;
&lt;p&gt;#vue #js&lt;/p&gt;
&lt;h2 id=&quot;v-if与v-show的区别以及使用场景&quot;&gt;&lt;a class=&quot;header-an
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/Stream%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/"/>
    <id>https://jinguo.tech/2022/01/14/Stream%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/</id>
    <published>2022-01-13T18:02:14.318Z</published>
    <updated>2021-12-13T13:02:43.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stream排序和分页"><a class="header-anchor" href="#stream排序和分页"></a>stream排序和分页</h1><p>#stream #排序 #分页</p><h2 id="Java-8-stream排序-分页"><a class="header-anchor" href="#Java-8-stream排序-分页"></a>Java 8 stream排序&amp;分页</h2><h3 id="排序"><a class="header-anchor" href="#排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student newList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v1.getId().compareTo(</span><br><span class="line">v2.getId()</span><br><span class="line">)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v2getId().compareTo(</span><br><span class="line">v1.getId()</span><br><span class="line">)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据子对象id，升序排序，Student对象中还有一个Boy的对象属性</span></span><br><span class="line">list.stream().sorted((v1,v2)-&gt;v1.getBoy().getbId().compareTo(</span><br><span class="line">v2.getBoy().getbId()</span><br><span class="line">)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="分页"><a class="header-anchor" href="#分页"></a>分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().skip((currentPage-<span class="number">1</span>)*pageSize).limit(pageSize).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="在项目中的运用："><a class="header-anchor" href="#在项目中的运用："></a>在项目中的运用：</h3><pre><code class="language-java">long totalPage = resultList.size() / request.getPageSize() + (resultList.size() % request.getPageSize() &gt; 0 ? 1 : 0);Pagination pagination = new Pagination(request.getCurrent().longValue(), request.getPageSize().longValue(),(long) resultList.size(), totalPage);//通过stream对返回结果进行分页List&lt;MarketingTaskEntity&gt; paginationResults = resultList.stream().skip((request.getCurrent() - 1) * request.getPageSize()).limit(request.getPageSize()).collect(Collectors.toList());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stream排序和分页&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#stream排序和分页&quot;&gt;&lt;/a&gt;stream排序和分页&lt;/h1&gt;
&lt;p&gt;#stream #排序 #分页&lt;/p&gt;
&lt;h2 id=&quot;Java-8-stream排序-分页&quot;&gt;&lt;a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/SQL%20Where%E5%A6%99%E7%94%A8/"/>
    <id>https://jinguo.tech/2022/01/14/SQL%20Where%E5%A6%99%E7%94%A8/</id>
    <published>2022-01-13T18:02:14.312Z</published>
    <updated>2021-12-14T14:53:32.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-Where妙用"><a class="header-anchor" href="#SQL-Where妙用"></a>SQL Where妙用</h1><p>#sql</p><h2 id="深入理解SQL中where-1-1的用处"><a class="header-anchor" href="#深入理解SQL中where-1-1的用处"></a>深入理解SQL中where 1=1的用处</h2><ol><li><p>where 的条件为永真<br>SQL注入时:<br><code>DELETE FROM table_a WHERE name= '张三'</code><br><code>DELETE FROM table_a WHERE name= '张三' or 1=1</code><br>本来是删除ａ值为张三的这一条数据，这就又变成了无约束的删除了。<br>1=1 永真， 1&lt;&gt;1 永假。</p></li><li><p>在后台写不定数量的查询条件下，便于规范语句，增加灵活性<code>String sql = &quot;select * from table a&quot;;</code></p></li></ol><p><strong>在不使用where 1=1的情况下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"name"</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.name='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"age"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"age"</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.age='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"class "</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"class "</span>).toString();</span><br><span class="line">    sql+=<span class="string">"where a.class ='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当时用</strong>where 1=1** 的时候**<br><code>String sql = &quot;select * from table a where 1=1&quot;;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"name"</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.name='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"age"</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"age"</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.age='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(params.containsKey(<span class="string">"class "</span>))&#123;</span><br><span class="line">    String key = params.get(<span class="string">"class "</span>).toString();</span><br><span class="line">    sql+=<span class="string">" and a.class ='"</span>+key +<span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis-where-1-1-和-where标签"><a class="header-anchor" href="#Mybatis-where-1-1-和-where标签"></a>Mybatis where 1=1 和 where标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selSampleListByIDX4"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"cn.com.git.cbs.datamodel.TBL_Sample"</span>&gt;</span></span><br><span class="line"> select </span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line"> from SAMPLE</span><br><span class="line"> where 1=1   </span><br><span class="line">   <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"samplenumber != null"</span> &gt;</span></span><br><span class="line">     AND SAMPLENUMBER = #&#123;samplenumber,jdbcType=DECIMAL&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mybatis  之前拼条件的时候 写法  where 1=1，也可以使where标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。</li><li>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：<br><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt;</code></li></ul><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><p><a href="https://blog.csdn.net/idomyway/article/details/78903822" target="_blank" rel="noopener">深入理解SQL中where 1=1的用处</a><br><a href="https://blog.csdn.net/qq_23994787/article/details/79045768" target="_blank" rel="noopener">where 1=1有什么用</a><br><a href="https://blog.csdn.net/xiaxiaorui2003/article/details/53301540" target="_blank" rel="noopener">where 1=1 和 where标签</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL-Where妙用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#SQL-Where妙用&quot;&gt;&lt;/a&gt;SQL Where妙用&lt;/h1&gt;
&lt;p&gt;#sql&lt;/p&gt;
&lt;h2 id=&quot;深入理解SQL中where-1-1的用处&quot;&gt;&lt;a class=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/SpringBoot%E9%9B%86%E6%88%90Kafka/"/>
    <id>https://jinguo.tech/2022/01/14/SpringBoot%E9%9B%86%E6%88%90Kafka/</id>
    <published>2022-01-13T18:02:14.305Z</published>
    <updated>2021-12-13T17:18:29.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot集成Kafka"><a class="header-anchor" href="#SpringBoot集成Kafka"></a>SpringBoot集成Kafka</h1><h2 id="Maven配置"><a class="header-anchor" href="#Maven配置"></a>Maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://jishuin.proginn.com/p/763bfbd4c199" target="_blank" rel="noopener">SpringBoot集成Kafka</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot集成Kafka&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#SpringBoot集成Kafka&quot;&gt;&lt;/a&gt;SpringBoot集成Kafka&lt;/h1&gt;
&lt;h2 id=&quot;Maven配置&quot;&gt;&lt;a class=&quot;header-a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <id>https://jinguo.tech/2022/01/14/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</id>
    <published>2022-01-13T18:02:14.299Z</published>
    <updated>2021-12-14T11:55:07.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot参数校验"><a class="header-anchor" href="#SpringBoot参数校验"></a>SpringBoot参数校验</h1><p>#spring</p><h2 id="参数校验"><a class="header-anchor" href="#参数校验"></a>参数校验</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException.class)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">argValidException</span><span class="params">(HttpServletResponse response, MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"参数校验异常："</span>, ex);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ex.getBindingResult().hasErrors()) &#123;</span><br><span class="line">            ex.getBindingResult().getFieldErrors().forEach(err-&gt;&#123;</span><br><span class="line">                builder.append(err.getDefaultMessage()).append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BaseResponse.fail(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/apply/collection"</span>, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">applyCollectionPermission</span><span class="params">(@Valid @RequestBody ApplyCollectionPermissionRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = metabaseService.applyCollection(request);</span><br><span class="line">        <span class="keyword">return</span> success ? BaseResponse.success(<span class="string">"已提交申请，等待审批。"</span>) : BaseResponse.fail(<span class="string">"操作失败，请重试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplyCollectionPermissionRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"申请理由不能为空"</span>)</span><br><span class="line">    String reason;</span><br><span class="line">    List&lt;MBCollection&gt; collections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html" target="_blank" rel="noopener">springboot使用hibernate validator</a><br><a href="https://juejin.cn/post/6844903974257049608" target="_blank" rel="noopener">@valid和@validated</a><br><a href="https://my.oschina.net/u/3706132/blog/1557940" target="_blank" rel="noopener">分组校验</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot参数校验&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#SpringBoot参数校验&quot;&gt;&lt;/a&gt;SpringBoot参数校验&lt;/h1&gt;
&lt;p&gt;#spring&lt;/p&gt;
&lt;h2 id=&quot;参数校验&quot;&gt;&lt;a class=&quot;heade
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/Redis%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    <id>https://jinguo.tech/2022/01/14/Redis%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</id>
    <published>2022-01-13T18:02:14.292Z</published>
    <updated>2021-12-13T17:15:56.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis延迟队列"><a class="header-anchor" href="#Redis延迟队列"></a>Redis延迟队列</h1><p>#缓存 #redis #队列</p><h2 id="带有延迟功能的消息队列"><a class="header-anchor" href="#带有延迟功能的消息队列"></a>带有延迟功能的消息队列</h2><h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><h3 id="设计目标"><a class="header-anchor" href="#设计目标"></a>设计目标</h3><h3 id="设计方案"><a class="header-anchor" href="#设计方案"></a>设计方案</h3><h3 id="核心代码实现"><a class="header-anchor" href="#核心代码实现"></a>核心代码实现</h3><h3 id="源码"><a class="header-anchor" href="#源码"></a>源码</h3><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://www.yuque.com/jinguo.tech/ca7ygu/ps8gdy" target="_blank" rel="noopener">Redis延迟队列</a><br><a href="https://blog.csdn.net/qq_21033663/article/details/101222502" target="_blank" rel="noopener">延迟队列浅析</a><br><a href="https://www.jianshu.com/p/6bddbfa52cef" target="_blank" rel="noopener">延迟队列的几种实现方式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis延迟队列&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Redis延迟队列&quot;&gt;&lt;/a&gt;Redis延迟队列&lt;/h1&gt;
&lt;p&gt;#缓存 #redis #队列&lt;/p&gt;
&lt;h2 id=&quot;带有延迟功能的消息队列&quot;&gt;&lt;a class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/Redis%E9%94%81/"/>
    <id>https://jinguo.tech/2022/01/14/Redis%E9%94%81/</id>
    <published>2022-01-13T18:02:14.285Z</published>
    <updated>2021-12-14T11:52:10.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis锁"><a class="header-anchor" href="#Redis锁"></a>Redis锁</h1><p>#redis  #分布式锁</p><h2 id="项目应用"><a class="header-anchor" href="#项目应用"></a>项目应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不存在(为空)就set值，并返回1；如果存在(不为空)不进行操作，并返回0</span></span><br><span class="line">Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, String.valueOf(System.currentTimeMillis()), seconds, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> success != <span class="keyword">null</span> &amp;&amp; success;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://xie.infoq.cn/article/556aaceb68789b9de4807f1c2" target="_blank" rel="noopener">Redis分布式锁原理</a><br><a href="https://juejin.cn/post/6901484610031452174" target="_blank" rel="noopener">Redis实现分布式锁</a><br><a href="https://blog.csdn.net/amosjob/article/details/99681707" target="_blank" rel="noopener">企业级分布式锁</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis锁&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Redis锁&quot;&gt;&lt;/a&gt;Redis锁&lt;/h1&gt;
&lt;p&gt;#redis  #分布式锁&lt;/p&gt;
&lt;h2 id=&quot;项目应用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#项
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/Presto%E5%BC%95%E6%93%8E/"/>
    <id>https://jinguo.tech/2022/01/14/Presto%E5%BC%95%E6%93%8E/</id>
    <published>2022-01-13T18:02:14.279Z</published>
    <updated>2021-12-14T12:03:25.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Presto引擎"><a class="header-anchor" href="#Presto引擎"></a>Presto引擎</h1><p>#presto</p><h2 id="Presto数据模型"><a class="header-anchor" href="#Presto数据模型"></a>Presto数据模型</h2><p>Presto使用Catalog、Schema和Table这3层结构来管理数据。</p><blockquote><p>** Catalog**:就是数据源。Hive是数据源，Mysql也是数据源，Hive 和Mysql都是数据源类型，可以连接多个Hive和多个Mysql，每个连接都有一个名字。一个Catalog可以包含多个Schema，大家可以通过show catalogs 命令看到Presto连接的所有数据源。<br>** Schema**：相当于一个数据库实例，一个Schema包含多张数据表。show schemas from 'catalog_name’可列出catalog_name下的所有schema。<br><strong>Table</strong>：数据表，与一般意义上的数据库表相同。show tables from 'catalog_name.schema_name’可查看’catalog_name.schema_name’下的所有表。</p></blockquote><blockquote><p>在Presto中定位一张表，一般是catalog为根，例如：一张表的全称为 hive.test_data.test，标识 hive(catalog)下的 test_data(schema)中test表。可以简理解为：数据源的大类.数据库.数据表。</p></blockquote><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="http://blog.chinaunix.net/uid-31012107-id-5819785.html" target="_blank" rel="noopener">Presto入门介绍</a><br><a href="https://www.alibabacloud.com/help/zh/doc-detail/166150.htm" target="_blank" rel="noopener">Presto数据源</a><br><a href="https://cloud.tencent.com/developer/article/1630733" target="_blank" rel="noopener">Presto查询引擎及原理分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Presto引擎&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Presto引擎&quot;&gt;&lt;/a&gt;Presto引擎&lt;/h1&gt;
&lt;p&gt;#presto&lt;/p&gt;
&lt;h2 id=&quot;Presto数据模型&quot;&gt;&lt;a class=&quot;header-anchor&quot; hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/OKHttp%E5%8E%9F%E7%90%86/"/>
    <id>https://jinguo.tech/2022/01/14/OKHttp%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-13T18:02:14.272Z</published>
    <updated>2021-12-14T15:39:18.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OKHttp原理"><a class="header-anchor" href="#OKHttp原理"></a>OKHttp原理</h1><p>#http</p><h2 id="原理概述"><a class="header-anchor" href="#原理概述"></a>原理概述</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1136954/1629450431169-f6cf4ce4-1a30-4f9f-98de-af6e4dcf12f0.webp" alt="okhttp原理"></p><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://juejin.cn/post/6968773787374321677?utm_source=gold_browser_extension" target="_blank" rel="noopener">探索 OkHttp 原理 - 掘金</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OKHttp原理&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#OKHttp原理&quot;&gt;&lt;/a&gt;OKHttp原理&lt;/h1&gt;
&lt;p&gt;#http&lt;/p&gt;
&lt;h2 id=&quot;原理概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#原理概
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jinguo.tech/2022/01/14/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <id>https://jinguo.tech/2022/01/14/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</id>
    <published>2022-01-13T18:02:14.266Z</published>
    <updated>2021-12-13T16:57:25.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h1><p>#mysql #执行计划</p><h2 id="Explain-用途"><a class="header-anchor" href="#Explain-用途"></a><code>Explain</code> 用途</h2><ol><li>表的读取顺序如何</li><li>数据读取操作有哪些操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间是如何引用</li><li>每张表有多少行被优化器查询</li></ol><h2 id="Explain语法"><a class="header-anchor" href="#Explain语法"></a><code>Explain</code>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><p><a href="https://blog.csdn.net/Dreamhai/article/details/104558854" target="_blank" rel="noopener">MySQL查询优化之explain 执行计划</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;
&lt;p&gt;#mysql #执行计划&lt;/p&gt;
&lt;h2 id=&quot;Explain-用途&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
