{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/bg.png","path":"images/bg.png","modified":1,"renderable":0},{"_id":"source/uploads/avatar.png","path":"uploads/avatar.png","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"source/images/bg1.png","path":"images/bg1.png","modified":1,"renderable":0},{"_id":"source/images/error-img.png","path":"images/error-img.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon1-16x16-next.png","path":"images/favicon1-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon1-32x32-next.png","path":"images/favicon1-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579661210378},{"_id":"source/404.html","hash":"993d04364c2f9c325762cb1788ef94a8872dc16a","modified":1579661210377},{"_id":"source/CNAME","hash":"a5b0be4f4ad89b0e64bf556000b935ebf8ccd186","modified":1579661210378},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1569736653051},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1569736653052},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1569736653052},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1569736653054},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1569736653055},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1569736653055},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1569736653056},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1569736653056},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1569736653057},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1569736653057},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1569736653058},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1569736653058},{"_id":"themes/next/_config.yml","hash":"b89a19b9f50affab00438b1d22b034cf30426f6d","modified":1579682579575},{"_id":"themes/next/_config.yml.bak","hash":"fbb950aa72618bb3adf47ce9f013c727ae18df6a","modified":1579680252426},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1569736653059},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1569736653060},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1569736653107},{"_id":"source/_posts/Netty笔记.md","hash":"bc447fe99b5805583555823d167dfd226a415864","modified":1579661210379},{"_id":"source/_posts/RocketMQ-上.md","hash":"9030f22f75ed077f3b021b5e76de1d1781d8788e","modified":1579661210380},{"_id":"source/_posts/storm-心得.md","hash":"c2f73990282cd62c91624b1968e115106b61b247","modified":1579661210381},{"_id":"source/_posts/假期学习计划.md","hash":"11e52bb37cd014a24f5a137c6cd80b41b7f81ffd","modified":1579681317926},{"_id":"source/about/index.md","hash":"575625d36c4a1c21e7eaf9a841392ec13295db6a","modified":1579661210382},{"_id":"source/css/style.css","hash":"314be3e203d0b90fc9af415ced60772f1108bf7f","modified":1579661210384},{"_id":"source/categories/index.md","hash":"8f3ad02d53b10b520042a734839215dd5eef1974","modified":1579661210383},{"_id":"source/images/bg.png","hash":"2f4aae91b44d6bd3d2cad99e7f5d1e0d47feb177","modified":1579661210385},{"_id":"source/tags/index.md","hash":"c36cf2dbaf89a5ec92c2d5e410c36d504b5a2323","modified":1579661210388},{"_id":"source/uploads/avatar.png","hash":"a4c6d3db8cba49934db18cae77455913fac46c5c","modified":1579661210389},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1569736653053},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1569736653053},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1569736653054},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1569736653054},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1569736653061},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1569736653061},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1569736653062},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1569736653062},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1569736653063},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1569736653063},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1569736653064},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1569736653064},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1569736653064},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1569736653065},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1569736653066},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1569736653065},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1569736653067},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1574047010217},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1569736653068},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1569736653068},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1569736653070},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1569736653105},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1569736653105},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1569736653105},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1569736653106},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1569736653106},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1569736653107},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1569736653107},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1569736653108},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1569736653109},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1569736653264},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1569736653265},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1569736653265},{"_id":"themes/next/source/404.html","hash":"ff6e56d030a30fcce827d21bf730f7807121b8cc","modified":1569743774790},{"_id":"source/images/bg1.png","hash":"4e50f8ae42d7dd04f12d588527eedd295b8837f4","modified":1579661210386},{"_id":"source/images/error-img.png","hash":"88240ff54335cf442180ecc3d311ea6a4bfccbff","modified":1579661210387},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653171},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1569736653069},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1569736653070},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1569736653071},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1579154509257},{"_id":"themes/next/layout/_macro/post.swig","hash":"afbe5342c51e1f40a5c1f8a0f6a1529dab7f1a9c","modified":1578297218683},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1569736653072},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1569736653073},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1569736653073},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1569736653074},{"_id":"themes/next/layout/_partials/footer - backup.swig","hash":"6a501a1cc151424fa096ccc4107438c77ff52e08","modified":1574410326381},{"_id":"themes/next/layout/_partials/footer.swig","hash":"9bcfb78fafea68872fd2a676ff2cbc20a0618efa","modified":1575272788571},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1569736653075},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1569736653076},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1569736653077},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1569736653077},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1569736653078},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1569736653082},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1569736653083},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1569736653086},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1569736653097},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1569736653097},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1569736653098},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1569736653098},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1569736653099},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1569736653100},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1569736653099},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1569736653110},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1569736653110},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1569736653111},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1569736653111},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1569736653112},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1569736653112},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1569736653113},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1569736653113},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1569736653114},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1569736653171},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1569736653172},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1569736653173},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1569736653174},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1569736653173},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1569736653175},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1569736653175},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1569736653176},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1569736653176},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1569736653177},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1569736653177},{"_id":"themes/next/source/images/favicon1-16x16-next.png","hash":"c620e67dd35f74d01020d7d4446f02450adf1083","modified":1579153765309},{"_id":"themes/next/source/images/favicon1-32x32-next.png","hash":"579ebb07b96fbd07539f12d1e06944e9e8e5e9e5","modified":1579153862730},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569736653178},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1569736653178},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569736653179},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1569736653179},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1569736653179},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1569736653180},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1569736653177},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653085},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653085},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653153},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653153},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653154},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653169},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569736653170},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1569736653174},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1569736653076},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1569736653076},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1569736653078},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1569736653079},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1569736653079},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1569736653080},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1569736653081},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1569736653081},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1569736653083},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1569736653084},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1569736653085},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1569736653087},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1569736653087},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1569736653088},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"16cb23818909f57dac1a5ada66869971c33d7bd8","modified":1574406432825},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1569736653088},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1569736653089},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1569736653089},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1569736653090},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1569736653090},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1569736653091},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1569736653092},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1569736653091},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1569736653092},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1569736653093},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1569736653094},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1569736653094},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1569736653094},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1569736653095},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1569736653096},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1569736653096},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1569736653095},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1569736653097},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1569736653102},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1569736653103},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1569736653103},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1569736653104},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1569736653081},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1569736653152},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1569736653153},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1569736653154},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1569736653154},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1569736653168},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1569736653169},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1569736653170},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1569736653181},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1569736653181},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1569736653182},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1569736653182},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1569736653183},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1569736653183},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1569736653184},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1569736653185},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1569736653186},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1569736653186},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1569736653187},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1569736653168},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1569736653195},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1569736653199},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1569736653200},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1569736653200},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1569736653201},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1569736653210},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1569736653210},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1569736653211},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1569736653211},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1569736653214},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1569736653214},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1569736653214},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1569736653215},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1569736653220},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1569736653237},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1569736653239},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1569736653239},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1569736653240},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1569736653240},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1569736653241},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1569736653241},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1569736653242},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1569736653243},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1569736653243},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1569736653244},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1569736653245},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1569736653245},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1569736653245},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1569736653246},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1569736653247},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1569736653247},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1569736653248},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1569736653248},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1569736653249},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1569736653249},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1569736653250},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1569736653250},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1569736653251},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1569736653252},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1569736653252},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1569736653253},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1569736653259},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1569736653260},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1569736653262},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1569736653263},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1569736653263},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1569736653238},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1569736653101},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1569736653102},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1569736653148},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1569736653115},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1569736653116},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1569736653116},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1569736653117},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1569736653117},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1569736653126},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1569736653138},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1569736653149},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1569736653149},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1569736653150},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1569736653150},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1569736653151},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1569736653151},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1569736653155},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1569736653156},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1569736653157},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1569736653157},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1569736653158},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1569736653158},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1569736653158},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1569736653159},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1569736653161},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1569736653161},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1569736653162},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1569736653162},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1569736653163},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1569736653165},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1569736653165},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1569736653166},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1569736653166},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1569736653167},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1569736653167},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1569736653185},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1569736653191},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1569736653193},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1569736653194},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1569736653201},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1569736653202},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1569736653202},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1569736653203},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1569736653203},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1569736653204},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1569736653208},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1569736653209},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1569736653209},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1569736653212},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1569736653213},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1569736653221},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1569736653222},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1569736653258},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1569736653259},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1569736653192},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1569736653223},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569736653235},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569736653236},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1569736653262},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1569736653118},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1569736653119},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1569736653119},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1569736653119},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1569736653120},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1569736653120},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1569736653122},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1569736653121},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1569736653123},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1569736653123},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1569736653124},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1569736653124},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1569736653125},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1569736653125},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1569736653126},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1569736653127},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1569736653127},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1569736653128},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1569736653128},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1569736653129},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1569736653129},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1569736653130},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1569736653131},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1569736653130},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1569736653131},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1569736653132},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1569736653132},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1569736653133},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a367383693bc8edfd4c1ef971c3071d4f8e55794","modified":1578297169561},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1569736653134},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e2953a79df0e03459178375b60212916aee787cf","modified":1569745534762},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1569736653135},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1569736653135},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1569736653136},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1569736653136},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1569736653137},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1569736653137},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1569736653137},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1569736653138},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1569736653139},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1569736653139},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1569736653140},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1569736653140},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1569736653141},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1569736653141},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1569736653142},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1569736653142},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1569736653142},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1569736653143},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1569736653144},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1569736653144},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1569736653144},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1569736653145},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1569736653145},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1569736653146},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1569736653147},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1569736653147},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1569736653147},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1569736653160},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1569736653160},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1569736653164},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1569736653189},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1569736653189},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1569736653190},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1569736653190},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1569736653191},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1569736653205},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1569736653205},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1569736653206},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1569736653206},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1569736653207},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1569736653207},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569736653226},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569736653234},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569736653228},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1569736653198},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1569736653256},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1569736653232},{"_id":"public/css/style.css","hash":"f78df8200f68cd88c064d3d6a64debbb82c2223f","modified":1579682646837},{"_id":"public/baidusitemap.xml","hash":"758e2f05687d50f367565088250d66e0df5507b0","modified":1579682646864},{"_id":"public/search.xml","hash":"c3743ef59ee206f5f38e9b96a75e9b4871cb59b7","modified":1579682646868},{"_id":"public/sitemap.xml","hash":"94f05d72920165df8e8c22f21f517e30e2230dfc","modified":1579682646891},{"_id":"public/404.html","hash":"d9040b57bbc86bac78794ef510aa68b119458d1f","modified":1579682647106},{"_id":"public/about/index.html","hash":"1ee6cfc2b1cdebd0dcf395037ceb4659253fff7a","modified":1579682647107},{"_id":"public/categories/index.html","hash":"2944b916e61ac274b83f19e6ed0d9f6aff00d009","modified":1579682647107},{"_id":"public/tags/index.html","hash":"bd35de01e3ac588c3ccd25d6a2ff1981ccc522b8","modified":1579682647108},{"_id":"public/2020/01/22/假期学习计划/index.html","hash":"eddc9949ac79becfbb568a7d14461dd0acc286fc","modified":1579682647108},{"_id":"public/2020/01/16/storm-心得/index.html","hash":"b96a668a010b9c5fe47780c487fd1df53a164ffa","modified":1579682647108},{"_id":"public/2020/01/16/Netty笔记/index.html","hash":"e4fb8f8901043f32b7016afb4cbe0b0d331b3b1a","modified":1579682647108},{"_id":"public/2020/01/16/RocketMQ-上/index.html","hash":"baece95a97a07d5308ab494983ccf182859708a1","modified":1579682647109},{"_id":"public/archives/index.html","hash":"c8afc9375cf085f8267bcf0a63679b22bbe9ac5d","modified":1579682647109},{"_id":"public/archives/2020/index.html","hash":"b8edc5f504303bbf8422b270e6158d2644711fc4","modified":1579682647109},{"_id":"public/archives/2020/01/index.html","hash":"7aceab379a3626b1b1d814208df934f4696df162","modified":1579682647109},{"_id":"public/index.html","hash":"223fc4e9c2cad32db73337a17fa80e6edd9d1e60","modified":1579682647110},{"_id":"public/categories/Java/index.html","hash":"efd347607fc470c30dec80acef0778de5800cfc1","modified":1579682647110},{"_id":"public/categories/大数据/index.html","hash":"b4384b4b1fbddeec6ecdb02fdf28127279a63820","modified":1579682647110},{"_id":"public/tags/MQ/index.html","hash":"6dec328f50637771b5d8be1fa9f5bfe5f8a0a8ef","modified":1579682647110},{"_id":"public/tags/Netty/index.html","hash":"1b8ab9f670fed1db67897552010682493676e24f","modified":1579682647110},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579682647110},{"_id":"public/tags/Storm/index.html","hash":"ebfa0fa1e346ecccdda5e08a21b48a8b5c1fe9b8","modified":1579682647170},{"_id":"public/CNAME","hash":"a5b0be4f4ad89b0e64bf556000b935ebf8ccd186","modified":1579682647171},{"_id":"public/images/bg.png","hash":"2f4aae91b44d6bd3d2cad99e7f5d1e0d47feb177","modified":1579682647171},{"_id":"public/uploads/avatar.png","hash":"a4c6d3db8cba49934db18cae77455913fac46c5c","modified":1579682647172},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1579682647173},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1579682647174},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1579682647174},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1579682647174},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1579682647175},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1579682647175},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1579682647175},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1579682647175},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1579682647176},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1579682647176},{"_id":"public/images/favicon1-16x16-next.png","hash":"c620e67dd35f74d01020d7d4446f02450adf1083","modified":1579682647177},{"_id":"public/images/favicon1-32x32-next.png","hash":"579ebb07b96fbd07539f12d1e06944e9e8e5e9e5","modified":1579682647178},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579682647178},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1579682647179},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1579682647179},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1579682647179},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1579682647180},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1579682647180},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1579682647180},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1579682647180},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1579682647180},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1579682647180},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1579682647180},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1579682647181},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1579682647181},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1579682647181},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1579682647182},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1579682647182},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1579682647182},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1579682647183},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1579682647185},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1579682647185},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1579682647186},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1579682647186},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1579682647186},{"_id":"public/live2dw/assets/mtn/00_idle.mtn","hash":"b224c60e463b9f71ddbfc0c720e430496c175f4f","modified":1579682647187},{"_id":"public/live2dw/assets/mtn/01.mtn","hash":"fb550833ae22c9954c3e01df37ed29b2d61700f2","modified":1579682647187},{"_id":"public/live2dw/assets/mtn/02.mtn","hash":"7eafc52edc73b7cb80ae70d34b43c6ac778fa47b","modified":1579682647187},{"_id":"public/live2dw/assets/mtn/04.mtn","hash":"c7a25d3c5d783639bae18db2f3cd284b819c3c85","modified":1579682647188},{"_id":"public/live2dw/assets/mtn/03.mtn","hash":"f900737c7a98441cbb2e05255427e6260e19ae68","modified":1579682647188},{"_id":"public/live2dw/assets/mtn/05.mtn","hash":"dd20ad24b5d1830a5d44b9bccb28f922eea5e0e5","modified":1579682647188},{"_id":"public/live2dw/assets/mtn/06.mtn","hash":"ad404bd852d276cdd3d054c953e23f90e4e45ae1","modified":1579682647189},{"_id":"public/live2dw/assets/mtn/07.mtn","hash":"b7f2e3a9fa4f3ffbb6e64a08f8d9f45ca1868ffb","modified":1579682647189},{"_id":"public/live2dw/assets/mtn/08.mtn","hash":"4411c7651ff65195b113d95e7d5ebef8a59a37d9","modified":1579682647190},{"_id":"public/live2dw/assets/tororo.model.json","hash":"3b96ea33460642d288c98327444966d93a0c11ba","modified":1579682647191},{"_id":"public/live2dw/assets/tororo.pose.json","hash":"81438bf69b32c7c11e311b4fe043730cdc7b7ec2","modified":1579682647191},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1579682647192},{"_id":"public/images/error-img.png","hash":"88240ff54335cf442180ecc3d311ea6a4bfccbff","modified":1579682650362},{"_id":"public/images/bg1.png","hash":"4e50f8ae42d7dd04f12d588527eedd295b8837f4","modified":1579682650379},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1579682650386},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1579682650432},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1579682650433},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1579682650434},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1579682650434},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1579682650434},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1579682650435},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1579682650441},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1579682650441},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1579682650442},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1579682650442},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1579682650442},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1579682650442},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1579682650442},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1579682650442},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1579682650443},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1579682650443},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1579682650443},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1579682650443},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1579682650443},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1579682650444},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1579682650444},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1579682650444},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1579682650445},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1579682650445},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1579682650446},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1579682650446},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1579682650446},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1579682650446},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1579682650447},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1579682650447},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1579682650447},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1579682650447},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1579682650448},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1579682650448},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1579682650448},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1579682650448},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1579682650448},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1579682650448},{"_id":"public/lib/fastclick/README.html","hash":"7a6fa40c87009a0f0642b9f2305bc2f7c17e5e51","modified":1579682650448},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"f1d1549099174206f404343b17a9f9361fa00cab","modified":1579682650448},{"_id":"public/lib/jquery_lazyload/README.html","hash":"6854cec50bf1f4f7309a0397341c412a44e407c5","modified":1579682650448},{"_id":"public/css/main.css","hash":"86660243fe84eb16ff7f99f76871c32ae010c8d4","modified":1579682650448},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1579682650449},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1579682650449},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1579682650449},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1579682650450},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1579682650450},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1579682650538},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1579682650539},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1579682650540},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1579682650541},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1579682650541},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1579682650541},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1579682650544},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1579682650545},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1579682650546},{"_id":"public/live2dw/assets/moc/tororo.moc","hash":"44289e62545a7046e0f5231103a851750b78524e","modified":1579682650547},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1579682650690},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1579682650691},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1579682650712},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1579682650712},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1579682650735},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1579682650736},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1579682650740},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1579682650741},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1579682650741},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1579682650741},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1579682650741},{"_id":"public/live2dw/assets/moc/tororo.2048/texture_00.png","hash":"98af764b541083e87fc2f8e85f02d2db38c898cc","modified":1579682650742},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1579682650791},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1579682650791},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1579682650875},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1579682650875},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1579682650974},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1579682650975},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1579682650975},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1579682650975},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1579682651151},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1579682651219},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1579682651237}],"Category":[{"name":"Java","_id":"ck5p297pv0005bg0rgp5jwo1v"},{"name":"大数据","_id":"ck5p298pq000gbg0rg1mf7fmg"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n\t<head>\n\t\t<title>架构师成长之旅 | Home :: jinguo.tech</title>\n\t\t<meta name=\"keywords\" content=\"404\" />\n\t\t<link href=\"./css/style.css\" rel=\"stylesheet\" type=\"text/css\"  media=\"all\" />\n\t</head>\n\t<body>\n\t\t<!--start-wrap--->\n\t\t<div class=\"wrap\">\n\t\t\t<!--start-content------>\n\t\t\t<div class=\"content\">\n\t\t\t\t<img src=\"./images/error-img.png\" title=\"error\" />\n\t\t\t\t<p><span><label>O</label>MG.....</span>You Requested for the page that is no longer There.</p>\n\t\t\t\t<a href=\"https://jinguo.tech\">Back To Home</a>\n\t\t\t\t<div class=\"copy-right\">\n\t\t\t\t\t<p>&#169 All rights Reserved Designed | 2019 Nov <a href=\"https://jinguo.tech\"></a></p>\n\t\t\t\t</div>\n   \t\t\t</div>\n\t\t\t<!--End-Cotent------>\n\t\t</div>\n\t\t<!--End-wrap--->\n\t</body>\n</html>\n\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n\t<head>\n\t\t<title>架构师成长之旅 | Home :: jinguo.tech</title>\n\t\t<meta name=\"keywords\" content=\"404\" />\n\t\t<link href=\"./css/style.css\" rel=\"stylesheet\" type=\"text/css\"  media=\"all\" />\n\t</head>\n\t<body>\n\t\t<!--start-wrap--->\n\t\t<div class=\"wrap\">\n\t\t\t<!--start-content------>\n\t\t\t<div class=\"content\">\n\t\t\t\t<img src=\"./images/error-img.png\" title=\"error\" />\n\t\t\t\t<p><span><label>O</label>MG.....</span>You Requested for the page that is no longer There.</p>\n\t\t\t\t<a href=\"https://jinguo.tech\">Back To Home</a>\n\t\t\t\t<div class=\"copy-right\">\n\t\t\t\t\t<p>&#169 All rights Reserved Designed | 2019 Nov <a href=\"https://jinguo.tech\"></a></p>\n\t\t\t\t</div>\n   \t\t\t</div>\n\t\t\t<!--End-Cotent------>\n\t\t</div>\n\t\t<!--End-wrap--->\n\t</body>\n</html>\n\n","date":"2020-01-22T07:12:43.902Z","updated":"2020-01-22T02:46:50.377Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ck5p297kf0000bg0rjtpahz8p","content":"<!DOCTYPE HTML>\n<html>\n\t<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n\t\t<title>架构师成长之旅 | Home :: jinguo.tech</title>\n\t\t<meta name=\"keywords\" content=\"404\">\n\t\t<link href=\"./css/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\">\n\t</head>\n\t<body>\n\t\t<!--start-wrap--->\n\t\t<div class=\"wrap\">\n\t\t\t<!--start-content------>\n\t\t\t<div class=\"content\">\n\t\t\t\t<img src=\"./images/error-img.png\" title=\"error\">\n\t\t\t\t<p><span><label>O</label>MG.....</span>You Requested for the page that is no longer There.</p>\n\t\t\t\t<a href=\"https://jinguo.tech\">Back To Home</a>\n\t\t\t\t<div class=\"copy-right\">\n\t\t\t\t\t<p>&#169 All rights Reserved Designed | 2019 Nov <a href=\"https://jinguo.tech\"></a></p>\n\t\t\t\t</div>\n   \t\t\t</div>\n\t\t\t<!--End-Cotent------>\n\t\t</div>\n\t\t<!--End-wrap--->\n\t<script src=\"/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05\"></script><script>L2Dwidget.init({\"model\":{\"jsonPath\":\"/live2dw/assets/tororo.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});</script></body>\n</html>\n\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n\t<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n\t\t<title>架构师成长之旅 | Home :: jinguo.tech</title>\n\t\t<meta name=\"keywords\" content=\"404\">\n\t\t<link href=\"./css/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\">\n\t</head>\n\t<body>\n\t\t<!--start-wrap--->\n\t\t<div class=\"wrap\">\n\t\t\t<!--start-content------>\n\t\t\t<div class=\"content\">\n\t\t\t\t<img src=\"./images/error-img.png\" title=\"error\">\n\t\t\t\t<p><span><label>O</label>MG.....</span>You Requested for the page that is no longer There.</p>\n\t\t\t\t<a href=\"https://jinguo.tech\">Back To Home</a>\n\t\t\t\t<div class=\"copy-right\">\n\t\t\t\t\t<p>&#169 All rights Reserved Designed | 2019 Nov <a href=\"https://jinguo.tech\"></a></p>\n\t\t\t\t</div>\n   \t\t\t</div>\n\t\t\t<!--End-Cotent------>\n\t\t</div>\n\t\t<!--End-wrap--->\n\t<script src=\"/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05\"></script><script>L2Dwidget.init({\"model\":{\"jsonPath\":\"/live2dw/assets/tororo.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});</script></body>\n</html>\n\n"},{"title":"about","date":"2019-09-29T07:43:32.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-09-29 15:43:32\n---\n","updated":"2020-01-22T02:46:50.382Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck5p297pf0002bg0rppd4qlt2","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"/* reset */\nhtml,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,dl,dt,dd,ol,nav ul,nav li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;}\narticle, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section {display: block;}\nol,ul{list-style:none;margin:0px;padding:0px;}\nblockquote,q{quotes:none;}\nblockquote:before,blockquote:after,q:before,q:after{content:'';content:none;}\ntable{border-collapse:collapse;border-spacing:0;}\n/* start editing from here */\na{text-decoration:none;}\n.txt-rt{text-align:right;}/* text align right */\n.txt-lt{text-align:left;}/* text align left */\n.txt-center{text-align:center;}/* text align center */\n.float-rt{float:right;}/* float right */\n.float-lt{float:left;}/* float left */\n.clear{clear:both;}/* clear float */\n.pos-relative{position:relative;}/* Position Relative */\n.pos-absolute{position:absolute;}/* Position Absolute */\n.vertical-base{\tvertical-align:baseline;}/* vertical align baseline */\n.vertical-top{\tvertical-align:top;}/* vertical align top */\n.underline{\tpadding-bottom:5px;\tborder-bottom: 1px solid #eee; margin:0 0 20px 0;}/* Add 5px bottom padding and a underline */\nnav.vertical ul li{\tdisplay:block;}/* vertical menu */\nnav.horizontal ul li{\tdisplay: inline-block;}/* horizontal menu */\nimg{max-width:100%;}\n/*end reset*\n */\nbody{\n\tbackground: url(../images/bg1.png);\n\tfont-family: \"Century Gothic\",Arial, Helvetica, sans-serif;\n\t}\n.content p{\n\tmargin: 18px 0px 45px 0px;\n}\n.content p{\n\tfont-family: \"Century Gothic\";\n\tfont-size:2em;\n\tcolor:#666;\n\ttext-align:center;\n}\n.content p span,.logo h1 a{\n\tcolor:#e54040;\n}\n.content{\n\ttext-align:center;\n\tpadding:115px 0px 0px 0px;\n}\n.content a{\n\tcolor:#fff;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\n\tpadding: 15px 20px;\n\tborder-radius: 1em;\n}\n.content a:hover{\n\tcolor:#e54040;\n}\n.logo{\n\ttext-align:center;\n\t-webkit-box-shadow: 0 8px 6px -6px rgb(97, 97, 97);\n\t-moz-box-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n\tbox-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n}\n.logo h1{\n\tfont-size:2em;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\t\n\tpadding: 10px 10px 18px 10px;\n}\n.logo h1 a{\n\tfont-size:1em;\n}\n.copy-right{\n\tpadding-top:20px;\n}\n.copy-right p{\n\tfont-size:0.9em;\n}\n.copy-right p a{\n\tbackground:none;\n\tcolor:#e54040;\n\tpadding:0px 0px 5px 0px;\n\tfont-size:0.9em;\n}\n.copy-right p a:hover{\n\tcolor:#666;\n}\n/*------responive-design--------*/\n@media screen and (max-width: 1366px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1280px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1024px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.5em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t\t\n\t}\n}\n@media screen and (max-width:640px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.3em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t}\n}\n@media screen and (max-width:460px)\t{\n\t.content {\n\t\tpadding:20px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content p {\n\t\tfont-size:0.9em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.8em;\n\t}\n}\n@media screen and (max-width:320px)\t{\n\t.content {\n\t\tpadding:30px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content a {\n\t\tpadding:10px 15px;\n\t\tfont-size:0.8em;\n\t}\n\t.content p {\n\t\tmargin: 18px 0px 22px 0px;\n\t}\n}","source":"css/style.css","raw":"/* reset */\nhtml,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,dl,dt,dd,ol,nav ul,nav li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;}\narticle, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section {display: block;}\nol,ul{list-style:none;margin:0px;padding:0px;}\nblockquote,q{quotes:none;}\nblockquote:before,blockquote:after,q:before,q:after{content:'';content:none;}\ntable{border-collapse:collapse;border-spacing:0;}\n/* start editing from here */\na{text-decoration:none;}\n.txt-rt{text-align:right;}/* text align right */\n.txt-lt{text-align:left;}/* text align left */\n.txt-center{text-align:center;}/* text align center */\n.float-rt{float:right;}/* float right */\n.float-lt{float:left;}/* float left */\n.clear{clear:both;}/* clear float */\n.pos-relative{position:relative;}/* Position Relative */\n.pos-absolute{position:absolute;}/* Position Absolute */\n.vertical-base{\tvertical-align:baseline;}/* vertical align baseline */\n.vertical-top{\tvertical-align:top;}/* vertical align top */\n.underline{\tpadding-bottom:5px;\tborder-bottom: 1px solid #eee; margin:0 0 20px 0;}/* Add 5px bottom padding and a underline */\nnav.vertical ul li{\tdisplay:block;}/* vertical menu */\nnav.horizontal ul li{\tdisplay: inline-block;}/* horizontal menu */\nimg{max-width:100%;}\n/*end reset*\n */\nbody{\n\tbackground: url(../images/bg1.png);\n\tfont-family: \"Century Gothic\",Arial, Helvetica, sans-serif;\n\t}\n.content p{\n\tmargin: 18px 0px 45px 0px;\n}\n.content p{\n\tfont-family: \"Century Gothic\";\n\tfont-size:2em;\n\tcolor:#666;\n\ttext-align:center;\n}\n.content p span,.logo h1 a{\n\tcolor:#e54040;\n}\n.content{\n\ttext-align:center;\n\tpadding:115px 0px 0px 0px;\n}\n.content a{\n\tcolor:#fff;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\n\tpadding: 15px 20px;\n\tborder-radius: 1em;\n}\n.content a:hover{\n\tcolor:#e54040;\n}\n.logo{\n\ttext-align:center;\n\t-webkit-box-shadow: 0 8px 6px -6px rgb(97, 97, 97);\n\t-moz-box-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n\tbox-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n}\n.logo h1{\n\tfont-size:2em;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\t\n\tpadding: 10px 10px 18px 10px;\n}\n.logo h1 a{\n\tfont-size:1em;\n}\n.copy-right{\n\tpadding-top:20px;\n}\n.copy-right p{\n\tfont-size:0.9em;\n}\n.copy-right p a{\n\tbackground:none;\n\tcolor:#e54040;\n\tpadding:0px 0px 5px 0px;\n\tfont-size:0.9em;\n}\n.copy-right p a:hover{\n\tcolor:#666;\n}\n/*------responive-design--------*/\n@media screen and (max-width: 1366px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1280px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1024px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.5em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t\t\n\t}\n}\n@media screen and (max-width:640px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.3em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t}\n}\n@media screen and (max-width:460px)\t{\n\t.content {\n\t\tpadding:20px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content p {\n\t\tfont-size:0.9em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.8em;\n\t}\n}\n@media screen and (max-width:320px)\t{\n\t.content {\n\t\tpadding:30px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content a {\n\t\tpadding:10px 15px;\n\t\tfont-size:0.8em;\n\t}\n\t.content p {\n\t\tmargin: 18px 0px 22px 0px;\n\t}\n}","date":"2020-01-22T07:12:43.928Z","updated":"2020-01-22T02:46:50.384Z","path":"css/style.css","layout":"false","title":"","comments":1,"_id":"ck5p297pp0004bg0rxl0avopd","content":"/* reset */\nhtml,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,dl,dt,dd,ol,nav ul,nav li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;}\narticle, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section {display: block;}\nol,ul{list-style:none;margin:0px;padding:0px;}\nblockquote,q{quotes:none;}\nblockquote:before,blockquote:after,q:before,q:after{content:'';content:none;}\ntable{border-collapse:collapse;border-spacing:0;}\n/* start editing from here */\na{text-decoration:none;}\n.txt-rt{text-align:right;}/* text align right */\n.txt-lt{text-align:left;}/* text align left */\n.txt-center{text-align:center;}/* text align center */\n.float-rt{float:right;}/* float right */\n.float-lt{float:left;}/* float left */\n.clear{clear:both;}/* clear float */\n.pos-relative{position:relative;}/* Position Relative */\n.pos-absolute{position:absolute;}/* Position Absolute */\n.vertical-base{\tvertical-align:baseline;}/* vertical align baseline */\n.vertical-top{\tvertical-align:top;}/* vertical align top */\n.underline{\tpadding-bottom:5px;\tborder-bottom: 1px solid #eee; margin:0 0 20px 0;}/* Add 5px bottom padding and a underline */\nnav.vertical ul li{\tdisplay:block;}/* vertical menu */\nnav.horizontal ul li{\tdisplay: inline-block;}/* horizontal menu */\nimg{max-width:100%;}\n/*end reset*\n */\nbody{\n\tbackground: url(../images/bg1.png);\n\tfont-family: \"Century Gothic\",Arial, Helvetica, sans-serif;\n\t}\n.content p{\n\tmargin: 18px 0px 45px 0px;\n}\n.content p{\n\tfont-family: \"Century Gothic\";\n\tfont-size:2em;\n\tcolor:#666;\n\ttext-align:center;\n}\n.content p span,.logo h1 a{\n\tcolor:#e54040;\n}\n.content{\n\ttext-align:center;\n\tpadding:115px 0px 0px 0px;\n}\n.content a{\n\tcolor:#fff;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\n\tpadding: 15px 20px;\n\tborder-radius: 1em;\n}\n.content a:hover{\n\tcolor:#e54040;\n}\n.logo{\n\ttext-align:center;\n\t-webkit-box-shadow: 0 8px 6px -6px rgb(97, 97, 97);\n\t-moz-box-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n\tbox-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n}\n.logo h1{\n\tfont-size:2em;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\t\n\tpadding: 10px 10px 18px 10px;\n}\n.logo h1 a{\n\tfont-size:1em;\n}\n.copy-right{\n\tpadding-top:20px;\n}\n.copy-right p{\n\tfont-size:0.9em;\n}\n.copy-right p a{\n\tbackground:none;\n\tcolor:#e54040;\n\tpadding:0px 0px 5px 0px;\n\tfont-size:0.9em;\n}\n.copy-right p a:hover{\n\tcolor:#666;\n}\n/*------responive-design--------*/\n@media screen and (max-width: 1366px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1280px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1024px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.5em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t\t\n\t}\n}\n@media screen and (max-width:640px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.3em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t}\n}\n@media screen and (max-width:460px)\t{\n\t.content {\n\t\tpadding:20px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content p {\n\t\tfont-size:0.9em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.8em;\n\t}\n}\n@media screen and (max-width:320px)\t{\n\t.content {\n\t\tpadding:30px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content a {\n\t\tpadding:10px 15px;\n\t\tfont-size:0.8em;\n\t}\n\t.content p {\n\t\tmargin: 18px 0px 22px 0px;\n\t}\n}","site":{"data":{}},"excerpt":"","more":"/* reset */\nhtml,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,dl,dt,dd,ol,nav ul,nav li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;}\narticle, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section {display: block;}\nol,ul{list-style:none;margin:0px;padding:0px;}\nblockquote,q{quotes:none;}\nblockquote:before,blockquote:after,q:before,q:after{content:'';content:none;}\ntable{border-collapse:collapse;border-spacing:0;}\n/* start editing from here */\na{text-decoration:none;}\n.txt-rt{text-align:right;}/* text align right */\n.txt-lt{text-align:left;}/* text align left */\n.txt-center{text-align:center;}/* text align center */\n.float-rt{float:right;}/* float right */\n.float-lt{float:left;}/* float left */\n.clear{clear:both;}/* clear float */\n.pos-relative{position:relative;}/* Position Relative */\n.pos-absolute{position:absolute;}/* Position Absolute */\n.vertical-base{\tvertical-align:baseline;}/* vertical align baseline */\n.vertical-top{\tvertical-align:top;}/* vertical align top */\n.underline{\tpadding-bottom:5px;\tborder-bottom: 1px solid #eee; margin:0 0 20px 0;}/* Add 5px bottom padding and a underline */\nnav.vertical ul li{\tdisplay:block;}/* vertical menu */\nnav.horizontal ul li{\tdisplay: inline-block;}/* horizontal menu */\nimg{max-width:100%;}\n/*end reset*\n */\nbody{\n\tbackground: url(../images/bg1.png);\n\tfont-family: \"Century Gothic\",Arial, Helvetica, sans-serif;\n\t}\n.content p{\n\tmargin: 18px 0px 45px 0px;\n}\n.content p{\n\tfont-family: \"Century Gothic\";\n\tfont-size:2em;\n\tcolor:#666;\n\ttext-align:center;\n}\n.content p span,.logo h1 a{\n\tcolor:#e54040;\n}\n.content{\n\ttext-align:center;\n\tpadding:115px 0px 0px 0px;\n}\n.content a{\n\tcolor:#fff;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\n\tpadding: 15px 20px;\n\tborder-radius: 1em;\n}\n.content a:hover{\n\tcolor:#e54040;\n}\n.logo{\n\ttext-align:center;\n\t-webkit-box-shadow: 0 8px 6px -6px rgb(97, 97, 97);\n\t-moz-box-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n\tbox-shadow: 0 8px 6px -6px  rgb(97, 97, 97);\n}\n.logo h1{\n\tfont-size:2em;\n\tfont-family: \"Century Gothic\";\n\tbackground: #666666; /* Old browsers */\n\tbackground: -moz-linear-gradient(top,  #666666 0%, #666666 100%); /* FF3.6+ */\n\tbackground: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#666666), color-stop(100%,#666666)); /* Chrome,Safari4+ */\n\tbackground: -webkit-linear-gradient(top,  #666666 0%,#666666 100%); /* Chrome10+,Safari5.1+ */\n\tbackground: -o-linear-gradient(top,  #666666 0%,#666666 100%); /* Opera 11.10+ */\n\tbackground: -ms-linear-gradient(top,  #666666 0%,#666666 100%); /* IE10+ */\n\tbackground: linear-gradient(to bottom,  #666666 0%,#666666 100%); /* W3C */\n\tfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#666666', endColorstr='#666666',GradientType=0 ); /* IE6-9 */\t\n\tpadding: 10px 10px 18px 10px;\n}\n.logo h1 a{\n\tfont-size:1em;\n}\n.copy-right{\n\tpadding-top:20px;\n}\n.copy-right p{\n\tfont-size:0.9em;\n}\n.copy-right p a{\n\tbackground:none;\n\tcolor:#e54040;\n\tpadding:0px 0px 5px 0px;\n\tfont-size:0.9em;\n}\n.copy-right p a:hover{\n\tcolor:#666;\n}\n/*------responive-design--------*/\n@media screen and (max-width: 1366px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1280px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n}\n@media screen and (max-width:1024px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.5em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t\t\n\t}\n}\n@media screen and (max-width:640px)\t{\n\t.content {\n\t\tpadding: 58px 0px 0px 0px;\n\t}\n\t.content p {\n\t\tfont-size: 1.3em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.9em;\n\t}\n}\n@media screen and (max-width:460px)\t{\n\t.content {\n\t\tpadding:20px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content p {\n\t\tfont-size:0.9em;\n\t}\n\t.copy-right p{\n\t\tfont-size:0.8em;\n\t}\n}\n@media screen and (max-width:320px)\t{\n\t.content {\n\t\tpadding:30px 0px 0px 0px;\n\t\tmargin:0px 12px;\n\t}\n\t.content a {\n\t\tpadding:10px 15px;\n\t\tfont-size:0.8em;\n\t}\n\t.content p {\n\t\tmargin: 18px 0px 22px 0px;\n\t}\n}"},{"title":"categories","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ncomments: false\n---","date":"2020-01-22T07:12:43.924Z","updated":"2020-01-22T02:46:50.383Z","path":"categories/index.html","layout":"page","_id":"ck5p297q20007bg0rvzh7ie81","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ncomments: false\n---\n","date":"2020-01-22T07:12:43.948Z","updated":"2020-01-22T02:46:50.388Z","path":"tags/index.html","layout":"page","_id":"ck5p297q80008bg0rrzk4o5ib","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RocketMQ(上)","date":"2020-01-16T06:24:26.000Z","_content":"\n## 1. RocketMQ 是什么\n\n#### RocketMQ是一款[^低延迟的]、[^高可靠的]、[^可伸缩的]、易于使用的消息中间件\n\n[^低延迟的]: 响应时间低，比如一个网页在几秒内打开，越短表示延迟越低\n[^高可靠的]: 指的是运行时间能够满足预计时间的一个系统或组件\n[^可伸缩的]: 可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡\n\n\n\n#### RocketMQ具有以下特性\n\n- 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型\n- 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递\n- 支持拉（pull）和推（push）两种消息模式\n- 单一队列百万消息的堆积能力\n- 支持多种消息协议，如 JMS、MQTT 等\n- 分布式高可用的部署架构,满足至少一次消息传递语义\n- 提供 docker 镜像用于隔离测试和云集群部署\n- 提供配置、指标和监控等功能丰富的 Dashboard\n\n\n\n> ### Producer\n>\n> **消息生产者**，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。\n>\n> ### Producer Group\n>\n> **生产者组**，就是多个发送同一类消息的生产者称之为一个生产者组。\n\n\n\n> ### Consumer\n>\n> **消息消费者**，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。\n>\n> ### Consumer Group\n>\n> **消费者组**，消费同一类消息的多个 consumer 实例组成一个消费者组。\n\n\n\n> ### Topic\n>\n> *Topic* 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推\n>\n> ### Message\n>\n> *Message*是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。\n>\n> \n\n\n\n> ### Tag\n>\n> *Tag***标签**可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息\n>\n> ### Broker\n>\n> *Broker*是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备\n>\n> ### Name Server\n>\n> *Name Server* 为 producer 和 consumer 提供路由信息。\n\n\n\n","source":"_posts/RocketMQ-上.md","raw":"---\ntitle: RocketMQ(上)\ndate: 2020-01-16 14:24:26\ntags: MQ\ncategories: Java\n---\n\n## 1. RocketMQ 是什么\n\n#### RocketMQ是一款[^低延迟的]、[^高可靠的]、[^可伸缩的]、易于使用的消息中间件\n\n[^低延迟的]: 响应时间低，比如一个网页在几秒内打开，越短表示延迟越低\n[^高可靠的]: 指的是运行时间能够满足预计时间的一个系统或组件\n[^可伸缩的]: 可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡\n\n\n\n#### RocketMQ具有以下特性\n\n- 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型\n- 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递\n- 支持拉（pull）和推（push）两种消息模式\n- 单一队列百万消息的堆积能力\n- 支持多种消息协议，如 JMS、MQTT 等\n- 分布式高可用的部署架构,满足至少一次消息传递语义\n- 提供 docker 镜像用于隔离测试和云集群部署\n- 提供配置、指标和监控等功能丰富的 Dashboard\n\n\n\n> ### Producer\n>\n> **消息生产者**，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。\n>\n> ### Producer Group\n>\n> **生产者组**，就是多个发送同一类消息的生产者称之为一个生产者组。\n\n\n\n> ### Consumer\n>\n> **消息消费者**，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。\n>\n> ### Consumer Group\n>\n> **消费者组**，消费同一类消息的多个 consumer 实例组成一个消费者组。\n\n\n\n> ### Topic\n>\n> *Topic* 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推\n>\n> ### Message\n>\n> *Message*是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。\n>\n> \n\n\n\n> ### Tag\n>\n> *Tag***标签**可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息\n>\n> ### Broker\n>\n> *Broker*是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备\n>\n> ### Name Server\n>\n> *Name Server* 为 producer 和 consumer 提供路由信息。\n\n\n\n","slug":"RocketMQ-上","published":1,"updated":"2020-01-22T02:46:50.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5p297p20001bg0ra2esksxi","content":"<h2 id=\"1-RocketMQ-是什么\"><a class=\"header-anchor\" href=\"#1-RocketMQ-是什么\"></a>1. RocketMQ 是什么</h2>\n<h4 id=\"RocketMQ是一款、、、易于使用的消息中间件\"><a class=\"header-anchor\" href=\"#RocketMQ是一款、、、易于使用的消息中间件\"></a>RocketMQ是一款<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>、<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>、<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>、易于使用的消息中间件</h4>\n<h4 id=\"RocketMQ具有以下特性\"><a class=\"header-anchor\" href=\"#RocketMQ具有以下特性\"></a>RocketMQ具有以下特性</h4>\n<ul>\n<li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li>\n<li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li>\n<li>支持拉（pull）和推（push）两种消息模式</li>\n<li>单一队列百万消息的堆积能力</li>\n<li>支持多种消息协议，如 JMS、MQTT 等</li>\n<li>分布式高可用的部署架构,满足至少一次消息传递语义</li>\n<li>提供 docker 镜像用于隔离测试和云集群部署</li>\n<li>提供配置、指标和监控等功能丰富的 Dashboard</li>\n</ul>\n<blockquote>\n<h3 id=\"Producer\"><a class=\"header-anchor\" href=\"#Producer\"></a>Producer</h3>\n<p><strong>消息生产者</strong>，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。</p>\n<h3 id=\"Producer-Group\"><a class=\"header-anchor\" href=\"#Producer-Group\"></a>Producer Group</h3>\n<p><strong>生产者组</strong>，就是多个发送同一类消息的生产者称之为一个生产者组。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"Consumer\"><a class=\"header-anchor\" href=\"#Consumer\"></a>Consumer</h3>\n<p><strong>消息消费者</strong>，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p>\n<h3 id=\"Consumer-Group\"><a class=\"header-anchor\" href=\"#Consumer-Group\"></a>Consumer Group</h3>\n<p><strong>消费者组</strong>，消费同一类消息的多个 consumer 实例组成一个消费者组。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"Topic\"><a class=\"header-anchor\" href=\"#Topic\"></a>Topic</h3>\n<p><em>Topic</em> 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推</p>\n<h3 id=\"Message\"><a class=\"header-anchor\" href=\"#Message\"></a>Message</h3>\n<p><em>Message</em>是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"Tag\"><a class=\"header-anchor\" href=\"#Tag\"></a>Tag</h3>\n<p><em>Tag</em><strong>标签</strong>可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息</p>\n<h3 id=\"Broker\"><a class=\"header-anchor\" href=\"#Broker\"></a>Broker</h3>\n<p><em>Broker</em>是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备</p>\n<h3 id=\"Name-Server\"><a class=\"header-anchor\" href=\"#Name-Server\"></a>Name Server</h3>\n<p><em>Name Server</em> 为 producer 和 consumer 提供路由信息。</p>\n</blockquote>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>响应时间低，比如一个网页在几秒内打开，越短表示延迟越低 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>指的是运行时间能够满足预计时间的一个系统或组件 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡 <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-RocketMQ-是什么\"><a class=\"header-anchor\" href=\"#1-RocketMQ-是什么\"></a>1. RocketMQ 是什么</h2>\n<h4 id=\"RocketMQ是一款、、、易于使用的消息中间件\"><a class=\"header-anchor\" href=\"#RocketMQ是一款、、、易于使用的消息中间件\"></a>RocketMQ是一款<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>、<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>、<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>、易于使用的消息中间件</h4>\n<h4 id=\"RocketMQ具有以下特性\"><a class=\"header-anchor\" href=\"#RocketMQ具有以下特性\"></a>RocketMQ具有以下特性</h4>\n<ul>\n<li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li>\n<li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li>\n<li>支持拉（pull）和推（push）两种消息模式</li>\n<li>单一队列百万消息的堆积能力</li>\n<li>支持多种消息协议，如 JMS、MQTT 等</li>\n<li>分布式高可用的部署架构,满足至少一次消息传递语义</li>\n<li>提供 docker 镜像用于隔离测试和云集群部署</li>\n<li>提供配置、指标和监控等功能丰富的 Dashboard</li>\n</ul>\n<blockquote>\n<h3 id=\"Producer\"><a class=\"header-anchor\" href=\"#Producer\"></a>Producer</h3>\n<p><strong>消息生产者</strong>，生产者的作用就是将消息发送到 MQ。生产者本身既可以产生消息，如读取文本信息等，也可以对外提供接口，由外部应用调用接口传递消息，再由生产者将收到的消息发送到 MQ。</p>\n<h3 id=\"Producer-Group\"><a class=\"header-anchor\" href=\"#Producer-Group\"></a>Producer Group</h3>\n<p><strong>生产者组</strong>，就是多个发送同一类消息的生产者称之为一个生产者组。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"Consumer\"><a class=\"header-anchor\" href=\"#Consumer\"></a>Consumer</h3>\n<p><strong>消息消费者</strong>，消费 MQ 上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。</p>\n<h3 id=\"Consumer-Group\"><a class=\"header-anchor\" href=\"#Consumer-Group\"></a>Consumer Group</h3>\n<p><strong>消费者组</strong>，消费同一类消息的多个 consumer 实例组成一个消费者组。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"Topic\"><a class=\"header-anchor\" href=\"#Topic\"></a>Topic</h3>\n<p><em>Topic</em> 是一种消息的逻辑分类。比如说有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。以此类推</p>\n<h3 id=\"Message\"><a class=\"header-anchor\" href=\"#Message\"></a>Message</h3>\n<p><em>Message</em>是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对，例如需要一个业务 key 来查找 broker 上的消息，方便在开发过程中诊断问题。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"Tag\"><a class=\"header-anchor\" href=\"#Tag\"></a>Tag</h3>\n<p><em>Tag</em><strong>标签</strong>可以被认为是对Topic进一步细化。一般在相同业务模块中通过标签来标记不同用途的消息</p>\n<h3 id=\"Broker\"><a class=\"header-anchor\" href=\"#Broker\"></a>Broker</h3>\n<p><em>Broker</em>是RocketMQ系统的主要角色，即MQ。Broker接收来自生产者的消息，储存，以及为消费者拉取消息的请求做好准备</p>\n<h3 id=\"Name-Server\"><a class=\"header-anchor\" href=\"#Name-Server\"></a>Name Server</h3>\n<p><em>Name Server</em> 为 producer 和 consumer 提供路由信息。</p>\n</blockquote>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>响应时间低，比如一个网页在几秒内打开，越短表示延迟越低 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>指的是运行时间能够满足预计时间的一个系统或组件 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>可伸缩性是高性能、低成本和可维护性等多因素的综合考量和平衡 <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"},{"title":"假期学习计划","date":"2020-01-22T08:21:57.000Z","_content":"","source":"_posts/假期学习计划.md","raw":"---\ntitle: 假期学习计划\ndate: 2020-01-22 16:21:57\ntags:\n---\n","slug":"假期学习计划","published":1,"updated":"2020-01-22T08:21:57.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5p297pi0003bg0r5hos8msk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Netty(笔记)","date":"2020-01-16T07:31:51.000Z","_content":"\n## 业界哪些流行的开源框架用Netty作为底层通信框架\n\n- Dubbo： 阿里开源的高性能RPC框架\n- RocketMQ： 阿里出品的高性能消息队列\n- Spark： 炙手可热的大数据处理引擎，底层使用Netty\n- Elasticsearch： 分布式多用户的全文搜索引擎\n- Apache Cassandra：开源分布式搜索数据库\n- Flink:分布式高性能高可用的流处理框架\n- Netty-SocketIO的java服务端实现\n- Spring5：使用Netty作为http协议框架\n- Play：简单易用的http服务器\n- Grpc:google开源的高性能rpc通信框架\n- Infinispan：针对缓存的高并发键值对数据存储\n- HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统\n- Vert.x轻量级高性能能JVM应用平台\n  -<br>[完整的参考列表](https://netty.io/wiki/adopters.html)\n\n## 业界有哪些公司在使用Netty\n\n**在大型企业中**有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram\n<br>**在初创企业中**有：做http长连接的**Firebase**、支持各种各样消息推送通知的**Urban Airship**\n<br><br> 当然，Netty也从这些项目中**受益**。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。\n\n## Netty是什么\n\n1. **异步**和**事件驱动**的高性能网络通信框架。\n2. **特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。\n3. **目的:**用于快速开发高性能服务端和客户端\n4. **封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易\n5. 自带编解码器解决拆包粘包问题，用户只关心业务逻辑\n6. 精心设计的reactor线程模型支持高并发海量连接\n7. 自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手\n8. **架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离--业务和网络逻辑解耦，模块化和可复用性，可测试性。\n\n## Netty的特性总结\n\n![mark](https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim)\n\n## Socket & Netty\n\n![Socket & Netty](https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim)\n\n## Netty基本组件\n\n![mark](https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim)\n\n- NioEventLoop ->Thread\n- Channel ->Socket  \t\n  NioSocketChannel implements Channel  \n  Chennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind\n- ByteBuf ->IO Bytes  \n  readBytes()、writeBytes() and so on\n- Pipline ->Logic Chain 逻辑链 \n- ChannelHandler ->Logic处理块\n\n## Netty核心组件\n\n### 1. Channel-Socket  \n\nChannel是通讯的载体，其基本构造是Socket  \n是对网络底层读写和连接原语言的抽象  \n\n### 2. EventLoop-控制流、多线程处理、并发\n\n定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件\n\n### 注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系\n\n![mark](https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim))\n\n##### A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；  \n\n##### B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定\n\n##### C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；\n\n##### D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；  \n\n##### E. 一个 EventLoop 可能会被分配给一个或多个 Channel\n\n##### F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。\n\n### 3. ChannelFuture-异步通知\n\nNetty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法\n\n### 4. ChannelHandler和ChannelPipeline\n\nChannelHandler负责Channel中的逻辑处理  \n其旨在简化应用程序处理逻辑的开发过程    \n充当了所有处理入站和出站数据的应用程序逻辑的容器  \nChannelHandler子接口：  \nChannelInboundHandler——处理入站数据以及各种状态变化  \nChannelOutboundHandler——处理出站数据并且允许拦截所有的操作  \nChannelInboundHandler的方法:  \n![mark](https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim)\nChannelOutboundHandler的方法:    \n![mark](https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim)\n\nChannelPipeline 提供了 ChannelHandler链的容器  \n定义了用于在该链上传播入站和出站事件流的API\n\n### 5. ByteBuf-Netty的数据容器\t\n\nJava NIO提供了ByteBuffer作为它的字节容器    \nNetty的ByteBuffer替代品是ByteBuf  \n\n##### A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；  \n\n##### B.容量可以按需增长（类似于 JDK 的 StringBuilder）\n\n##### C.读和写使用了不同的索引\n\n##### D.支持方法的链式调用\n\n##### E.支持引用计数\n\n##### F.支持池化\n\n### 6. Bootstap-引导客户端和无连接协议\n\nBootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel\n![](http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg)\n\n## 单元测试\n\n使用EmbeddedChannel 测试 ChannelHandler  \n\n1. 测试入站消息  \n2. 测试出站消息  \n3. 测试异常处理  \n\n## 编解码器\n\n- 解码器   \n  将字节解码为消息  \n  将一种消息类型解码为另一种\n- 编码器  \n  将消息编码为字节  \n  将消息编码为消息\n\n## Netty服务端启动\n\n1. 创建服务端Channel\n2. 初始化服务端Channel\n3. 注册Selector\n4. 端口绑定，实现对本地端口的接听\n\n## 预置的ChannelHandler和编解码器\n\n1. 通过 SSL/TLS 保护 Netty 应用程序\n2. ChannelHandler处理 HTTP 和 HTTPS协议\n3. 支持WebSocket\n4. ChannelHandler检测空闲连接以及超时\n5. FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域\n6. 使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据\n7. 使用UDP广播事件\n\n### 创建服务端Channel\n\n**bind()[用户代码入口] ->initAndRegister()[初始化并注册] ->newChannel()[创建服务端channel]**\n![mark](https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim)\n\n![mark](https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim)\n\n![mark](https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim)\n\n## 如何使用Netty进行RPC服务器的开发?  \n\n1. 定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。    \n2. 服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。\n3. 客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。\n4. RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。\n5. 客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。\n   ![mark](https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim) **客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。**\n   Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：  \n6. ![mark](https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim)  \n   **客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。**\n\n\n\n## 附录\n\n### Netty疑问\n\n1. Netty是什么？  \n   Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。\n2. 使用Netty能够做什么？  \n   ①开发异步、非阻塞的TCP网络应用程序；  \n   ②开发异步、非阻塞的UDP网络应用程序；  \n   ③开发异步文件传输应用程序；  \n   ④开发异步HTTP服务端和客户端应用程序；  \n   ⑤提供对多种编解码框架的集成；  \n   ⑥提供形式多样的编解码基础类库；  \n   ⑦基于职责链模式的Pipeline-Handler机制；\n   ⑧所有的IO操作都是异步的；\n   ⑨IP黑白名单控制，性能统计；\n   ⑩基于链路空闲事件检测的心跳检测；\n3. Netty在哪些行业得到了应用  \n   **①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。  \n   典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。  \n   除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。  \n   **②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。   \n   **③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。  \n   **④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。  \n   **⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。  \n4. 使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？  \n   传统的同步阻塞IO通信存在如下几个问题：  \n   **①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；  \n   **②性能差：**频繁的线程上下文切换导致CPU利用效率不高；  \n   **③可靠性差：**由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。  \n   **采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：**  \n   ①Nio采用Reactor模式*，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N < 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N < 进程可用的最大句柄数)；   \n   ②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；  \n   ③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。  \n   **由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。**\n5. 为什么不直接基于JDK的NIO类库编程呢？  \n   即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。\n6. 为什么要选择Netty框架？  \n   Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。\n   Netty的优点总结如下：  \n   ①API使用简单，开发门槛低；  \n   ②功能强大，预置了多种编解码功能，支持多种主流协议；  \n   ③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；  \n   ④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；  \n   ⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；  \n   ⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；  \n   ⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。\n\n## 代码\n\n### 1. 基于Netty的客户端和服务端的简单通信\n\n##### 要点：\n\n①为初始化客户端， 创建了一个 Bootstrap 实例  \n②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；  \n③为服务器连接创建了一个 InetSocketAddress 实例；    \n④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；  \n⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；  \n![mark](https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim)\n\n### EchoServerHandler\n\n##### channelRead()—对于每个传入的消息都要调用；\n\n##### channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；\n\n##### exceptionCaught()—在读取操作期间，有异常抛出时会调用。\n\n```Java\n\t//标示一个ChannelHandler可以被多个 Channel 安全地共享\n\t\t@Sharable\n\t\tpublic class EchoServerHandler extends ChannelInboundHandlerAdapter {\n\t\t    @Override\n\t\t    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n\t\t        ByteBuf in = (ByteBuf) msg;\n\t\t        //将消息记录到控制台\n\t\t        System.out.println(\"Server received: \" + in.toString(CharsetUtil.UTF_8));\n\t\t        //将接收到的消息写给发送者，而不冲刷出站消息\n\t\t        ctx.write(in);\n\t\t    }\n             @Override\n\t    \tpublic void channelReadComplete(ChannelHandlerContext ctx)throws Exception {\n\t        \t//将未决消息冲刷到远程节点，并且关闭该 Channel\n\t        \tctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n\t    \t}\n\t\n\t    @Override\n\t    public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) {\n\t        //打印异常栈跟踪\n\t        cause.printStackTrace();\n\t        //关闭该Channel\n\t        ctx.close();\n\t    }\n\t}\n```\n\n### EchoServer\n\n##### 绑定到服务器将在其上监听并接受传入连接请求的端口；\n\n##### 配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。\n\n```java\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public static void main(String[] args)\n            throws Exception {\n        if (args.length != 1) {\n            System.err.println(\"Usage: \" + EchoServer.class.getSimpleName() +\" <port>\"\n            );\n            return;\n        }\n        //设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）\n        int port = Integer.parseInt(args[0]);\n        //调用服务器的 start()方法\n        new EchoServer(port).start();\n    }\n\n    public void start() throws Exception {\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        //(1) 创建EventLoopGroup\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            //(2) 创建ServerBootstrap\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(group)\n                    //(3) 指定所使用的 NIO 传输 Channel\n                    .channel(NioServerSocketChannel.class)\n                    //(4) 使用指定的端口设置套接字地址\n                    .localAddress(new InetSocketAddress(port))\n                    //(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            //EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例\n                            //这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，\n                            ch.pipeline().addLast(serverHandler);\n                        }\n                    });\n            //(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成\n            ChannelFuture f = b.bind().sync();\n            System.out.println(EchoServer.class.getName() +\n                    \" started and listening for connections on \" + f.channel().localAddress());\n            //(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成\n            f.channel().closeFuture().sync();\n        } finally {\n            //(8) 关闭 EventLoopGroup，释放所有的资源\n            grop.shutdownGracefully().sync();\n        }\n    }\n}\n```\n\n### 通过 ChannelHandler 实现客户端逻辑\n\n##### channelActive()——在到服务器的连接已经建立之后将被调用；\n\n##### channelRead0()——当服务器接收到一条消息时被调用\n\n##### exceptionCaught()——在处理过程中引发异常时被调用。\n\n```java\n@Sharable\n//标记该类的实例可以被多个 Channel 共享\npublic class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        //当被通知 Channel是活跃的时候，发送一条消息\n        ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty rocks!\",CharsetUtil.UTF_8));\n    }\n\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {\n        //记录已接收消息的转储\n        System.out.println(\"Client received: \" + in.toString(CharsetUtil.UTF_8));\n    }\n\n    @Override\n    //在发生异常时，记录错误并关闭Channel\n    public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n\t\t\n```\n\n### 引导客户端\n\n##### 客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口\n\n```java\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start()\n            throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            //创建 Bootstrap\n            Bootstrap b = new Bootstrap();\n            //指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现\n            b.group(group)\n                    //适用于 NIO 传输的Channel 类型\n                    .channel(NioSocketChannel.class)\n                    //设置服务器的InetSocketAddress\n                    .remoteAddress(new InetSocketAddress(host, port))\n                    //在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch)\n                                throws Exception {\n                            ch.pipeline().addLast(\n                                    new EchoClientHandler());\n                        }\n                    });\n            //连接到远程节点，阻塞等待直到连接完成\n            ChannelFuture f = b.connect().sync();\n            //阻塞，直到Channel 关闭\n            f.channel().closeFuture().sync();\n        } finally {\n            //关闭线程池并且释放所有的资源\n            group.shutdownGracefully().sync();\n        }\n    }\n\n    public static void main(String[] args)\n            throws Exception {\n        if (args.length != 2) {\n            System.err.println(\"Usage: \" + EchoClient.class.getSimpleName() +\n                    \" <host> <port>\"\n            );\n            return;\n        }\n\n        final String host = args[0];\n        final int port = Integer.parseInt(args[1]);\n        new EchoClient(host, port).start();\n    }\n}\n```\n\n### 2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架\n\n##### 简易RPC有如下特性：\n\n- 服务异步调用的支持，回调函数callback的支持\n- 客户端使用长连接（在多次调用共享连接）\n- 服务端异步多线程处理RPC请求\n- 服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。\n- 通信：使用Netty作为通信框架\n- Spring：使用Spring配置服务，加载Bean，扫描注解\n- 动态代理：客户端使用代理模式透明化服务调用\n- 消息编解码：使用Protostuff序列化和反序列化消息\n\n##### RPC介绍\n\nRPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。\n\n![mark](https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim)\n\n- 服务端发布服务\n\n##### 服务注解：\n\n```java\n\t@Target({ElementType.TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface RpcService {\n\t    Class<?> value();\n\t}\n```\n\n##### 一个服务接口：\n\n```java\npublic interface HelloService {\nString hello(String name);\n\t   String hello(Person person);\n}\n```\n\n##### 一个服务实现：使用注解标注：\n\n```java\n@RpcService(HelloService.class)\npublic class HelloServiceImpl implements HelloService {\n    @Override\n    public String hello(String name) {\n        return \"Hello! \" + name;\n    }\n\n    @Override\n    public String hello(Person person) {\n        return \"Hello! \" + person.getFirstName() + \" \" + person.getLastName()\n    }\n}\n\n```\n\n##### 服务在启动的时候扫描得到所有的服务接口及其实现：\n\n```java\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext ctx) throws BeansException {\n\t      Map<String, Object> serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);\n\t      if (MapUtils.isNotEmpty(serviceBeanMap)) {\n\t        for (Object serviceBean : serviceBeanMap.values()) {\n\t            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();\n\t            handlerMap.put(interfaceName, serviceBean);\n\t         }\n\t      }\n\t  }\n```\n\n##### 在Zookeeper集群上注册服务地址：\n\n```java\npublic class ServiceRegistry {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    private String registryAddress;\n\n    public ServiceRegistry(String registryAddress) {\n        this.registryAddress = registryAddress;\n    }\n\n    public void register(String data) {\n        if (data != null) {\n            ZooKeeper zk = connectServer();\n            if (zk != null) {\n                AddRootNode(zk); // Add root node if not exist\n                createNode(zk, data);\n            }\n        }\n    }\n\n    private ZooKeeper connectServer() {\n        ZooKeeper zk = null;\n        try {\n            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\n                        latch.countDown();\n                    }\n                }\n            });\n            latch.await();\n        } catch (IOException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedException ex) {\n            LOGGER.error(\"\", ex);\n        }\n        return zk;\n    }\n\n    private void AddRootNode(ZooKeeper zk) {\n        try {\n            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, false);\n            if (s == null) {\n                zk.create(Constant.ZK_REGISTRY_PATH, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n        } catch (KeeperException e) {\n            LOGGER.error(e.toString());\n        } catch (InterruptedException e) {\n            LOGGER.error(e.toString());\n        }\n    }\n\n    private void createNode(ZooKeeper zk, String data) {\n        try {\n            byte[] bytes = data.getBytes();\n            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n            LOGGER.debug(\"create zookeeper node ({} => {})\", path, data);\n        } catch (KeeperException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedExceptin ex) {\n            LOGGER.error(\"\", ex);\n        }\n    }\n}\n\t    \n```\n\n##### 客户端使用代理模式调用服务：\n\n```java\npublic class ServiceRegistry {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    private String registryAddress;\n\n    public ServiceRegistry(String registryAddress) {\n        this.registryAddress = registryAddress;\n    }\n\n    public void register(String data) {\n        if (data != null) {\n            ZooKeeper zk = connectServer();\n            if (zk != null) {\n                AddRootNode(zk); // Add root node if not exist\n                createNode(zk, data);\n            }\n        }\n    }\n\n    private ZooKeeper connectServer() {\n        ZooKeeper zk = null;\n        try {\n            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\n                        latch.countDown();\n                    }\n                }\n            });\n            latch.await();\n        } catch (IOException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedException ex) {\n            LOGGER.error(\"\", ex);\n        }\n        return zk;\n    }\n\n    private void AddRootNode(ZooKeeper zk) {\n        try {\n            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, false);\n            if (s == null) {\n                zk.create(Constant.ZK_REGISTRY_PATH, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n        } catch (KeeperException e) {\n            LOGGER.error(e.toString());\n        } catch (InterruptedException e) {\n            LOGGER.error(e.toString());\n        }\n    }\n\n    private void createNode(ZooKeeper zk, String data) {\n        try {\n            byte[] bytes = data.getBytes();\n            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n            LOGGER.debug(\"create zookeeper node ({} => {})\", path, data);\n        } catch (KeeperException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedException ex) {\n            LOGGER.error(\"\", ex);\n        }\n    }\n}\n\n```\n\n##### 从Zookeeper上获取服务地址：\n\n```java\npublic class ServiceDiscovery {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    private volatile List<String> dataList = new ArrayList<>();\n\n    private String registryAddress;\n\n    public ServiceDiscovery(String registryAddress) {\n        this.registryAddress = registryAddress;\n        ZooKeeper zk = connectServer();\n        if (zk != null) {\n            watchNode(zk);\n        }\n    }\n\n    public String discover() {\n        String data = null;\n        int size = dataList.size();\n        if (size > 0) {\n            if (size == 1) {\n                data = dataList.get(0);\n                LOGGER.debug(\"using only data: {}\", data);\n            } else {\n                data = dataList.get(ThreadLocalRandom.current().nextInt(size));\n                LOGGER.debug(\"using random data: {}\", data);\n            }\n        }\n        return data;\n    }\n\n    private ZooKeeper connectServer() {\n        ZooKeeper zk = null;\n        try {\n            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\n                        latch.countDown();\n                    }\n                }\n            });\n            latch.await();\n        } catch (IOException | InterruptedException e) {\n            LOGGER.error(\"\", e);\n        }\n        return zk;\n    }\n\n    private void watchNode(final ZooKeeper zk) {\n        try {\n            List<String> nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getType() == Event.EventType.NodeChildrenChanged) {\n                        watchNode(zk);\n                    }\n                }\n            });\n            List<String> dataList = new ArrayList<>();\n            for (String node : nodeList) {\n                byte[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + \"/\" + node, false, null);\n                dataList.add(new String(bytes));\n            }\n            LOGGER.debug(\"node data: {}\", dataList);\n            this.dataList = dataList;\n        } catch (KeeperException | InterrupteException e) {\n            LOGGER.error(\"\", e);\n        }\n    }\n}\n\n```\n\n##### 消息编码 请求消息：\n\n```java\npublic class RpcRequest {\n    private String requestId;\n    private String className;\n    private String methodName;\n    private Class<?>[] parameterTypes;\n    private Object[] parameters;\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getClassName() {\n        return className;\n    }\n\n    public void setClassName(String className) {\n        this.className = className;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n\n    public void setMethodName(String methodName) {\n        this.methodName = methodName;\n    }\n\n    public Class<?>[] getParameterTypes() {\n        return parameterTypes;\n    }\n\n    public void setParameterTypes(Class<?>[] parameterTypes) {\n        this.parameterTypes = parameterTypes;\n    }\n\n    public Object[] getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(Object[] parameters) {\n        this.parameters = parameters;\n    }\n}\n\t  \n```\n\n##### 响应消息：\n\n```java\npublic class RpcResponse {\n    private String requestId;\n    private String error;\n    private Object result;\n\n    public boolean isError() {\n        return error != null;\n    }\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getError() {\n        return error;\n    }\n\n    public void setError(String error) {\n        this.error = error;\n    }\n\n    public Object getResult() {\n        return result;\n    }\n\n    public void setResult(Object result) {\n        this.result = result;\n    }\n}\n\t\n```\n\n##### 消息序列化和反序列化工具：（基于 Protostuff 实现）\n\n```java\npublic class SerializationUtil {\n    private static Map<Class<?>, Schema<?>> cachedSchema = new ConcurrentHashMap<>();\n\n    private static Objenesis objenesis = new ObjenesisStd(true);\n\n    private SerializationUtil() {\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> Schema<T> getSchema(Class<T> cls) {\n        Schema<T> schema = (Schema<T>) cachedSchema.get(cls);\n        if (schema == null) {\n            schema = RuntimeSchema.createFrom(cls);\n            if (schema != null) {\n                cachedSchema.put(cls, schema);\n            }\n        }\n        return schema;\n    }\n\n    /**\n     * 序列化（对象 -> 字节数组）\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> byte[] serialize(T obj) {\n        Class<T> cls = (Class<T>) obj.getClass();\n        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);\n        try {\n            Schema<T> schema = getSchema(cls);\n            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        } finally {\n            buffer.clear();\n        }\n    }\n\n    /**\n     * 反序列化（字节数组 -> 对象）\n     */\n    public static <T> T deserialize(byte[] data, Class<T> cls) {\n        try {\n            T message = (T) objenesis.newInstance(cls);\n            Schema<T> schema = getSchema(cls);\n            ProtostuffIOUtil.mergeFrom(data, message, schema);\n            return message;\n        } catch (Exception e) {\n            throw new IllegalStatexception(e.getMessage(), e);\n        }\n    }\n}\n```\n\n##### 性能改进 服务端请求异步处理\n\n```java\npublic void channelRead0(final ChannelHandlerContext ctx,final RpcRequest request) throws Exception {\n        RpcServer.submit(new Runnable() {\n            @Override\n            public void run() {\n                LOGGER.debug(\"Receive request \" + request.getRequestId());\n                RpcResponse response = new RpcResponse();\n                response.setRequestId(request.getRequestId());\n                try {\n                    Object result = handle(request);\n                    response.setResult(result);\n                } catch (Throwable t) {\n                    response.setError(t.toString());\n                    LOGGER.error(\"RPC Server handle request error\",t);\n                }\n                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture channelFuture) throws Exception {\n                        LOGGER.debug(\"Send response for request \" + request.getRequestId());\n                    }\n                });\n            }\n        });\n    }\n```\n\n##### 服务端长连接的管理\n\n客户端保持和服务进行**长连接**，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。  \n通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。\n\n##### 客户端请求异步处理\n\n**客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。**\n\n```java\n\tIAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);\n\tRPCFuture helloFuture = client.call(\"hello\", Integer.toString(i));\n\tString result = (String) helloFuture.get(3000, TimeUnit.MILLISECONDS);\n```\n\n","source":"_posts/Netty笔记.md","raw":"---\ntitle: Netty(笔记)\ndate: 2020-01-16 15:31:51\ntags: Netty\ncategories: Java\n---\n\n## 业界哪些流行的开源框架用Netty作为底层通信框架\n\n- Dubbo： 阿里开源的高性能RPC框架\n- RocketMQ： 阿里出品的高性能消息队列\n- Spark： 炙手可热的大数据处理引擎，底层使用Netty\n- Elasticsearch： 分布式多用户的全文搜索引擎\n- Apache Cassandra：开源分布式搜索数据库\n- Flink:分布式高性能高可用的流处理框架\n- Netty-SocketIO的java服务端实现\n- Spring5：使用Netty作为http协议框架\n- Play：简单易用的http服务器\n- Grpc:google开源的高性能rpc通信框架\n- Infinispan：针对缓存的高并发键值对数据存储\n- HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统\n- Vert.x轻量级高性能能JVM应用平台\n  -<br>[完整的参考列表](https://netty.io/wiki/adopters.html)\n\n## 业界有哪些公司在使用Netty\n\n**在大型企业中**有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram\n<br>**在初创企业中**有：做http长连接的**Firebase**、支持各种各样消息推送通知的**Urban Airship**\n<br><br> 当然，Netty也从这些项目中**受益**。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。\n\n## Netty是什么\n\n1. **异步**和**事件驱动**的高性能网络通信框架。\n2. **特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。\n3. **目的:**用于快速开发高性能服务端和客户端\n4. **封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易\n5. 自带编解码器解决拆包粘包问题，用户只关心业务逻辑\n6. 精心设计的reactor线程模型支持高并发海量连接\n7. 自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手\n8. **架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离--业务和网络逻辑解耦，模块化和可复用性，可测试性。\n\n## Netty的特性总结\n\n![mark](https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim)\n\n## Socket & Netty\n\n![Socket & Netty](https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim)\n\n## Netty基本组件\n\n![mark](https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim)\n\n- NioEventLoop ->Thread\n- Channel ->Socket  \t\n  NioSocketChannel implements Channel  \n  Chennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind\n- ByteBuf ->IO Bytes  \n  readBytes()、writeBytes() and so on\n- Pipline ->Logic Chain 逻辑链 \n- ChannelHandler ->Logic处理块\n\n## Netty核心组件\n\n### 1. Channel-Socket  \n\nChannel是通讯的载体，其基本构造是Socket  \n是对网络底层读写和连接原语言的抽象  \n\n### 2. EventLoop-控制流、多线程处理、并发\n\n定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件\n\n### 注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系\n\n![mark](https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim))\n\n##### A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；  \n\n##### B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定\n\n##### C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；\n\n##### D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；  \n\n##### E. 一个 EventLoop 可能会被分配给一个或多个 Channel\n\n##### F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。\n\n### 3. ChannelFuture-异步通知\n\nNetty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法\n\n### 4. ChannelHandler和ChannelPipeline\n\nChannelHandler负责Channel中的逻辑处理  \n其旨在简化应用程序处理逻辑的开发过程    \n充当了所有处理入站和出站数据的应用程序逻辑的容器  \nChannelHandler子接口：  \nChannelInboundHandler——处理入站数据以及各种状态变化  \nChannelOutboundHandler——处理出站数据并且允许拦截所有的操作  \nChannelInboundHandler的方法:  \n![mark](https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim)\nChannelOutboundHandler的方法:    \n![mark](https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim)\n\nChannelPipeline 提供了 ChannelHandler链的容器  \n定义了用于在该链上传播入站和出站事件流的API\n\n### 5. ByteBuf-Netty的数据容器\t\n\nJava NIO提供了ByteBuffer作为它的字节容器    \nNetty的ByteBuffer替代品是ByteBuf  \n\n##### A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；  \n\n##### B.容量可以按需增长（类似于 JDK 的 StringBuilder）\n\n##### C.读和写使用了不同的索引\n\n##### D.支持方法的链式调用\n\n##### E.支持引用计数\n\n##### F.支持池化\n\n### 6. Bootstap-引导客户端和无连接协议\n\nBootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel\n![](http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg)\n\n## 单元测试\n\n使用EmbeddedChannel 测试 ChannelHandler  \n\n1. 测试入站消息  \n2. 测试出站消息  \n3. 测试异常处理  \n\n## 编解码器\n\n- 解码器   \n  将字节解码为消息  \n  将一种消息类型解码为另一种\n- 编码器  \n  将消息编码为字节  \n  将消息编码为消息\n\n## Netty服务端启动\n\n1. 创建服务端Channel\n2. 初始化服务端Channel\n3. 注册Selector\n4. 端口绑定，实现对本地端口的接听\n\n## 预置的ChannelHandler和编解码器\n\n1. 通过 SSL/TLS 保护 Netty 应用程序\n2. ChannelHandler处理 HTTP 和 HTTPS协议\n3. 支持WebSocket\n4. ChannelHandler检测空闲连接以及超时\n5. FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域\n6. 使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据\n7. 使用UDP广播事件\n\n### 创建服务端Channel\n\n**bind()[用户代码入口] ->initAndRegister()[初始化并注册] ->newChannel()[创建服务端channel]**\n![mark](https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim)\n\n![mark](https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim)\n\n![mark](https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim)\n\n## 如何使用Netty进行RPC服务器的开发?  \n\n1. 定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。    \n2. 服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。\n3. 客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。\n4. RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。\n5. 客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。\n   ![mark](https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim) **客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。**\n   Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：  \n6. ![mark](https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim)  \n   **客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。**\n\n\n\n## 附录\n\n### Netty疑问\n\n1. Netty是什么？  \n   Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。\n2. 使用Netty能够做什么？  \n   ①开发异步、非阻塞的TCP网络应用程序；  \n   ②开发异步、非阻塞的UDP网络应用程序；  \n   ③开发异步文件传输应用程序；  \n   ④开发异步HTTP服务端和客户端应用程序；  \n   ⑤提供对多种编解码框架的集成；  \n   ⑥提供形式多样的编解码基础类库；  \n   ⑦基于职责链模式的Pipeline-Handler机制；\n   ⑧所有的IO操作都是异步的；\n   ⑨IP黑白名单控制，性能统计；\n   ⑩基于链路空闲事件检测的心跳检测；\n3. Netty在哪些行业得到了应用  \n   **①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。  \n   典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。  \n   除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。  \n   **②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。   \n   **③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。  \n   **④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。  \n   **⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。  \n4. 使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？  \n   传统的同步阻塞IO通信存在如下几个问题：  \n   **①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；  \n   **②性能差：**频繁的线程上下文切换导致CPU利用效率不高；  \n   **③可靠性差：**由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。  \n   **采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：**  \n   ①Nio采用Reactor模式*，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N < 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N < 进程可用的最大句柄数)；   \n   ②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；  \n   ③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。  \n   **由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。**\n5. 为什么不直接基于JDK的NIO类库编程呢？  \n   即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。\n6. 为什么要选择Netty框架？  \n   Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。\n   Netty的优点总结如下：  \n   ①API使用简单，开发门槛低；  \n   ②功能强大，预置了多种编解码功能，支持多种主流协议；  \n   ③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；  \n   ④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；  \n   ⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；  \n   ⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；  \n   ⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。\n\n## 代码\n\n### 1. 基于Netty的客户端和服务端的简单通信\n\n##### 要点：\n\n①为初始化客户端， 创建了一个 Bootstrap 实例  \n②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；  \n③为服务器连接创建了一个 InetSocketAddress 实例；    \n④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；  \n⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；  \n![mark](https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim)\n\n### EchoServerHandler\n\n##### channelRead()—对于每个传入的消息都要调用；\n\n##### channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；\n\n##### exceptionCaught()—在读取操作期间，有异常抛出时会调用。\n\n```Java\n\t//标示一个ChannelHandler可以被多个 Channel 安全地共享\n\t\t@Sharable\n\t\tpublic class EchoServerHandler extends ChannelInboundHandlerAdapter {\n\t\t    @Override\n\t\t    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n\t\t        ByteBuf in = (ByteBuf) msg;\n\t\t        //将消息记录到控制台\n\t\t        System.out.println(\"Server received: \" + in.toString(CharsetUtil.UTF_8));\n\t\t        //将接收到的消息写给发送者，而不冲刷出站消息\n\t\t        ctx.write(in);\n\t\t    }\n             @Override\n\t    \tpublic void channelReadComplete(ChannelHandlerContext ctx)throws Exception {\n\t        \t//将未决消息冲刷到远程节点，并且关闭该 Channel\n\t        \tctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n\t    \t}\n\t\n\t    @Override\n\t    public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) {\n\t        //打印异常栈跟踪\n\t        cause.printStackTrace();\n\t        //关闭该Channel\n\t        ctx.close();\n\t    }\n\t}\n```\n\n### EchoServer\n\n##### 绑定到服务器将在其上监听并接受传入连接请求的端口；\n\n##### 配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。\n\n```java\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public static void main(String[] args)\n            throws Exception {\n        if (args.length != 1) {\n            System.err.println(\"Usage: \" + EchoServer.class.getSimpleName() +\" <port>\"\n            );\n            return;\n        }\n        //设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）\n        int port = Integer.parseInt(args[0]);\n        //调用服务器的 start()方法\n        new EchoServer(port).start();\n    }\n\n    public void start() throws Exception {\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        //(1) 创建EventLoopGroup\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            //(2) 创建ServerBootstrap\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(group)\n                    //(3) 指定所使用的 NIO 传输 Channel\n                    .channel(NioServerSocketChannel.class)\n                    //(4) 使用指定的端口设置套接字地址\n                    .localAddress(new InetSocketAddress(port))\n                    //(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            //EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例\n                            //这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，\n                            ch.pipeline().addLast(serverHandler);\n                        }\n                    });\n            //(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成\n            ChannelFuture f = b.bind().sync();\n            System.out.println(EchoServer.class.getName() +\n                    \" started and listening for connections on \" + f.channel().localAddress());\n            //(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成\n            f.channel().closeFuture().sync();\n        } finally {\n            //(8) 关闭 EventLoopGroup，释放所有的资源\n            grop.shutdownGracefully().sync();\n        }\n    }\n}\n```\n\n### 通过 ChannelHandler 实现客户端逻辑\n\n##### channelActive()——在到服务器的连接已经建立之后将被调用；\n\n##### channelRead0()——当服务器接收到一条消息时被调用\n\n##### exceptionCaught()——在处理过程中引发异常时被调用。\n\n```java\n@Sharable\n//标记该类的实例可以被多个 Channel 共享\npublic class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        //当被通知 Channel是活跃的时候，发送一条消息\n        ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty rocks!\",CharsetUtil.UTF_8));\n    }\n\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {\n        //记录已接收消息的转储\n        System.out.println(\"Client received: \" + in.toString(CharsetUtil.UTF_8));\n    }\n\n    @Override\n    //在发生异常时，记录错误并关闭Channel\n    public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n\t\t\n```\n\n### 引导客户端\n\n##### 客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口\n\n```java\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start()\n            throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            //创建 Bootstrap\n            Bootstrap b = new Bootstrap();\n            //指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现\n            b.group(group)\n                    //适用于 NIO 传输的Channel 类型\n                    .channel(NioSocketChannel.class)\n                    //设置服务器的InetSocketAddress\n                    .remoteAddress(new InetSocketAddress(host, port))\n                    //在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch)\n                                throws Exception {\n                            ch.pipeline().addLast(\n                                    new EchoClientHandler());\n                        }\n                    });\n            //连接到远程节点，阻塞等待直到连接完成\n            ChannelFuture f = b.connect().sync();\n            //阻塞，直到Channel 关闭\n            f.channel().closeFuture().sync();\n        } finally {\n            //关闭线程池并且释放所有的资源\n            group.shutdownGracefully().sync();\n        }\n    }\n\n    public static void main(String[] args)\n            throws Exception {\n        if (args.length != 2) {\n            System.err.println(\"Usage: \" + EchoClient.class.getSimpleName() +\n                    \" <host> <port>\"\n            );\n            return;\n        }\n\n        final String host = args[0];\n        final int port = Integer.parseInt(args[1]);\n        new EchoClient(host, port).start();\n    }\n}\n```\n\n### 2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架\n\n##### 简易RPC有如下特性：\n\n- 服务异步调用的支持，回调函数callback的支持\n- 客户端使用长连接（在多次调用共享连接）\n- 服务端异步多线程处理RPC请求\n- 服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。\n- 通信：使用Netty作为通信框架\n- Spring：使用Spring配置服务，加载Bean，扫描注解\n- 动态代理：客户端使用代理模式透明化服务调用\n- 消息编解码：使用Protostuff序列化和反序列化消息\n\n##### RPC介绍\n\nRPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。\n\n![mark](https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim)\n\n- 服务端发布服务\n\n##### 服务注解：\n\n```java\n\t@Target({ElementType.TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface RpcService {\n\t    Class<?> value();\n\t}\n```\n\n##### 一个服务接口：\n\n```java\npublic interface HelloService {\nString hello(String name);\n\t   String hello(Person person);\n}\n```\n\n##### 一个服务实现：使用注解标注：\n\n```java\n@RpcService(HelloService.class)\npublic class HelloServiceImpl implements HelloService {\n    @Override\n    public String hello(String name) {\n        return \"Hello! \" + name;\n    }\n\n    @Override\n    public String hello(Person person) {\n        return \"Hello! \" + person.getFirstName() + \" \" + person.getLastName()\n    }\n}\n\n```\n\n##### 服务在启动的时候扫描得到所有的服务接口及其实现：\n\n```java\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext ctx) throws BeansException {\n\t      Map<String, Object> serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);\n\t      if (MapUtils.isNotEmpty(serviceBeanMap)) {\n\t        for (Object serviceBean : serviceBeanMap.values()) {\n\t            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();\n\t            handlerMap.put(interfaceName, serviceBean);\n\t         }\n\t      }\n\t  }\n```\n\n##### 在Zookeeper集群上注册服务地址：\n\n```java\npublic class ServiceRegistry {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    private String registryAddress;\n\n    public ServiceRegistry(String registryAddress) {\n        this.registryAddress = registryAddress;\n    }\n\n    public void register(String data) {\n        if (data != null) {\n            ZooKeeper zk = connectServer();\n            if (zk != null) {\n                AddRootNode(zk); // Add root node if not exist\n                createNode(zk, data);\n            }\n        }\n    }\n\n    private ZooKeeper connectServer() {\n        ZooKeeper zk = null;\n        try {\n            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\n                        latch.countDown();\n                    }\n                }\n            });\n            latch.await();\n        } catch (IOException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedException ex) {\n            LOGGER.error(\"\", ex);\n        }\n        return zk;\n    }\n\n    private void AddRootNode(ZooKeeper zk) {\n        try {\n            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, false);\n            if (s == null) {\n                zk.create(Constant.ZK_REGISTRY_PATH, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n        } catch (KeeperException e) {\n            LOGGER.error(e.toString());\n        } catch (InterruptedException e) {\n            LOGGER.error(e.toString());\n        }\n    }\n\n    private void createNode(ZooKeeper zk, String data) {\n        try {\n            byte[] bytes = data.getBytes();\n            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n            LOGGER.debug(\"create zookeeper node ({} => {})\", path, data);\n        } catch (KeeperException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedExceptin ex) {\n            LOGGER.error(\"\", ex);\n        }\n    }\n}\n\t    \n```\n\n##### 客户端使用代理模式调用服务：\n\n```java\npublic class ServiceRegistry {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    private String registryAddress;\n\n    public ServiceRegistry(String registryAddress) {\n        this.registryAddress = registryAddress;\n    }\n\n    public void register(String data) {\n        if (data != null) {\n            ZooKeeper zk = connectServer();\n            if (zk != null) {\n                AddRootNode(zk); // Add root node if not exist\n                createNode(zk, data);\n            }\n        }\n    }\n\n    private ZooKeeper connectServer() {\n        ZooKeeper zk = null;\n        try {\n            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\n                        latch.countDown();\n                    }\n                }\n            });\n            latch.await();\n        } catch (IOException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedException ex) {\n            LOGGER.error(\"\", ex);\n        }\n        return zk;\n    }\n\n    private void AddRootNode(ZooKeeper zk) {\n        try {\n            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, false);\n            if (s == null) {\n                zk.create(Constant.ZK_REGISTRY_PATH, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n        } catch (KeeperException e) {\n            LOGGER.error(e.toString());\n        } catch (InterruptedException e) {\n            LOGGER.error(e.toString());\n        }\n    }\n\n    private void createNode(ZooKeeper zk, String data) {\n        try {\n            byte[] bytes = data.getBytes();\n            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n            LOGGER.debug(\"create zookeeper node ({} => {})\", path, data);\n        } catch (KeeperException e) {\n            LOGGER.error(\"\", e);\n        } catch (InterruptedException ex) {\n            LOGGER.error(\"\", ex);\n        }\n    }\n}\n\n```\n\n##### 从Zookeeper上获取服务地址：\n\n```java\npublic class ServiceDiscovery {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    private volatile List<String> dataList = new ArrayList<>();\n\n    private String registryAddress;\n\n    public ServiceDiscovery(String registryAddress) {\n        this.registryAddress = registryAddress;\n        ZooKeeper zk = connectServer();\n        if (zk != null) {\n            watchNode(zk);\n        }\n    }\n\n    public String discover() {\n        String data = null;\n        int size = dataList.size();\n        if (size > 0) {\n            if (size == 1) {\n                data = dataList.get(0);\n                LOGGER.debug(\"using only data: {}\", data);\n            } else {\n                data = dataList.get(ThreadLocalRandom.current().nextInt(size));\n                LOGGER.debug(\"using random data: {}\", data);\n            }\n        }\n        return data;\n    }\n\n    private ZooKeeper connectServer() {\n        ZooKeeper zk = null;\n        try {\n            zk = new ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getState() == Event.KeeperState.SyncConnected) {\n                        latch.countDown();\n                    }\n                }\n            });\n            latch.await();\n        } catch (IOException | InterruptedException e) {\n            LOGGER.error(\"\", e);\n        }\n        return zk;\n    }\n\n    private void watchNode(final ZooKeeper zk) {\n        try {\n            List<String> nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, new Watcher() {\n                @Override\n                public void process(WatchedEvent event) {\n                    if (event.getType() == Event.EventType.NodeChildrenChanged) {\n                        watchNode(zk);\n                    }\n                }\n            });\n            List<String> dataList = new ArrayList<>();\n            for (String node : nodeList) {\n                byte[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + \"/\" + node, false, null);\n                dataList.add(new String(bytes));\n            }\n            LOGGER.debug(\"node data: {}\", dataList);\n            this.dataList = dataList;\n        } catch (KeeperException | InterrupteException e) {\n            LOGGER.error(\"\", e);\n        }\n    }\n}\n\n```\n\n##### 消息编码 请求消息：\n\n```java\npublic class RpcRequest {\n    private String requestId;\n    private String className;\n    private String methodName;\n    private Class<?>[] parameterTypes;\n    private Object[] parameters;\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getClassName() {\n        return className;\n    }\n\n    public void setClassName(String className) {\n        this.className = className;\n    }\n\n    public String getMethodName() {\n        return methodName;\n    }\n\n    public void setMethodName(String methodName) {\n        this.methodName = methodName;\n    }\n\n    public Class<?>[] getParameterTypes() {\n        return parameterTypes;\n    }\n\n    public void setParameterTypes(Class<?>[] parameterTypes) {\n        this.parameterTypes = parameterTypes;\n    }\n\n    public Object[] getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(Object[] parameters) {\n        this.parameters = parameters;\n    }\n}\n\t  \n```\n\n##### 响应消息：\n\n```java\npublic class RpcResponse {\n    private String requestId;\n    private String error;\n    private Object result;\n\n    public boolean isError() {\n        return error != null;\n    }\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getError() {\n        return error;\n    }\n\n    public void setError(String error) {\n        this.error = error;\n    }\n\n    public Object getResult() {\n        return result;\n    }\n\n    public void setResult(Object result) {\n        this.result = result;\n    }\n}\n\t\n```\n\n##### 消息序列化和反序列化工具：（基于 Protostuff 实现）\n\n```java\npublic class SerializationUtil {\n    private static Map<Class<?>, Schema<?>> cachedSchema = new ConcurrentHashMap<>();\n\n    private static Objenesis objenesis = new ObjenesisStd(true);\n\n    private SerializationUtil() {\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> Schema<T> getSchema(Class<T> cls) {\n        Schema<T> schema = (Schema<T>) cachedSchema.get(cls);\n        if (schema == null) {\n            schema = RuntimeSchema.createFrom(cls);\n            if (schema != null) {\n                cachedSchema.put(cls, schema);\n            }\n        }\n        return schema;\n    }\n\n    /**\n     * 序列化（对象 -> 字节数组）\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> byte[] serialize(T obj) {\n        Class<T> cls = (Class<T>) obj.getClass();\n        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);\n        try {\n            Schema<T> schema = getSchema(cls);\n            return ProtostuffIOUtil.toByteArray(obj, schema, buffer);\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        } finally {\n            buffer.clear();\n        }\n    }\n\n    /**\n     * 反序列化（字节数组 -> 对象）\n     */\n    public static <T> T deserialize(byte[] data, Class<T> cls) {\n        try {\n            T message = (T) objenesis.newInstance(cls);\n            Schema<T> schema = getSchema(cls);\n            ProtostuffIOUtil.mergeFrom(data, message, schema);\n            return message;\n        } catch (Exception e) {\n            throw new IllegalStatexception(e.getMessage(), e);\n        }\n    }\n}\n```\n\n##### 性能改进 服务端请求异步处理\n\n```java\npublic void channelRead0(final ChannelHandlerContext ctx,final RpcRequest request) throws Exception {\n        RpcServer.submit(new Runnable() {\n            @Override\n            public void run() {\n                LOGGER.debug(\"Receive request \" + request.getRequestId());\n                RpcResponse response = new RpcResponse();\n                response.setRequestId(request.getRequestId());\n                try {\n                    Object result = handle(request);\n                    response.setResult(result);\n                } catch (Throwable t) {\n                    response.setError(t.toString());\n                    LOGGER.error(\"RPC Server handle request error\",t);\n                }\n                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture channelFuture) throws Exception {\n                        LOGGER.debug(\"Send response for request \" + request.getRequestId());\n                    }\n                });\n            }\n        });\n    }\n```\n\n##### 服务端长连接的管理\n\n客户端保持和服务进行**长连接**，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。  \n通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。\n\n##### 客户端请求异步处理\n\n**客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。**\n\n```java\n\tIAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);\n\tRPCFuture helloFuture = client.call(\"hello\", Integer.toString(i));\n\tString result = (String) helloFuture.get(3000, TimeUnit.MILLISECONDS);\n```\n\n","slug":"Netty笔记","published":1,"updated":"2020-01-22T02:46:50.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5p298j5000bbg0rmya5p4od","content":"<h2 id=\"业界哪些流行的开源框架用Netty作为底层通信框架\"><a class=\"header-anchor\" href=\"#业界哪些流行的开源框架用Netty作为底层通信框架\"></a>业界哪些流行的开源框架用Netty作为底层通信框架</h2>\n<ul>\n<li>Dubbo： 阿里开源的高性能RPC框架</li>\n<li>RocketMQ： 阿里出品的高性能消息队列</li>\n<li>Spark： 炙手可热的大数据处理引擎，底层使用Netty</li>\n<li>Elasticsearch： 分布式多用户的全文搜索引擎</li>\n<li>Apache Cassandra：开源分布式搜索数据库</li>\n<li>Flink:分布式高性能高可用的流处理框架</li>\n<li>Netty-SocketIO的java服务端实现</li>\n<li>Spring5：使用Netty作为http协议框架</li>\n<li>Play：简单易用的http服务器</li>\n<li>Grpc:google开源的高性能rpc通信框架</li>\n<li>Infinispan：针对缓存的高并发键值对数据存储</li>\n<li>HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统</li>\n<li>Vert.x轻量级高性能能JVM应用平台<br>\n-<br><a href=\"https://netty.io/wiki/adopters.html\" target=\"_blank\" rel=\"noopener\">完整的参考列表</a></li>\n</ul>\n<h2 id=\"业界有哪些公司在使用Netty\"><a class=\"header-anchor\" href=\"#业界有哪些公司在使用Netty\"></a>业界有哪些公司在使用Netty</h2>\n<p><strong>在大型企业中</strong>有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram<br>\n<br><strong>在初创企业中</strong>有：做http长连接的<strong>Firebase</strong>、支持各种各样消息推送通知的<strong>Urban Airship</strong><br>\n<br><br> 当然，Netty也从这些项目中<strong>受益</strong>。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。</p>\n<h2 id=\"Netty是什么\"><a class=\"header-anchor\" href=\"#Netty是什么\"></a>Netty是什么</h2>\n<ol>\n<li><strong>异步</strong>和<strong>事件驱动</strong>的高性能网络通信框架。</li>\n<li>**特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。</li>\n<li>**目的:**用于快速开发高性能服务端和客户端</li>\n<li>**封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易</li>\n<li>自带编解码器解决拆包粘包问题，用户只关心业务逻辑</li>\n<li>精心设计的reactor线程模型支持高并发海量连接</li>\n<li>自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手</li>\n<li>**架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离–业务和网络逻辑解耦，模块化和可复用性，可测试性。</li>\n</ol>\n<h2 id=\"Netty的特性总结\"><a class=\"header-anchor\" href=\"#Netty的特性总结\"></a>Netty的特性总结</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim\" alt=\"mark\"></p>\n<h2 id=\"Socket-Netty\"><a class=\"header-anchor\" href=\"#Socket-Netty\"></a>Socket &amp; Netty</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim\" alt=\"Socket &amp; Netty\"></p>\n<h2 id=\"Netty基本组件\"><a class=\"header-anchor\" href=\"#Netty基本组件\"></a>Netty基本组件</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim\" alt=\"mark\"></p>\n<ul>\n<li>NioEventLoop -&gt;Thread</li>\n<li>Channel -&gt;Socket  \t<br>\nNioSocketChannel implements Channel<br>\nChennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind</li>\n<li>ByteBuf -&gt;IO Bytes<br>\nreadBytes()、writeBytes() and so on</li>\n<li>Pipline -&gt;Logic Chain 逻辑链</li>\n<li>ChannelHandler -&gt;Logic处理块</li>\n</ul>\n<h2 id=\"Netty核心组件\"><a class=\"header-anchor\" href=\"#Netty核心组件\"></a>Netty核心组件</h2>\n<h3 id=\"1-Channel-Socket\"><a class=\"header-anchor\" href=\"#1-Channel-Socket\"></a>1. Channel-Socket</h3>\n<p>Channel是通讯的载体，其基本构造是Socket<br>\n是对网络底层读写和连接原语言的抽象</p>\n<h3 id=\"2-EventLoop-控制流、多线程处理、并发\"><a class=\"header-anchor\" href=\"#2-EventLoop-控制流、多线程处理、并发\"></a>2. EventLoop-控制流、多线程处理、并发</h3>\n<p>定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件</p>\n<h3 id=\"注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系\"><a class=\"header-anchor\" href=\"#注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系\"></a>注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim\" alt=\"mark\">)</p>\n<h5 id=\"A-一个-EventLoopGroup-包含一个或者多个-EventLoop；\"><a class=\"header-anchor\" href=\"#A-一个-EventLoopGroup-包含一个或者多个-EventLoop；\"></a>A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；</h5>\n<h5 id=\"B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定\"><a class=\"header-anchor\" href=\"#B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定\"></a>B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定</h5>\n<h5 id=\"C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；\"><a class=\"header-anchor\" href=\"#C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；\"></a>C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</h5>\n<h5 id=\"D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；\"><a class=\"header-anchor\" href=\"#D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；\"></a>D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；</h5>\n<h5 id=\"E-一个-EventLoop-可能会被分配给一个或多个-Channel\"><a class=\"header-anchor\" href=\"#E-一个-EventLoop-可能会被分配给一个或多个-Channel\"></a>E. 一个 EventLoop 可能会被分配给一个或多个 Channel</h5>\n<h5 id=\"F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。\"><a class=\"header-anchor\" href=\"#F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。\"></a>F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。</h5>\n<h3 id=\"3-ChannelFuture-异步通知\"><a class=\"header-anchor\" href=\"#3-ChannelFuture-异步通知\"></a>3. ChannelFuture-异步通知</h3>\n<p>Netty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法</p>\n<h3 id=\"4-ChannelHandler和ChannelPipeline\"><a class=\"header-anchor\" href=\"#4-ChannelHandler和ChannelPipeline\"></a>4. ChannelHandler和ChannelPipeline</h3>\n<p>ChannelHandler负责Channel中的逻辑处理<br>\n其旨在简化应用程序处理逻辑的开发过程<br>\n充当了所有处理入站和出站数据的应用程序逻辑的容器<br>\nChannelHandler子接口：<br>\nChannelInboundHandler——处理入站数据以及各种状态变化<br>\nChannelOutboundHandler——处理出站数据并且允许拦截所有的操作<br>\nChannelInboundHandler的方法:<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim\" alt=\"mark\"><br>\nChannelOutboundHandler的方法:<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim\" alt=\"mark\"></p>\n<p>ChannelPipeline 提供了 ChannelHandler链的容器<br>\n定义了用于在该链上传播入站和出站事件流的API</p>\n<h3 id=\"5-ByteBuf-Netty的数据容器\"><a class=\"header-anchor\" href=\"#5-ByteBuf-Netty的数据容器\"></a>5. ByteBuf-Netty的数据容器</h3>\n<p>Java NIO提供了ByteBuffer作为它的字节容器<br>\nNetty的ByteBuffer替代品是ByteBuf</p>\n<h5 id=\"A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；\"><a class=\"header-anchor\" href=\"#A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；\"></a>A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；</h5>\n<h5 id=\"B-容量可以按需增长（类似于-JDK-的-StringBuilder）\"><a class=\"header-anchor\" href=\"#B-容量可以按需增长（类似于-JDK-的-StringBuilder）\"></a>B.容量可以按需增长（类似于 JDK 的 StringBuilder）</h5>\n<h5 id=\"C-读和写使用了不同的索引\"><a class=\"header-anchor\" href=\"#C-读和写使用了不同的索引\"></a>C.读和写使用了不同的索引</h5>\n<h5 id=\"D-支持方法的链式调用\"><a class=\"header-anchor\" href=\"#D-支持方法的链式调用\"></a>D.支持方法的链式调用</h5>\n<h5 id=\"E-支持引用计数\"><a class=\"header-anchor\" href=\"#E-支持引用计数\"></a>E.支持引用计数</h5>\n<h5 id=\"F-支持池化\"><a class=\"header-anchor\" href=\"#F-支持池化\"></a>F.支持池化</h5>\n<h3 id=\"6-Bootstap-引导客户端和无连接协议\"><a class=\"header-anchor\" href=\"#6-Bootstap-引导客户端和无连接协议\"></a>6. Bootstap-引导客户端和无连接协议</h3>\n<p>Bootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel<br>\n<img src=\"http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg\" alt></p>\n<h2 id=\"单元测试\"><a class=\"header-anchor\" href=\"#单元测试\"></a>单元测试</h2>\n<p>使用EmbeddedChannel 测试 ChannelHandler</p>\n<ol>\n<li>测试入站消息</li>\n<li>测试出站消息</li>\n<li>测试异常处理</li>\n</ol>\n<h2 id=\"编解码器\"><a class=\"header-anchor\" href=\"#编解码器\"></a>编解码器</h2>\n<ul>\n<li>解码器<br>\n将字节解码为消息<br>\n将一种消息类型解码为另一种</li>\n<li>编码器<br>\n将消息编码为字节<br>\n将消息编码为消息</li>\n</ul>\n<h2 id=\"Netty服务端启动\"><a class=\"header-anchor\" href=\"#Netty服务端启动\"></a>Netty服务端启动</h2>\n<ol>\n<li>创建服务端Channel</li>\n<li>初始化服务端Channel</li>\n<li>注册Selector</li>\n<li>端口绑定，实现对本地端口的接听</li>\n</ol>\n<h2 id=\"预置的ChannelHandler和编解码器\"><a class=\"header-anchor\" href=\"#预置的ChannelHandler和编解码器\"></a>预置的ChannelHandler和编解码器</h2>\n<ol>\n<li>通过 SSL/TLS 保护 Netty 应用程序</li>\n<li>ChannelHandler处理 HTTP 和 HTTPS协议</li>\n<li>支持WebSocket</li>\n<li>ChannelHandler检测空闲连接以及超时</li>\n<li>FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域</li>\n<li>使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据</li>\n<li>使用UDP广播事件</li>\n</ol>\n<h3 id=\"创建服务端Channel\"><a class=\"header-anchor\" href=\"#创建服务端Channel\"></a>创建服务端Channel</h3>\n<p><strong>bind()[用户代码入口] -&gt;initAndRegister()[初始化并注册] -&gt;newChannel()[创建服务端channel]</strong><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim\" alt=\"mark\"></p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim\" alt=\"mark\"></p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim\" alt=\"mark\"></p>\n<h2 id=\"如何使用Netty进行RPC服务器的开发\"><a class=\"header-anchor\" href=\"#如何使用Netty进行RPC服务器的开发\"></a>如何使用Netty进行RPC服务器的开发?</h2>\n<ol>\n<li>定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</li>\n<li>服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</li>\n<li>客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</li>\n<li>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</li>\n<li>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim\" alt=\"mark\"> <strong>客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。</strong><br>\nNetty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</li>\n<li><img src=\"https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim\" alt=\"mark\"><br>\n<strong>客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</strong></li>\n</ol>\n<h2 id=\"附录\"><a class=\"header-anchor\" href=\"#附录\"></a>附录</h2>\n<h3 id=\"Netty疑问\"><a class=\"header-anchor\" href=\"#Netty疑问\"></a>Netty疑问</h3>\n<ol>\n<li>Netty是什么？<br>\nNetty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。</li>\n<li>使用Netty能够做什么？<br>\n①开发异步、非阻塞的TCP网络应用程序；<br>\n②开发异步、非阻塞的UDP网络应用程序；<br>\n③开发异步文件传输应用程序；<br>\n④开发异步HTTP服务端和客户端应用程序；<br>\n⑤提供对多种编解码框架的集成；<br>\n⑥提供形式多样的编解码基础类库；<br>\n⑦基于职责链模式的Pipeline-Handler机制；<br>\n⑧所有的IO操作都是异步的；<br>\n⑨IP黑白名单控制，性能统计；<br>\n⑩基于链路空闲事件检测的心跳检测；</li>\n<li>Netty在哪些行业得到了应用<br>\n**①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。<br>\n典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。<br>\n除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。<br>\n**②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。<br>\n**③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。<br>\n**④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。<br>\n**⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。</li>\n<li>使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？<br>\n传统的同步阻塞IO通信存在如下几个问题：<br>\n**①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>\n**②性能差：**频繁的线程上下文切换导致CPU利用效率不高；<br>\n**③可靠性差：*<em>由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>\n<strong>采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：</strong><br>\n①Nio采用Reactor模式</em>，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N &lt; 进程可用的最大句柄数)；<br>\n②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；<br>\n③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。<br>\n<strong>由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。</strong></li>\n<li>为什么不直接基于JDK的NIO类库编程呢？<br>\n即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。</li>\n<li>为什么要选择Netty框架？<br>\nNetty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。<br>\nNetty的优点总结如下：<br>\n①API使用简单，开发门槛低；<br>\n②功能强大，预置了多种编解码功能，支持多种主流协议；<br>\n③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；<br>\n④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；<br>\n⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；<br>\n⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；<br>\n⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。</li>\n</ol>\n<h2 id=\"代码\"><a class=\"header-anchor\" href=\"#代码\"></a>代码</h2>\n<h3 id=\"1-基于Netty的客户端和服务端的简单通信\"><a class=\"header-anchor\" href=\"#1-基于Netty的客户端和服务端的简单通信\"></a>1. 基于Netty的客户端和服务端的简单通信</h3>\n<h5 id=\"要点：\"><a class=\"header-anchor\" href=\"#要点：\"></a>要点：</h5>\n<p>①为初始化客户端， 创建了一个 Bootstrap 实例<br>\n②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；<br>\n③为服务器连接创建了一个 InetSocketAddress 实例；<br>\n④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；<br>\n⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"EchoServerHandler\"><a class=\"header-anchor\" href=\"#EchoServerHandler\"></a>EchoServerHandler</h3>\n<h5 id=\"channelRead-—对于每个传入的消息都要调用；\"><a class=\"header-anchor\" href=\"#channelRead-—对于每个传入的消息都要调用；\"></a>channelRead()—对于每个传入的消息都要调用；</h5>\n<h5 id=\"channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；\"><a class=\"header-anchor\" href=\"#channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；\"></a>channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；</h5>\n<h5 id=\"exceptionCaught-—在读取操作期间，有异常抛出时会调用。\"><a class=\"header-anchor\" href=\"#exceptionCaught-—在读取操作期间，有异常抛出时会调用。\"></a>exceptionCaught()—在读取操作期间，有异常抛出时会调用。</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标示一个ChannelHandler可以被多个 Channel 安全地共享</span></span><br><span class=\"line\">\t<span class=\"meta\">@Sharable</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class=\"line\">\t        ByteBuf in = (ByteBuf) msg;</span><br><span class=\"line\">\t        <span class=\"comment\">//将消息记录到控制台</span></span><br><span class=\"line\">\t        System.out.println(<span class=\"string\">\"Server received: \"</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class=\"line\">\t        <span class=\"comment\">//将接收到的消息写给发送者，而不冲刷出站消息</span></span><br><span class=\"line\">\t        ctx.write(in);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">    \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span><span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//将未决消息冲刷到远程节点，并且关闭该 Channel</span></span><br><span class=\"line\">        \tctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//打印异常栈跟踪</span></span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        <span class=\"comment\">//关闭该Channel</span></span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EchoServer\"><a class=\"header-anchor\" href=\"#EchoServer\"></a>EchoServer</h3>\n<h5 id=\"绑定到服务器将在其上监听并接受传入连接请求的端口；\"><a class=\"header-anchor\" href=\"#绑定到服务器将在其上监听并接受传入连接请求的端口；\"></a>绑定到服务器将在其上监听并接受传入连接请求的端口；</h5>\n<h5 id=\"配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。\"><a class=\"header-anchor\" href=\"#配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。\"></a>配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"Usage: \"</span> + EchoServer.class.getSimpleName() +<span class=\"string\">\" &lt;port&gt;\"</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//调用服务器的 start()方法</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> EchoServer(port).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> EchoServerHandler serverHandler = <span class=\"keyword\">new</span> EchoServerHandler();</span><br><span class=\"line\">        <span class=\"comment\">//(1) 创建EventLoopGroup</span></span><br><span class=\"line\">        EventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//(2) 创建ServerBootstrap</span></span><br><span class=\"line\">            ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            b.group(group)</span><br><span class=\"line\">                    <span class=\"comment\">//(3) 指定所使用的 NIO 传输 Channel</span></span><br><span class=\"line\">                    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                    <span class=\"comment\">//(4) 使用指定的端口设置套接字地址</span></span><br><span class=\"line\">                    .localAddress(<span class=\"keyword\">new</span> InetSocketAddress(port))</span><br><span class=\"line\">                    <span class=\"comment\">//(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline</span></span><br><span class=\"line\">                    .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例</span></span><br><span class=\"line\">                            <span class=\"comment\">//这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，</span></span><br><span class=\"line\">                            ch.pipeline().addLast(serverHandler);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">            <span class=\"comment\">//(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成</span></span><br><span class=\"line\">            ChannelFuture f = b.bind().sync();</span><br><span class=\"line\">            System.out.println(EchoServer.class.getName() +</span><br><span class=\"line\">                    <span class=\"string\">\" started and listening for connections on \"</span> + f.channel().localAddress());</span><br><span class=\"line\">            <span class=\"comment\">//(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成</span></span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//(8) 关闭 EventLoopGroup，释放所有的资源</span></span><br><span class=\"line\">            grop.shutdownGracefully().sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-ChannelHandler-实现客户端逻辑\"><a class=\"header-anchor\" href=\"#通过-ChannelHandler-实现客户端逻辑\"></a>通过 ChannelHandler 实现客户端逻辑</h3>\n<h5 id=\"channelActive-——在到服务器的连接已经建立之后将被调用；\"><a class=\"header-anchor\" href=\"#channelActive-——在到服务器的连接已经建立之后将被调用；\"></a>channelActive()——在到服务器的连接已经建立之后将被调用；</h5>\n<h5 id=\"channelRead0-——当服务器接收到一条消息时被调用\"><a class=\"header-anchor\" href=\"#channelRead0-——当服务器接收到一条消息时被调用\"></a>channelRead0()——当服务器接收到一条消息时被调用</h5>\n<h5 id=\"exceptionCaught-——在处理过程中引发异常时被调用。\"><a class=\"header-anchor\" href=\"#exceptionCaught-——在处理过程中引发异常时被调用。\"></a>exceptionCaught()——在处理过程中引发异常时被调用。</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span></span><br><span class=\"line\"><span class=\"comment\">//标记该类的实例可以被多个 Channel 共享</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClientHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">ByteBuf</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当被通知 Channel是活跃的时候，发送一条消息</span></span><br><span class=\"line\">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class=\"string\">\"Netty rocks!\"</span>,CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//记录已接收消息的转储</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Client received: \"</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">//在发生异常时，记录错误并关闭Channel</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"引导客户端\"><a class=\"header-anchor\" href=\"#引导客户端\"></a>引导客户端</h3>\n<h5 id=\"客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口\"><a class=\"header-anchor\" href=\"#客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口\"></a>客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoClient</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        EventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建 Bootstrap</span></span><br><span class=\"line\">            Bootstrap b = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">            <span class=\"comment\">//指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现</span></span><br><span class=\"line\">            b.group(group)</span><br><span class=\"line\">                    <span class=\"comment\">//适用于 NIO 传输的Channel 类型</span></span><br><span class=\"line\">                    .channel(NioSocketChannel.class)</span><br><span class=\"line\">                    <span class=\"comment\">//设置服务器的InetSocketAddress</span></span><br><span class=\"line\">                    .remoteAddress(<span class=\"keyword\">new</span> InetSocketAddress(host, port))</span><br><span class=\"line\">                    <span class=\"comment\">//在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例</span></span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span></span></span><br><span class=\"line\"><span class=\"function\">                                <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            ch.pipeline().addLast(</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> EchoClientHandler());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">            <span class=\"comment\">//连接到远程节点，阻塞等待直到连接完成</span></span><br><span class=\"line\">            ChannelFuture f = b.connect().sync();</span><br><span class=\"line\">            <span class=\"comment\">//阻塞，直到Channel 关闭</span></span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭线程池并且释放所有的资源</span></span><br><span class=\"line\">            group.shutdownGracefully().sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"Usage: \"</span> + EchoClient.class.getSimpleName() +</span><br><span class=\"line\">                    <span class=\"string\">\" &lt;host&gt; &lt;port&gt;\"</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> String host = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> EchoClient(host, port).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架\"><a class=\"header-anchor\" href=\"#2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架\"></a>2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架</h3>\n<h5 id=\"简易RPC有如下特性：\"><a class=\"header-anchor\" href=\"#简易RPC有如下特性：\"></a>简易RPC有如下特性：</h5>\n<ul>\n<li>服务异步调用的支持，回调函数callback的支持</li>\n<li>客户端使用长连接（在多次调用共享连接）</li>\n<li>服务端异步多线程处理RPC请求</li>\n<li>服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。</li>\n<li>通信：使用Netty作为通信框架</li>\n<li>Spring：使用Spring配置服务，加载Bean，扫描注解</li>\n<li>动态代理：客户端使用代理模式透明化服务调用</li>\n<li>消息编解码：使用Protostuff序列化和反序列化消息</li>\n</ul>\n<h5 id=\"RPC介绍\"><a class=\"header-anchor\" href=\"#RPC介绍\"></a>RPC介绍</h5>\n<p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim\" alt=\"mark\"></p>\n<ul>\n<li>服务端发布服务</li>\n</ul>\n<h5 id=\"服务注解：\"><a class=\"header-anchor\" href=\"#服务注解：\"></a>服务注解：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RpcService &#123;</span><br><span class=\"line\">    Class&lt;?&gt; value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"一个服务接口：\"><a class=\"header-anchor\" href=\"#一个服务接口：\"></a>一个服务接口：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HelloService</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">hello</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">\t   <span class=\"function\">String <span class=\"title\">hello</span><span class=\"params\">(Person person)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"一个服务实现：使用注解标注：\"><a class=\"header-anchor\" href=\"#一个服务实现：使用注解标注：\"></a>一个服务实现：使用注解标注：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RpcService</span>(HelloService.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">HelloService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello! \"</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello! \"</span> + person.getFirstName() + <span class=\"string\">\" \"</span> + person.getLastName()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"服务在启动的时候扫描得到所有的服务接口及其实现：\"><a class=\"header-anchor\" href=\"#服务在启动的时候扫描得到所有的服务接口及其实现：\"></a>服务在启动的时候扫描得到所有的服务接口及其实现：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext ctx)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">      Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class=\"line\">            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class=\"line\">            handlerMap.put(interfaceName, serviceBean);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在Zookeeper集群上注册服务地址：\"><a class=\"header-anchor\" href=\"#在Zookeeper集群上注册服务地址：\"></a>在Zookeeper集群上注册服务地址：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceRegistry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String registryAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceRegistry</span><span class=\"params\">(String registryAddress)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.registryAddress = registryAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ZooKeeper zk = connectServer();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zk != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                AddRootNode(zk); <span class=\"comment\">// Add root node if not exist</span></span><br><span class=\"line\">                createNode(zk, data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ZooKeeper <span class=\"title\">connectServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddRootNode</span><span class=\"params\">(ZooKeeper zk)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                zk.create(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createNode</span><span class=\"params\">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = data.getBytes();</span><br><span class=\"line\">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class=\"line\">            LOGGER.debug(<span class=\"string\">\"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)\"</span>, path, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedExceptin ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"客户端使用代理模式调用服务：\"><a class=\"header-anchor\" href=\"#客户端使用代理模式调用服务：\"></a>客户端使用代理模式调用服务：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceRegistry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String registryAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceRegistry</span><span class=\"params\">(String registryAddress)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.registryAddress = registryAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ZooKeeper zk = connectServer();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zk != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                AddRootNode(zk); <span class=\"comment\">// Add root node if not exist</span></span><br><span class=\"line\">                createNode(zk, data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ZooKeeper <span class=\"title\">connectServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddRootNode</span><span class=\"params\">(ZooKeeper zk)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                zk.create(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createNode</span><span class=\"params\">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = data.getBytes();</span><br><span class=\"line\">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class=\"line\">            LOGGER.debug(<span class=\"string\">\"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)\"</span>, path, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"从Zookeeper上获取服务地址：\"><a class=\"header-anchor\" href=\"#从Zookeeper上获取服务地址：\"></a>从Zookeeper上获取服务地址：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceDiscovery</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> List&lt;String&gt; dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String registryAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceDiscovery</span><span class=\"params\">(String registryAddress)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.registryAddress = registryAddress;</span><br><span class=\"line\">        ZooKeeper zk = connectServer();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zk != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            watchNode(zk);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">discover</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String data = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = dataList.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                data = dataList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                LOGGER.debug(<span class=\"string\">\"using only data: &#123;&#125;\"</span>, data);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class=\"line\">                LOGGER.debug(<span class=\"string\">\"using random data: &#123;&#125;\"</span>, data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ZooKeeper <span class=\"title\">connectServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">watchNode</span><span class=\"params\">(<span class=\"keyword\">final</span> ZooKeeper zk)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class=\"line\">                        watchNode(zk);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            List&lt;String&gt; dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String node : nodeList) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class=\"string\">\"/\"</span> + node, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                dataList.add(<span class=\"keyword\">new</span> String(bytes));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            LOGGER.debug(<span class=\"string\">\"node data: &#123;&#125;\"</span>, dataList);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.dataList = dataList;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException | InterrupteException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"消息编码-请求消息：\"><a class=\"header-anchor\" href=\"#消息编码-请求消息：\"></a>消息编码 请求消息：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RpcRequest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String requestId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String className;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String methodName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] parameters;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getRequestId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRequestId</span><span class=\"params\">(String requestId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.requestId = requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClassName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setClassName</span><span class=\"params\">(String className)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.className = className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMethodName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMethodName</span><span class=\"params\">(String methodName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methodName = methodName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parameterTypes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setParameterTypes</span><span class=\"params\">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parameterTypes = parameterTypes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] getParameters() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parameters;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setParameters</span><span class=\"params\">(Object[] parameters)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parameters = parameters;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"响应消息：\"><a class=\"header-anchor\" href=\"#响应消息：\"></a>响应消息：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RpcResponse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String requestId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String error;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getRequestId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRequestId</span><span class=\"params\">(String requestId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.requestId = requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setError</span><span class=\"params\">(String error)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.error = error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setResult</span><span class=\"params\">(Object result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"消息序列化和反序列化工具：（基于-Protostuff-实现）\"><a class=\"header-anchor\" href=\"#消息序列化和反序列化工具：（基于-Protostuff-实现）\"></a>消息序列化和反序列化工具：（基于 Protostuff 实现）</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializationUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Objenesis objenesis = <span class=\"keyword\">new</span> ObjenesisStd(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SerializationUtil</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Schema&lt;T&gt; <span class=\"title\">getSchema</span><span class=\"params\">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (schema == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            schema = RuntimeSchema.createFrom(cls);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (schema != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cachedSchema.put(cls, schema);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> schema;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 序列化（对象 -&gt; 字节数组）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"keyword\">byte</span>[] serialize(T obj) &#123;</span><br><span class=\"line\">        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();</span><br><span class=\"line\">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            buffer.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 反序列化（字节数组 -&gt; 对象）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">deserialize</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            T message = (T) objenesis.newInstance(cls);</span><br><span class=\"line\">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class=\"line\">            ProtostuffIOUtil.mergeFrom(data, message, schema);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStatexception(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"性能改进-服务端请求异步处理\"><a class=\"header-anchor\" href=\"#性能改进-服务端请求异步处理\"></a>性能改进 服务端请求异步处理</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx,<span class=\"keyword\">final</span> RpcRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        RpcServer.submit(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                LOGGER.debug(<span class=\"string\">\"Receive request \"</span> + request.getRequestId());</span><br><span class=\"line\">                RpcResponse response = <span class=\"keyword\">new</span> RpcResponse();</span><br><span class=\"line\">                response.setRequestId(request.getRequestId());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Object result = handle(request);</span><br><span class=\"line\">                    response.setResult(result);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                    response.setError(t.toString());</span><br><span class=\"line\">                    LOGGER.error(<span class=\"string\">\"RPC Server handle request error\"</span>,t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture channelFuture)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        LOGGER.debug(<span class=\"string\">\"Send response for request \"</span> + request.getRequestId());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"服务端长连接的管理\"><a class=\"header-anchor\" href=\"#服务端长连接的管理\"></a>服务端长连接的管理</h5>\n<p>客户端保持和服务进行<strong>长连接</strong>，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。<br>\n通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。</p>\n<h5 id=\"客户端请求异步处理\"><a class=\"header-anchor\" href=\"#客户端请求异步处理\"></a>客户端请求异步处理</h5>\n<p><strong>客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);</span><br><span class=\"line\">RPCFuture helloFuture = client.call(<span class=\"string\">\"hello\"</span>, Integer.toString(i));</span><br><span class=\"line\">String result = (String) helloFuture.get(<span class=\"number\">3000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"业界哪些流行的开源框架用Netty作为底层通信框架\"><a class=\"header-anchor\" href=\"#业界哪些流行的开源框架用Netty作为底层通信框架\"></a>业界哪些流行的开源框架用Netty作为底层通信框架</h2>\n<ul>\n<li>Dubbo： 阿里开源的高性能RPC框架</li>\n<li>RocketMQ： 阿里出品的高性能消息队列</li>\n<li>Spark： 炙手可热的大数据处理引擎，底层使用Netty</li>\n<li>Elasticsearch： 分布式多用户的全文搜索引擎</li>\n<li>Apache Cassandra：开源分布式搜索数据库</li>\n<li>Flink:分布式高性能高可用的流处理框架</li>\n<li>Netty-SocketIO的java服务端实现</li>\n<li>Spring5：使用Netty作为http协议框架</li>\n<li>Play：简单易用的http服务器</li>\n<li>Grpc:google开源的高性能rpc通信框架</li>\n<li>Infinispan：针对缓存的高并发键值对数据存储</li>\n<li>HornetQ：支持集群和多种协议，可嵌入、高性能的异步消息系统</li>\n<li>Vert.x轻量级高性能能JVM应用平台<br>\n-<br><a href=\"https://netty.io/wiki/adopters.html\" target=\"_blank\" rel=\"noopener\">完整的参考列表</a></li>\n</ul>\n<h2 id=\"业界有哪些公司在使用Netty\"><a class=\"header-anchor\" href=\"#业界有哪些公司在使用Netty\"></a>业界有哪些公司在使用Netty</h2>\n<p><strong>在大型企业中</strong>有：Apple、Twitter的Finagle、Facebook的Nifty、Google、Square、Instagram<br>\n<br><strong>在初创企业中</strong>有：做http长连接的<strong>Firebase</strong>、支持各种各样消息推送通知的<strong>Urban Airship</strong><br>\n<br><br> 当然，Netty也从这些项目中<strong>受益</strong>。通过实现 FTP、 SMTP、 HTTP 和 WebSocket 以及其他的基于二进制和基于文本的协议， Netty 扩展了它的应用范围及灵活性。</p>\n<h2 id=\"Netty是什么\"><a class=\"header-anchor\" href=\"#Netty是什么\"></a>Netty是什么</h2>\n<ol>\n<li><strong>异步</strong>和<strong>事件驱动</strong>的高性能网络通信框架。</li>\n<li>**特点:**它可以以任意的顺序响应在任意的时间点产生的事件，可以实现最高级别的可伸缩性。</li>\n<li>**目的:**用于快速开发高性能服务端和客户端</li>\n<li>**封装:**JDK底层BIO和NIO模型，提供高度可用的API,满足各类业务场景，其中ChannelHandler的热插拔机制解放了业务逻辑之外的细节问题，让业务逻辑的添加和删除非常容易</li>\n<li>自带编解码器解决拆包粘包问题，用户只关心业务逻辑</li>\n<li>精心设计的reactor线程模型支持高并发海量连接</li>\n<li>自带各种协议栈如http、websocket，处理任何一种通信协议都几乎不用亲自动手</li>\n<li>**架构方法和设计原则：**每个小点都和它的技术性内容一样重要，穷其精妙。如关注点分离–业务和网络逻辑解耦，模块化和可复用性，可测试性。</li>\n</ol>\n<h2 id=\"Netty的特性总结\"><a class=\"header-anchor\" href=\"#Netty的特性总结\"></a>Netty的特性总结</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/556rRkzcJvAd.jpg?imageslim\" alt=\"mark\"></p>\n<h2 id=\"Socket-Netty\"><a class=\"header-anchor\" href=\"#Socket-Netty\"></a>Socket &amp; Netty</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/HPr4j4YYplQS.jpg?imageslim\" alt=\"Socket &amp; Netty\"></p>\n<h2 id=\"Netty基本组件\"><a class=\"header-anchor\" href=\"#Netty基本组件\"></a>Netty基本组件</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/YR8r6PSGf0P3.jpg?imageslim\" alt=\"mark\"></p>\n<ul>\n<li>NioEventLoop -&gt;Thread</li>\n<li>Channel -&gt;Socket  \t<br>\nNioSocketChannel implements Channel<br>\nChennel is a nexus to a network socket or a component which is capable operations such as read,write,connect,and bind</li>\n<li>ByteBuf -&gt;IO Bytes<br>\nreadBytes()、writeBytes() and so on</li>\n<li>Pipline -&gt;Logic Chain 逻辑链</li>\n<li>ChannelHandler -&gt;Logic处理块</li>\n</ul>\n<h2 id=\"Netty核心组件\"><a class=\"header-anchor\" href=\"#Netty核心组件\"></a>Netty核心组件</h2>\n<h3 id=\"1-Channel-Socket\"><a class=\"header-anchor\" href=\"#1-Channel-Socket\"></a>1. Channel-Socket</h3>\n<p>Channel是通讯的载体，其基本构造是Socket<br>\n是对网络底层读写和连接原语言的抽象</p>\n<h3 id=\"2-EventLoop-控制流、多线程处理、并发\"><a class=\"header-anchor\" href=\"#2-EventLoop-控制流、多线程处理、并发\"></a>2. EventLoop-控制流、多线程处理、并发</h3>\n<p>定义了 Netty 的核心抽象， 用于处理连接的生命周期中所发生的事件</p>\n<h3 id=\"注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系\"><a class=\"header-anchor\" href=\"#注-Channel、-EventLoop、-Thread-以及EventLoopGroup-之间的关系\"></a>注: Channel、 EventLoop、 Thread 以及EventLoopGroup 之间的关系</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/f3SuURuf0NE8.jpg?imageslim\" alt=\"mark\">)</p>\n<h5 id=\"A-一个-EventLoopGroup-包含一个或者多个-EventLoop；\"><a class=\"header-anchor\" href=\"#A-一个-EventLoopGroup-包含一个或者多个-EventLoop；\"></a>A. 一个 EventLoopGroup 包含一个或者多个 EventLoop；</h5>\n<h5 id=\"B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定\"><a class=\"header-anchor\" href=\"#B-一个-EventLoop-在它的生命周期内只和一个-Thread-绑定\"></a>B. 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定</h5>\n<h5 id=\"C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；\"><a class=\"header-anchor\" href=\"#C-所有由-EventLoop-处理的-I-O-事件都将在它专有的-Thread-上被处理；\"></a>C. 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</h5>\n<h5 id=\"D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；\"><a class=\"header-anchor\" href=\"#D-一个-Channel-在它的生命周期内只注册于一个-EventLoop；\"></a>D. 一个 Channel 在它的生命周期内只注册于一个 EventLoop；</h5>\n<h5 id=\"E-一个-EventLoop-可能会被分配给一个或多个-Channel\"><a class=\"header-anchor\" href=\"#E-一个-EventLoop-可能会被分配给一个或多个-Channel\"></a>E. 一个 EventLoop 可能会被分配给一个或多个 Channel</h5>\n<h5 id=\"F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。\"><a class=\"header-anchor\" href=\"#F-一个给定-Channel-的-I-O-操作都是由相同的-Thread-执行的，-实际上消除了对于同步的需要。\"></a>F. 一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的， 实际上消除了对于同步的需要。</h5>\n<h3 id=\"3-ChannelFuture-异步通知\"><a class=\"header-anchor\" href=\"#3-ChannelFuture-异步通知\"></a>3. ChannelFuture-异步通知</h3>\n<p>Netty 中所有的 I/O 操作都是异步的,用于在之后的某个时间点确定其结果的方法</p>\n<h3 id=\"4-ChannelHandler和ChannelPipeline\"><a class=\"header-anchor\" href=\"#4-ChannelHandler和ChannelPipeline\"></a>4. ChannelHandler和ChannelPipeline</h3>\n<p>ChannelHandler负责Channel中的逻辑处理<br>\n其旨在简化应用程序处理逻辑的开发过程<br>\n充当了所有处理入站和出站数据的应用程序逻辑的容器<br>\nChannelHandler子接口：<br>\nChannelInboundHandler——处理入站数据以及各种状态变化<br>\nChannelOutboundHandler——处理出站数据并且允许拦截所有的操作<br>\nChannelInboundHandler的方法:<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/BYvKbknKEu5E.png?imageslim\" alt=\"mark\"><br>\nChannelOutboundHandler的方法:<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/PJSBnLn25B3G.png?imageslim\" alt=\"mark\"></p>\n<p>ChannelPipeline 提供了 ChannelHandler链的容器<br>\n定义了用于在该链上传播入站和出站事件流的API</p>\n<h3 id=\"5-ByteBuf-Netty的数据容器\"><a class=\"header-anchor\" href=\"#5-ByteBuf-Netty的数据容器\"></a>5. ByteBuf-Netty的数据容器</h3>\n<p>Java NIO提供了ByteBuffer作为它的字节容器<br>\nNetty的ByteBuffer替代品是ByteBuf</p>\n<h5 id=\"A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；\"><a class=\"header-anchor\" href=\"#A-它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；\"></a>A. 它可以被用户自定义的缓冲区类型扩展，通过内置的复合缓冲区类型实现了透明的零拷贝；</h5>\n<h5 id=\"B-容量可以按需增长（类似于-JDK-的-StringBuilder）\"><a class=\"header-anchor\" href=\"#B-容量可以按需增长（类似于-JDK-的-StringBuilder）\"></a>B.容量可以按需增长（类似于 JDK 的 StringBuilder）</h5>\n<h5 id=\"C-读和写使用了不同的索引\"><a class=\"header-anchor\" href=\"#C-读和写使用了不同的索引\"></a>C.读和写使用了不同的索引</h5>\n<h5 id=\"D-支持方法的链式调用\"><a class=\"header-anchor\" href=\"#D-支持方法的链式调用\"></a>D.支持方法的链式调用</h5>\n<h5 id=\"E-支持引用计数\"><a class=\"header-anchor\" href=\"#E-支持引用计数\"></a>E.支持引用计数</h5>\n<h5 id=\"F-支持池化\"><a class=\"header-anchor\" href=\"#F-支持池化\"></a>F.支持池化</h5>\n<h3 id=\"6-Bootstap-引导客户端和无连接协议\"><a class=\"header-anchor\" href=\"#6-Bootstap-引导客户端和无连接协议\"></a>6. Bootstap-引导客户端和无连接协议</h3>\n<p>Bootstrap类负责为客户端和使用无连接协议的应用程序创建 Channel<br>\n<img src=\"http://ww1.sinaimg.cn/large/005Vjva3gy1g2q8bxb9z6j30h109mgn0.jpg\" alt></p>\n<h2 id=\"单元测试\"><a class=\"header-anchor\" href=\"#单元测试\"></a>单元测试</h2>\n<p>使用EmbeddedChannel 测试 ChannelHandler</p>\n<ol>\n<li>测试入站消息</li>\n<li>测试出站消息</li>\n<li>测试异常处理</li>\n</ol>\n<h2 id=\"编解码器\"><a class=\"header-anchor\" href=\"#编解码器\"></a>编解码器</h2>\n<ul>\n<li>解码器<br>\n将字节解码为消息<br>\n将一种消息类型解码为另一种</li>\n<li>编码器<br>\n将消息编码为字节<br>\n将消息编码为消息</li>\n</ul>\n<h2 id=\"Netty服务端启动\"><a class=\"header-anchor\" href=\"#Netty服务端启动\"></a>Netty服务端启动</h2>\n<ol>\n<li>创建服务端Channel</li>\n<li>初始化服务端Channel</li>\n<li>注册Selector</li>\n<li>端口绑定，实现对本地端口的接听</li>\n</ol>\n<h2 id=\"预置的ChannelHandler和编解码器\"><a class=\"header-anchor\" href=\"#预置的ChannelHandler和编解码器\"></a>预置的ChannelHandler和编解码器</h2>\n<ol>\n<li>通过 SSL/TLS 保护 Netty 应用程序</li>\n<li>ChannelHandler处理 HTTP 和 HTTPS协议</li>\n<li>支持WebSocket</li>\n<li>ChannelHandler检测空闲连接以及超时</li>\n<li>FileRegion,通过支持零拷贝的文件传输的Channel来发送的文件区域</li>\n<li>使用JDK、JBOSS Marshalling、Protocol Buffers序列化数据</li>\n<li>使用UDP广播事件</li>\n</ol>\n<h3 id=\"创建服务端Channel\"><a class=\"header-anchor\" href=\"#创建服务端Channel\"></a>创建服务端Channel</h3>\n<p><strong>bind()[用户代码入口] -&gt;initAndRegister()[初始化并注册] -&gt;newChannel()[创建服务端channel]</strong><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/IJvpJbzfX4Ik.jpg?imageslim\" alt=\"mark\"></p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/T5pcP0vbkpy8.jpg?imageslim\" alt=\"mark\"></p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/DaqDEJmk1sOn.jpg?imageslim\" alt=\"mark\"></p>\n<h2 id=\"如何使用Netty进行RPC服务器的开发\"><a class=\"header-anchor\" href=\"#如何使用Netty进行RPC服务器的开发\"></a>如何使用Netty进行RPC服务器的开发?</h2>\n<ol>\n<li>定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</li>\n<li>服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</li>\n<li>客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</li>\n<li>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</li>\n<li>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/AVRTu5aellyr.png?imageslim\" alt=\"mark\"> <strong>客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，通过消息回调机制实现。</strong><br>\nNetty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</li>\n<li><img src=\"https://img.jinguo.tech/blog/20200116/hLvJCvXn7BzQ.png?imageslim\" alt=\"mark\"><br>\n<strong>客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序。    Netty把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</strong></li>\n</ol>\n<h2 id=\"附录\"><a class=\"header-anchor\" href=\"#附录\"></a>附录</h2>\n<h3 id=\"Netty疑问\"><a class=\"header-anchor\" href=\"#Netty疑问\"></a>Netty疑问</h3>\n<ol>\n<li>Netty是什么？<br>\nNetty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是：异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。</li>\n<li>使用Netty能够做什么？<br>\n①开发异步、非阻塞的TCP网络应用程序；<br>\n②开发异步、非阻塞的UDP网络应用程序；<br>\n③开发异步文件传输应用程序；<br>\n④开发异步HTTP服务端和客户端应用程序；<br>\n⑤提供对多种编解码框架的集成；<br>\n⑥提供形式多样的编解码基础类库；<br>\n⑦基于职责链模式的Pipeline-Handler机制；<br>\n⑧所有的IO操作都是异步的；<br>\n⑨IP黑白名单控制，性能统计；<br>\n⑩基于链路空闲事件检测的心跳检测；</li>\n<li>Netty在哪些行业得到了应用<br>\n**①互联网行业：**随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于Tomcat等Web容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。<br>\n典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用Netty进行异步/同步通信。除了Dubbo之外，淘宝的消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能、异步通信。<br>\n除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用Netty构建高性能、分布式的网络服务器。<br>\n**②大数据领域：**经典的Hadoop的高性能通信和序列化组件Avro的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现。大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于Netty的综合性能是目前各个成熟NIO框架中最高的，因此，往往会被选中用作大数据各节点间的通信。<br>\n**③企业软件：**企业和IT集成需要ESB，Netty对多协议支持、私有协议定制的简洁性和高性能是ESB RPC框架的首选通信组件。事实上，很多企业总线厂商会选择Netty作为基础通信组件，用于企业的IT集成。<br>\n**④通信行业：**Netty的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。<br>\n**⑤游戏行业：**无论是手游服务端、还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了TCP/UDP和HTTP协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过Netty进行高性能的通信。</li>\n<li>使用传统的Socket开发挺简单的，我为什么要切换到NIO进行编程呢？<br>\n传统的同步阻塞IO通信存在如下几个问题：<br>\n**①线程模型存在致命缺陷：**一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>\n**②性能差：**频繁的线程上下文切换导致CPU利用效率不高；<br>\n**③可靠性差：*<em>由于所有的IO操作都是同步的，所以业务线程只要进行IO操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>\n<strong>采用非阻塞IO（NIO）之后，同步阻塞IO的三个缺陷都将迎刃而解：</strong><br>\n①Nio采用Reactor模式</em>，一个Reactor线程聚合一个多路复用器Selector，它可以同时注册、监听和轮询成百上千个Channel，一个IO线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为CPU核数 + 1， N &lt; 进程可用的最大句柄数)；<br>\n②由于IO线程总数有限，不会存在频繁的IO线程之间上下文切换和竞争，CPU利用率高；<br>\n③所有的IO操作都是异步的，即使业务线程直接进行IO操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。<br>\n<strong>由于切换到NIO编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用NIO进行通信已经逐渐成为主流。</strong></li>\n<li>为什么不直接基于JDK的NIO类库编程呢？<br>\n即便抛开代码和NIO类库复杂性不谈，一个高性能、高可靠性的NIO服务端开发和维护成本都是非常高的，开发者需要具有丰富的NIO编程经验和网络维护经验，很多时候甚至需要通过抓包来定位问题。也许开发出一套NIO程序需要1个月，但是它的稳定很可能需要1年甚至更长的时间，这也就是为什么我不建议直接使用JDK NIO类库进行通信开发的一个重要原因。</li>\n<li>为什么要选择Netty框架？<br>\nNetty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro使用Netty作为通信框架。很多其它业界主流的RPC和分布式服务框架，也使用Netty来构建高性能的异步通信能力。<br>\nNetty的优点总结如下：<br>\n①API使用简单，开发门槛低；<br>\n②功能强大，预置了多种编解码功能，支持多种主流协议；<br>\n③定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；<br>\n④性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；<br>\n⑤成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；<br>\n⑥社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；<br>\n⑦经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它完全满足不同行业的商用标准。</li>\n</ol>\n<h2 id=\"代码\"><a class=\"header-anchor\" href=\"#代码\"></a>代码</h2>\n<h3 id=\"1-基于Netty的客户端和服务端的简单通信\"><a class=\"header-anchor\" href=\"#1-基于Netty的客户端和服务端的简单通信\"></a>1. 基于Netty的客户端和服务端的简单通信</h3>\n<h5 id=\"要点：\"><a class=\"header-anchor\" href=\"#要点：\"></a>要点：</h5>\n<p>①为初始化客户端， 创建了一个 Bootstrap 实例<br>\n②为进行事件处理分配了一个 NioEventLoopGroup 实例， 其中事件处理包括创建新的连接以及处理入站和出站数据；<br>\n③为服务器连接创建了一个 InetSocketAddress 实例；<br>\n④当连接被建立时，一个 EchoClientHandler 实例会被安装到（该 Channel 的）ChannelPipeline 中；<br>\n⑤在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/cIhXBNgNE4y8.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"EchoServerHandler\"><a class=\"header-anchor\" href=\"#EchoServerHandler\"></a>EchoServerHandler</h3>\n<h5 id=\"channelRead-—对于每个传入的消息都要调用；\"><a class=\"header-anchor\" href=\"#channelRead-—对于每个传入的消息都要调用；\"></a>channelRead()—对于每个传入的消息都要调用；</h5>\n<h5 id=\"channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；\"><a class=\"header-anchor\" href=\"#channelReadComplete-—通知ChannelInboundHandler最后一次对channelRead-的调用是当前批量读取中的最后一条消息；\"></a>channelReadComplete()—通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息；</h5>\n<h5 id=\"exceptionCaught-—在读取操作期间，有异常抛出时会调用。\"><a class=\"header-anchor\" href=\"#exceptionCaught-—在读取操作期间，有异常抛出时会调用。\"></a>exceptionCaught()—在读取操作期间，有异常抛出时会调用。</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标示一个ChannelHandler可以被多个 Channel 安全地共享</span></span><br><span class=\"line\">\t<span class=\"meta\">@Sharable</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class=\"line\">\t        ByteBuf in = (ByteBuf) msg;</span><br><span class=\"line\">\t        <span class=\"comment\">//将消息记录到控制台</span></span><br><span class=\"line\">\t        System.out.println(<span class=\"string\">\"Server received: \"</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class=\"line\">\t        <span class=\"comment\">//将接收到的消息写给发送者，而不冲刷出站消息</span></span><br><span class=\"line\">\t        ctx.write(in);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">    \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span><span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//将未决消息冲刷到远程节点，并且关闭该 Channel</span></span><br><span class=\"line\">        \tctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//打印异常栈跟踪</span></span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        <span class=\"comment\">//关闭该Channel</span></span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EchoServer\"><a class=\"header-anchor\" href=\"#EchoServer\"></a>EchoServer</h3>\n<h5 id=\"绑定到服务器将在其上监听并接受传入连接请求的端口；\"><a class=\"header-anchor\" href=\"#绑定到服务器将在其上监听并接受传入连接请求的端口；\"></a>绑定到服务器将在其上监听并接受传入连接请求的端口；</h5>\n<h5 id=\"配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。\"><a class=\"header-anchor\" href=\"#配置-Channel，以将有关的入站消息通知给-EchoServerHandler-实例。\"></a>配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"Usage: \"</span> + EchoServer.class.getSimpleName() +<span class=\"string\">\" &lt;port&gt;\"</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//设置端口值（如果端口参数的格式不正确，则抛出一个NumberFormatException）</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//调用服务器的 start()方法</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> EchoServer(port).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> EchoServerHandler serverHandler = <span class=\"keyword\">new</span> EchoServerHandler();</span><br><span class=\"line\">        <span class=\"comment\">//(1) 创建EventLoopGroup</span></span><br><span class=\"line\">        EventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//(2) 创建ServerBootstrap</span></span><br><span class=\"line\">            ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            b.group(group)</span><br><span class=\"line\">                    <span class=\"comment\">//(3) 指定所使用的 NIO 传输 Channel</span></span><br><span class=\"line\">                    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                    <span class=\"comment\">//(4) 使用指定的端口设置套接字地址</span></span><br><span class=\"line\">                    .localAddress(<span class=\"keyword\">new</span> InetSocketAddress(port))</span><br><span class=\"line\">                    <span class=\"comment\">//(5) 添加一个EchoServerHandler到于Channel的 ChannelPipeline</span></span><br><span class=\"line\">                    .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例</span></span><br><span class=\"line\">                            <span class=\"comment\">//这里对于所有的客户端来说，都会使用同一个 EchoServerHandler，因为其被标注@Sharable，</span></span><br><span class=\"line\">                            ch.pipeline().addLast(serverHandler);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">            <span class=\"comment\">//(6) 异步地绑定服务器；调用 sync()方法阻塞等待直到绑定完成</span></span><br><span class=\"line\">            ChannelFuture f = b.bind().sync();</span><br><span class=\"line\">            System.out.println(EchoServer.class.getName() +</span><br><span class=\"line\">                    <span class=\"string\">\" started and listening for connections on \"</span> + f.channel().localAddress());</span><br><span class=\"line\">            <span class=\"comment\">//(7) 获取 Channel 的CloseFuture，并且阻塞当前线程直到它完成</span></span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//(8) 关闭 EventLoopGroup，释放所有的资源</span></span><br><span class=\"line\">            grop.shutdownGracefully().sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-ChannelHandler-实现客户端逻辑\"><a class=\"header-anchor\" href=\"#通过-ChannelHandler-实现客户端逻辑\"></a>通过 ChannelHandler 实现客户端逻辑</h3>\n<h5 id=\"channelActive-——在到服务器的连接已经建立之后将被调用；\"><a class=\"header-anchor\" href=\"#channelActive-——在到服务器的连接已经建立之后将被调用；\"></a>channelActive()——在到服务器的连接已经建立之后将被调用；</h5>\n<h5 id=\"channelRead0-——当服务器接收到一条消息时被调用\"><a class=\"header-anchor\" href=\"#channelRead0-——当服务器接收到一条消息时被调用\"></a>channelRead0()——当服务器接收到一条消息时被调用</h5>\n<h5 id=\"exceptionCaught-——在处理过程中引发异常时被调用。\"><a class=\"header-anchor\" href=\"#exceptionCaught-——在处理过程中引发异常时被调用。\"></a>exceptionCaught()——在处理过程中引发异常时被调用。</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span></span><br><span class=\"line\"><span class=\"comment\">//标记该类的实例可以被多个 Channel 共享</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClientHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">ByteBuf</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当被通知 Channel是活跃的时候，发送一条消息</span></span><br><span class=\"line\">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class=\"string\">\"Netty rocks!\"</span>,CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//记录已接收消息的转储</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Client received: \"</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">//在发生异常时，记录错误并关闭Channel</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx,Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"引导客户端\"><a class=\"header-anchor\" href=\"#引导客户端\"></a>引导客户端</h3>\n<h5 id=\"客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口\"><a class=\"header-anchor\" href=\"#客户端是使用主机和端口参数来连接远程地址，也就是Echo-服务器的地址，而不是绑定到一个一直被监听的端口\"></a>客户端是使用主机和端口参数来连接远程地址，也就是Echo 服务器的地址，而不是绑定到一个一直被监听的端口</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoClient</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        EventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建 Bootstrap</span></span><br><span class=\"line\">            Bootstrap b = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">            <span class=\"comment\">//指定 EventLoopGroup 以处理客户端事件；需要适用于 NIO 的实现</span></span><br><span class=\"line\">            b.group(group)</span><br><span class=\"line\">                    <span class=\"comment\">//适用于 NIO 传输的Channel 类型</span></span><br><span class=\"line\">                    .channel(NioSocketChannel.class)</span><br><span class=\"line\">                    <span class=\"comment\">//设置服务器的InetSocketAddress</span></span><br><span class=\"line\">                    .remoteAddress(<span class=\"keyword\">new</span> InetSocketAddress(host, port))</span><br><span class=\"line\">                    <span class=\"comment\">//在创建Channel时，向 ChannelPipeline中添加一个 EchoClientHandler实例</span></span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span></span></span><br><span class=\"line\"><span class=\"function\">                                <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            ch.pipeline().addLast(</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> EchoClientHandler());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">            <span class=\"comment\">//连接到远程节点，阻塞等待直到连接完成</span></span><br><span class=\"line\">            ChannelFuture f = b.connect().sync();</span><br><span class=\"line\">            <span class=\"comment\">//阻塞，直到Channel 关闭</span></span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭线程池并且释放所有的资源</span></span><br><span class=\"line\">            group.shutdownGracefully().sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            System.err.println(<span class=\"string\">\"Usage: \"</span> + EchoClient.class.getSimpleName() +</span><br><span class=\"line\">                    <span class=\"string\">\" &lt;host&gt; &lt;port&gt;\"</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> String host = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> EchoClient(host, port).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架\"><a class=\"header-anchor\" href=\"#2-基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架\"></a>2. 基于Zookeeper、Netty和Spring的轻量级的分布式RPC框架</h3>\n<h5 id=\"简易RPC有如下特性：\"><a class=\"header-anchor\" href=\"#简易RPC有如下特性：\"></a>简易RPC有如下特性：</h5>\n<ul>\n<li>服务异步调用的支持，回调函数callback的支持</li>\n<li>客户端使用长连接（在多次调用共享连接）</li>\n<li>服务端异步多线程处理RPC请求</li>\n<li>服务发布与订阅：服务端使用Zookeeper注册服务地址，客户端从Zookeeper获取可用的服务地址。</li>\n<li>通信：使用Netty作为通信框架</li>\n<li>Spring：使用Spring配置服务，加载Bean，扫描注解</li>\n<li>动态代理：客户端使用代理模式透明化服务调用</li>\n<li>消息编解码：使用Protostuff序列化和反序列化消息</li>\n</ul>\n<h5 id=\"RPC介绍\"><a class=\"header-anchor\" href=\"#RPC介绍\"></a>RPC介绍</h5>\n<p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC可以很好的解耦系统，如WebService就是一种基于Http协议的RPC。</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/b2FvBccopV9G.png?imageslim\" alt=\"mark\"></p>\n<ul>\n<li>服务端发布服务</li>\n</ul>\n<h5 id=\"服务注解：\"><a class=\"header-anchor\" href=\"#服务注解：\"></a>服务注解：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RpcService &#123;</span><br><span class=\"line\">    Class&lt;?&gt; value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"一个服务接口：\"><a class=\"header-anchor\" href=\"#一个服务接口：\"></a>一个服务接口：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HelloService</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">hello</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">\t   <span class=\"function\">String <span class=\"title\">hello</span><span class=\"params\">(Person person)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"一个服务实现：使用注解标注：\"><a class=\"header-anchor\" href=\"#一个服务实现：使用注解标注：\"></a>一个服务实现：使用注解标注：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RpcService</span>(HelloService.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">HelloService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello! \"</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello! \"</span> + person.getFirstName() + <span class=\"string\">\" \"</span> + person.getLastName()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"服务在启动的时候扫描得到所有的服务接口及其实现：\"><a class=\"header-anchor\" href=\"#服务在启动的时候扫描得到所有的服务接口及其实现：\"></a>服务在启动的时候扫描得到所有的服务接口及其实现：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext ctx)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">      Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (MapUtils.isNotEmpty(serviceBeanMap)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class=\"line\">            String interfaceName =              serviceBean.getClass().getAnnotation(RpcService.class).value().getName();</span><br><span class=\"line\">            handlerMap.put(interfaceName, serviceBean);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"在Zookeeper集群上注册服务地址：\"><a class=\"header-anchor\" href=\"#在Zookeeper集群上注册服务地址：\"></a>在Zookeeper集群上注册服务地址：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceRegistry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String registryAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceRegistry</span><span class=\"params\">(String registryAddress)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.registryAddress = registryAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ZooKeeper zk = connectServer();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zk != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                AddRootNode(zk); <span class=\"comment\">// Add root node if not exist</span></span><br><span class=\"line\">                createNode(zk, data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ZooKeeper <span class=\"title\">connectServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddRootNode</span><span class=\"params\">(ZooKeeper zk)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                zk.create(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createNode</span><span class=\"params\">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = data.getBytes();</span><br><span class=\"line\">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class=\"line\">            LOGGER.debug(<span class=\"string\">\"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)\"</span>, path, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedExceptin ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"客户端使用代理模式调用服务：\"><a class=\"header-anchor\" href=\"#客户端使用代理模式调用服务：\"></a>客户端使用代理模式调用服务：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceRegistry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceRegistry.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String registryAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceRegistry</span><span class=\"params\">(String registryAddress)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.registryAddress = registryAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ZooKeeper zk = connectServer();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zk != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                AddRootNode(zk); <span class=\"comment\">// Add root node if not exist</span></span><br><span class=\"line\">                createNode(zk, data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ZooKeeper <span class=\"title\">connectServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddRootNode</span><span class=\"params\">(ZooKeeper zk)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Stat s = zk.exists(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                zk.create(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            LOGGER.error(e.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createNode</span><span class=\"params\">(ZooKeeper zk, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = data.getBytes();</span><br><span class=\"line\">            String path = zk.create(Constant.ZK_DATA_PATH, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class=\"line\">            LOGGER.debug(<span class=\"string\">\"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)\"</span>, path, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"从Zookeeper上获取服务地址：\"><a class=\"header-anchor\" href=\"#从Zookeeper上获取服务地址：\"></a>从Zookeeper上获取服务地址：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceDiscovery</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(ServiceDiscovery.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> List&lt;String&gt; dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String registryAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceDiscovery</span><span class=\"params\">(String registryAddress)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.registryAddress = registryAddress;</span><br><span class=\"line\">        ZooKeeper zk = connectServer();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zk != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            watchNode(zk);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">discover</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String data = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = dataList.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                data = dataList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                LOGGER.debug(<span class=\"string\">\"using only data: &#123;&#125;\"</span>, data);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                data = dataList.get(ThreadLocalRandom.current().nextInt(size));</span><br><span class=\"line\">                LOGGER.debug(<span class=\"string\">\"using random data: &#123;&#125;\"</span>, data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ZooKeeper <span class=\"title\">connectServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(registryAddress, Constant.ZK_SESSION_TIMEOUT, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zk;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">watchNode</span><span class=\"params\">(<span class=\"keyword\">final</span> ZooKeeper zk)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            List&lt;String&gt; nodeList = zk.getChildren(Constant.ZK_REGISTRY_PATH, <span class=\"keyword\">new</span> Watcher() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent event)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class=\"line\">                        watchNode(zk);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            List&lt;String&gt; dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String node : nodeList) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bytes = zk.getData(Constant.ZK_REGISTRY_PATH + <span class=\"string\">\"/\"</span> + node, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                dataList.add(<span class=\"keyword\">new</span> String(bytes));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            LOGGER.debug(<span class=\"string\">\"node data: &#123;&#125;\"</span>, dataList);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.dataList = dataList;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException | InterrupteException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"消息编码-请求消息：\"><a class=\"header-anchor\" href=\"#消息编码-请求消息：\"></a>消息编码 请求消息：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RpcRequest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String requestId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String className;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String methodName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] parameters;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getRequestId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRequestId</span><span class=\"params\">(String requestId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.requestId = requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getClassName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setClassName</span><span class=\"params\">(String className)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.className = className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMethodName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> methodName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMethodName</span><span class=\"params\">(String methodName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methodName = methodName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt;[] getParameterTypes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parameterTypes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setParameterTypes</span><span class=\"params\">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parameterTypes = parameterTypes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] getParameters() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parameters;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setParameters</span><span class=\"params\">(Object[] parameters)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parameters = parameters;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"响应消息：\"><a class=\"header-anchor\" href=\"#响应消息：\"></a>响应消息：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RpcResponse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String requestId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String error;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getRequestId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRequestId</span><span class=\"params\">(String requestId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.requestId = requestId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setError</span><span class=\"params\">(String error)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.error = error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setResult</span><span class=\"params\">(Object result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"消息序列化和反序列化工具：（基于-Protostuff-实现）\"><a class=\"header-anchor\" href=\"#消息序列化和反序列化工具：（基于-Protostuff-实现）\"></a>消息序列化和反序列化工具：（基于 Protostuff 实现）</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializationUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Objenesis objenesis = <span class=\"keyword\">new</span> ObjenesisStd(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SerializationUtil</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Schema&lt;T&gt; <span class=\"title\">getSchema</span><span class=\"params\">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (schema == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            schema = RuntimeSchema.createFrom(cls);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (schema != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cachedSchema.put(cls, schema);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> schema;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 序列化（对象 -&gt; 字节数组）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"keyword\">byte</span>[] serialize(T obj) &#123;</span><br><span class=\"line\">        Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass();</span><br><span class=\"line\">        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ProtostuffIOUtil.toByteArray(obj, schema, buffer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            buffer.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 反序列化（字节数组 -&gt; 对象）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">deserialize</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            T message = (T) objenesis.newInstance(cls);</span><br><span class=\"line\">            Schema&lt;T&gt; schema = getSchema(cls);</span><br><span class=\"line\">            ProtostuffIOUtil.mergeFrom(data, message, schema);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStatexception(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"性能改进-服务端请求异步处理\"><a class=\"header-anchor\" href=\"#性能改进-服务端请求异步处理\"></a>性能改进 服务端请求异步处理</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx,<span class=\"keyword\">final</span> RpcRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        RpcServer.submit(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                LOGGER.debug(<span class=\"string\">\"Receive request \"</span> + request.getRequestId());</span><br><span class=\"line\">                RpcResponse response = <span class=\"keyword\">new</span> RpcResponse();</span><br><span class=\"line\">                response.setRequestId(request.getRequestId());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Object result = handle(request);</span><br><span class=\"line\">                    response.setResult(result);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                    response.setError(t.toString());</span><br><span class=\"line\">                    LOGGER.error(<span class=\"string\">\"RPC Server handle request error\"</span>,t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture channelFuture)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        LOGGER.debug(<span class=\"string\">\"Send response for request \"</span> + request.getRequestId());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"服务端长连接的管理\"><a class=\"header-anchor\" href=\"#服务端长连接的管理\"></a>服务端长连接的管理</h5>\n<p>客户端保持和服务进行<strong>长连接</strong>，不需要每次调用服务的时候进行连接，长连接的管理（通过Zookeeper获取有效的地址）。<br>\n通过监听Zookeeper服务节点值的变化，动态更新客户端和服务端保持的长连接。这个事情现在放在客户端在做，客户端保持了和所有可用服务的长连接，给客户端和服务端都造成了压力，需要解耦这个实现。</p>\n<h5 id=\"客户端请求异步处理\"><a class=\"header-anchor\" href=\"#客户端请求异步处理\"></a>客户端请求异步处理</h5>\n<p><strong>客户端请求异步处理的支持，不需要同步等待：发送一个异步请求，返回Future，通过Future的callback机制获取结果。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IAsyncObjectProxy client = rpcClient.createAsync(HelloService.class);</span><br><span class=\"line\">RPCFuture helloFuture = client.call(<span class=\"string\">\"hello\"</span>, Integer.toString(i));</span><br><span class=\"line\">String result = (String) helloFuture.get(<span class=\"number\">3000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>\n"},{"title":"storm(心得)","date":"2020-01-16T08:08:52.000Z","_content":"\n# Storm入门\n\nStorm是一个**分布式的**，可靠的，容错的**数据流处理系统**。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。   \nStorm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等\nStorm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的  \nStorm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。\n一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。  \n注：Storm中的核心术语  \n**spout**龙卷，读取原始数据为bolt提供数据  \n**bolt** 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果    \n**nimbus** 雨云，主节点的守护进程，负责为工作节点分发任务  \n**topology** 拓扑结构，Storm的一个任务单元  \n**define field(s)** 定义域，由spout或bolt提供，被bolt接收  \n\n## Storm应用案例\n\n- 数据处理流，Storm不需要中间队列\n- 连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。\n- **分布式远程过程调用**\n- 频繁的CPU密集型操作**并行化**。\n\n## Storm组件\n\n在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。  \n主节点运行着一个叫做**Nimbus**的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。    \n**Supervisor**守护进程作为拓扑的一部分运行在工作节点上。  \n一个Storm**拓扑结构**在不同的机器上运行着众多的工作节点。\n因为Storm在**Zookeeper**或本地磁盘上**维持所有的集群状态**，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康  \n在系统底层，Storm使用了**zeromq**，这是一种先进的，可嵌入的**网络通讯库**，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets      \n\n### 注：zeromq的特性  \n\n- 一个并发架构的Socket库  \n- 对于集群产品和超级计算，比TCP要快    \n- 可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信  \n- 异步I / O的可扩展的多核消息传递应用程序  \n- 利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接  \n  注：最新的Storm已不再必须依赖**ZeroMQ**，各种依赖的库和软件也已经有更新的版本。\n  最近版本的Storm支持使用**netty**做消息队列。\n  Netty提供**异步的、事件驱动**的网络应用程序框架和工具，用以快速开发**高性能、高可靠性的**网络服务器和客户端程序。正好是 storm所需要的。\n\n## Storm的特性\n\n- 简化编程：使用Storm，实现实时处理的复杂性被大大降低了\n- 开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发\n- 容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。\n- 可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。\n- 可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。\n- 快速：速度是驱动Storm设计的一个关键因素\n- 事务性：可以为几乎任何计算得到恰好一次消息语义\n\n## 安装Storm集群\n\n要手工安装Storm，需要先安装以下软件  \n\n1. Zookeeper集群\n2. Java\n3. Python\n4. Unzip命令\n\n### 注：\n\nNimbus和管理进程将要依赖Java、Python和unzip命令\n\n### 前期准备\n\n1. 准备搭建3节点集群,准备3个虚拟机node1,node2,node3  \n2. 配置好hosts映射文件和互相的ssh免密登录  \n3. 配置好JDK  \n   注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好\n\n### 安装storm\n\n1. 准备好storm安装包\n2. 上传解压重命名为storm到/export/server路径下\n3. 修改配置文件 storm.yaml\n\n### 运行\n\n- 前台启动 (前台启动会占用窗口)  \n  （1）在node1上启动 nimbus进程(主节点) 和 web UI  \n  （2）在 node2 和 node3 上启动 supervisor(从节点)\n- 后台启动\n\n#### ssh脚本实现一键启动\n\n```shell\n.#!/bin/bash\nsource /etc/profile\nnohup /export/server/storm/bin/storm nimbus >/dev/null 2>&1 &\necho \"node1 nimbus is running\"\nnohup /export/server/storm/bin/storm ui >/dev/null 2>&1 &\necho \"node1 core is running\"\nfor host in node2 node3\ndo\n{\nssh $host \"source /etc/profile;nohup /export/server/storm/bin/storm supervisor >/dev/null 2>&1 &\"\necho \"$host Supervisor is running\"\n}\ndone\n```\n\n### 进入web页面查看集群\n\n## 使用入门\n\n### MAVEN依赖\n\n```xml\n<dependency>\n    <groupId>org.apache.storm</groupId>\n    <artifactId>storm-core</artifactId>\n    <version>1.1.1</version>\n    <!-- 目前<scope>可以使用5个值：\n    * compile，缺省值，适用于所有阶段，会随着项目一起发布。\n    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。\n    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。\n    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。\n    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  -->\n    <!--<scope>provided</scope>-->\n</dependency>\n```\n\n### 编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理\n\n```java\n/***\n * Version: \n * Description: 读取外部文件,把一行一行的数据发送给下游的bolt\n *              类似于hadoop mapreduce的inputformat\n ***/\n//BaseBasicSpout\npublic class ReadFileSpout extends BaseRichSpout {\n    private SpoutOutputCollector spoutOutputCollector;\n    private BufferedReader bufferedReader;\n    /**\n     * 初始化方法, 类似于这个类的构造器, 只被运行一次\n     * spout组件读取原始数据为bolt提供数据\n     * 一般用来打开数据链接, 打开网络连接\n     * @param map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用\n     * @param topologyContext 上下文对象, 一般不用\n     * @param spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架\n     */\n    public void open(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector) {\n        try {\n        \t//本地模式\n            //this.bufferedReader = new BufferedReader(new FileReader(new File(\"D:\\\\wordcount.txt\")));\n            //集群模式\n            this.bufferedReader = new BufferedReader(new FileReader(new File(\"//root//stormdata//wordcount.txt\")));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        this.spoutOutputCollector = spoutOutputCollector;\n    }\n\n    /**\n     * 下一个tuple, tuple是数据传送的基本单位\n     * 不断地往下一个组件发送tuple消息\n     * 这里面是该spout组件的核心逻辑\n     * 如从kafka消息队列中拿到数据\n     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去\n     */\n    public void nextTuple() {\n        String line = null;\n        try {\n        \t//一行一行的读取文件内容,并且一行一行的发送\n            line = bufferedReader.readLine();\n            if (line != null){\n\t\t\t\t//将信息封装成tuple，发送消息给下一个组件\n\t\t        //this.collector.emit(new Value(this.words[index]));\n\n                spoutOutputCollector.emit(Arrays.asList(line));\n\n\t\t\t\t//每发送一个消息，休眠500ms\n       \t\t\t// Thread.sleep(500);\n\t\t\t\t// Utils.sleep(500);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 通过字段声明发出的数据是什么,tuple中的数据的字段名\n     * @param outputFieldsDeclarer\n     */\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        outputFieldsDeclarer.declare(new Fields(\"line\"));\n    } \n}\n```\n\n### 编写Bolt类对出入的内容进行单词切分\n\n```java\n/***\n * Description: 输入一行一行的数据\n *              对一行数据进行切割\n *              输出单词及单词出现的次数\n ***\n//BaseBasicBolt\npublic class SplitBolt extends BaseRichBolt {\n    private OutputCollector outputCollector;\n    /**\n     * 初始化方法,只被运行一次\n     * @param map 配置文件\n     * @param topologyContext 上下文对象\n     * @param outputCollector 数据收集器\n     */\n    @Override\n    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {\n        this.outputCollector = outputCollector;\n    }\n\n    /**\n     * 执行业务逻辑的方法\n     * @param tuple 获取的上游数据\n     */\n    @Override\n    public void execute(Tuple tuple) {\n        //获取上游句子(字段:\"line\"),从tuple中读取数据\n\t\t//获取nextTuple()方法emit()过来的数据\t\n        String line = tuple.getStringByField(\"line\");\n        //对句子进行切割\n        String[] words = line.split(\" \");\n        //发送数据\n        for (String word : words) {\n            //需要发送单词和单词出现的次数,总共两个字段\n            outputCollector.emit(Arrays.asList(word, \"1\"));\n        }\n    }\n\n    /**\n     * 声明发送出去的数据\n     * @param outputFieldsDeclarer\n     */\n    @Override\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        outputFieldsDeclarer.declare(new Fields(\"word\", \"num\"));\n    }\n}\n```\n\n### 编写Bolt类对单词进行计数\n\n```java\n/***\n* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce\n*              输入单词及单词出现的次数\n*              输出打印在控制台\n***/\npublic class WordCountBolt extends BaseRichBolt {\n\t//定义一个map用于储存单词及其数量\n    private Map<String, Integer> wordCountMap = new HashMap<>();\n\n    /**\n     * 初始化方法\n     * @param map 配置文件\n     * @param topologyContext 上下文对象\n     * @param outputCollector 数据收集器\n     */\n    @Override\n    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {\n        //由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector\n    }\n\n    @Override\n    public void execute(Tuple tuple) {\n        //获取信息(单词, 数量)\n        String word = tuple.getStringByField(\"word\");\n        String num = tuple.getStringByField(\"num\");\n        //使用map进行记录\n        //开始计数\n        if (wordCountMap.containsKey(word)){\n            //如果map里已经有这个单词,就把数量进行累加\n            Integer integer = wordCountMap.get(word);\n            wordCountMap.put(word, integer + Integer.parseInt(num));\n        }else {\n            //如果map里已经没有这个单词,就把单词和数量放入map\n            wordCountMap.put(word, Integer.parseInt(num));\n        }\n\n        //打印\n        System.out.println(wordCountMap);\n    }\n\n    @Override\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        //由于不向外发送数据,所以不用写\n    }\n}\n```\n\n### 编写启动类对程序进行整合\n\n```\n/***\n * Description: wordcount驱动类,用来提交任务\n ***/\npublic class WordCountTopology {\n    public static void main(String[] args) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException {\n        //通过TopologyBuilder 封装任务信息\n        TopologyBuilder topologyBuilder = new TopologyBuilder();\n```\n\n​     \n\n```java\n        //设置spout获取数据\n        //SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件\n\t\t//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task\n\n        topologyBuilder.setSpout(\"readfilesspout\", new ReadFileSpout(), 2);\n        //设置splitbolt 对句子进行切割\n        topologyBuilder.setBolt(\"splitbolt\", new SplitBolt(), 4).shuffleGrouping(\"readfilesspout\");\n        //设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息\n        topologyBuilder.setBolt(\"wordcountbolt\", new WordCountBolt(), 2).shuffleGrouping(\"splitbolt\");\n\n        //准备一个配置文件，配置一些topology在集群中运行的参数\n        Config config = new Config();\n\n        //启动2个worker!\n        config.setNumWorkers(2);\n\n        //任务提交有:本地模式 和 集群模式\n\n        //本地模式\n        //LocalCluster localCluster = new LocalCluster();\n        //localCluster.submitTopology(\"wordcount\", config, topologyBuilder.createTopology());\n\n        //集群模式,参数:Topology名字, 配置文件, Topology对象\n\t\t//用builder来创建topology\n        StormSubmitter.submitTopology(\"wordcount2\", config, topologyBuilder.createTopology());\n    }\n}\n```\n\n### 执行程序\n\n1. 选择本地模式运行  \n   直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台\n2. 选择上传到集群进行执行  \n   首先通过maven的package命名将程序打好jar包  \n\n#### 注：\n\n在storm-core的依赖中加入:<scope>provided</scope>  \n在上传到node2或node3上, 在指定路径下要确保存在日志文件\n\n# Storm Distributed RPC（DRPC）\n\n## 分布式远程过程调用\n\n- DRPC的主要作用就是利用Storm的**实时计算**能力来**并行化**CPU intensive的计算。  \n- 对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。  \n- DRPC其实不能算是storm本身的一个特性，它是通过组合storm的**原语**spout，bolt，topology而成的一种模式(pattern)。  \n- DRPC通过一个\"DRPC server\"来进行**协调均衡**。（Storm整合了DRPC server的一个实现）。  \n- DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。  \n- 对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。\n\n### 客户端使用DRPC来获取以\"http://baidu.com\"为参数的\"reach\"函数的返回结果：\n\n```java\nDRPCClient client = new DRPCClient(\"drpc-host\", 3772);\nString result = client.execute(\"reach\", \"http://baidu.com\");\n```\n\n![mark](https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim)  \n\n#### 1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用  \n\n#### 2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。\n\n#### 3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。\n\n#### 4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。\n\n#### 5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。\n\n## LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）\n\n### Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:\n\n1. 建立 spout\n2. 将结果返回到DRPC server\n3. 向bolts提供了在tuples集合上进行有限聚集的功能\n\n#### 创建LinearDRPCTopologyBuilder\n\n```java\npublic static class ExclaimBolt extends BaseBasicBolt {\n    public void execute(Tuple tuple, BasicOutputCollector collector) {\n        String input = tuple.getString(1);\n\t\t//简单的在元组的第二个字段的值后加了一个\"!\"\n        collector.emit(new Values(tuple.getValue(0), input + \"!\"));\n    }\n```\n\n​\t\t\n\n```java\n    public void declareOutputFields(OutputFieldsDeclarer declarer) {\n        declarer.declare(new Fields(\"id\", \"result\"));\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n  //我们将DRPC函数名告诉给topology（本例函数名为exclamation）。\t\n  //单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。\n  //第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。\n    LinearDRPCTopologyBuilder builder = new LinearDRPCTopologyBuilder(\"exclamation\");\n    builder.addBolt(new ExclaimBolt(), 3);\n}\n```\n\n#### 创建Local mode DRPC\n\n```java\n//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。\nLocalDRPC drpc = new LocalDRPC();\n//然后创建LocalCluster来以本地模式来运行该topology。\nLocalCluster cluster = new LocalCluster();\n//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。\n//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象\n//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;\ncluster.submitTopology(\"drpc-demo\", conf, builder.createLocalTopology(drpc));\n//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。\nSystem.out.println(\"Results for 'hello':\" + drpc.execute(\"exclamation\", \"hello\"));\n\ncluster.shutdown();\ndrpc.shutdown();\n```\n\n#### Remote mode DRPC\n\n1. 建立DRPC servers\n2. 配置DRPC servers的位置\n3. 向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：\n\n##### 1. 用storm脚本建立DRPC server：\n\n```java\nbin/storm drpc\n```\n\n##### 2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置\n\n```java\ndrpc.servers:\n  - \"drpc1.foo.com\"\n  - \"drpc2.foo.com\"\n```\n\n##### 3. 通过StormSubmitter建立DRPC topologies\n\n```java\nStormSubmitter.submitTopology(\"exclamation-drpc\", conf, builder.createRemoteTopology());\n```\n\n## Storm DRPC深入\n\n分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的**函数调用**进行**并行计算**。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。  \n可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。 \n\n### 注：\n\nStorm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）  \nStorm只负责数据的计算，不负责数据的存储     \n2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x \n\n![mark](https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim)\n**其中:**\nNimbus：负责资源分配和任务调度。  \nSupervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。  \nWorker：运行具体处理组件逻辑的进程。  \nTask：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。  \n![mark](https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim)\n\n### 注：\n\n**DataSource**: 数据源  \n**Spout**：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。   \n**Bolt**：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。   \n**Tuple**：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.  \n**Stream**：源源不断传递的tuple就组成了stream。  \n**Topology**：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。\n\n### 分组策略\n\n1. 随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用\n2. 字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。\n3. LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。\n\n\n\n## zookeeper安装和使用\n\nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。  \nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。  \nZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。    \n\n### zoo_sample.cfg文件配置\n\n```properties\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just \n# example sakes.\ndataDir=D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\data\ndataLogDir=D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\log\n# the port at which the clients will connect\nclientPort=2181\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns=60\n#\n# Be sure to read the maintenance section of the \n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount=3\n# Purge task interval in hours\n# Set to \"0\" to disable auto purge feature\n#autopurge.purgeInterval=1\n```\n\n### 参数解释\n\n- tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。\n- initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒\n- syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒\n- dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。\n- clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。\n\n### 异常\n\nSocket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information  \n**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg\n\nzookeeper启动成功\n![mark](https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim)\n\n## Zookeeper伪分布式集群搭建\n\n1. 将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。   \n2. 创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。\n3. 在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.  \n4. 修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改\n\n### zoo.cfg文件如下\n\n```properties\n# The number of milliseconds of each tick\n# 服务器与客户端之间交互的基本时间单元（ms）\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\n# zookeeper所能接受的客户端数量\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\n# 服务器与客户端之间请求和应答的时间间隔\nsyncLimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just \n# example sakes.\n# 保存zookeeper数据，日志路径\ndataDir=D:/DevelopSoftware/zookeeper/zk-data/8001/data\ndataLogDir=D:/DevelopSoftware/zookeeper/zk-data/8001/log\n# the port at which the clients will connect\n# 这是客户端链接的端口号\nclientPort=2181\t\t\t\t\t\t\t\t\t\t\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns=60\n#\n# Be sure to read the maintenance section of the \n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount=3\n# Purge task interval in hours\n# Set to \"0\" to disable auto purge feature\n#autopurge.purgeInterval=1\n\n# Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口\n# server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。\n# 客户端与zookeeper相互交互的端口\nserver.1=127.0.0.1:8001:9001\nserver.2=127.0.0.1:8002:9002\nserver.3=127.0.0.1:8003:9003\n```\n\n### 报错\n\n```java\n [myid:1] - WARN  [WorkerSender[myid=1]:QuorumCnxManager@584] - Cannot open channel to 3 at election address /127.0.0.1:9003\njava.net.ConnectException: Connection refused: connect\n        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)\n        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)\n        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n        at java.net.Socket.connect(Socket.java:589)\n        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:558)\n        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:534)\n        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:454)\n        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:435)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\n### 报错解决办法\n\n产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。\n\n## dubbo的引入\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进\n![mark](https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim)\n\n- 单一应用架构\n  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。  \n  此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。  \n\n- 垂直应用架构\n  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。  \n  此时，用于加速前端页面开发的  Web框架(MVC)  是关键。  \n\n- 分布式服务架构\n  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n  此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。  \n\n- 流动计算架构\n  当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率  \n  此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。  \n\n  \n\n在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。  \n\n1. 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。  \n   此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。  \n\n2. 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。  \n   这时，需要自动画出应用间的依赖关系图，以理清理关系。  \n\n3. 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？  \n   为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。     \n   其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。  \n\n### Dubbo的工作原理\n\n![mark](https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim)\n\n### 节点角色说明：\n\n- Provider:  暴露服务的服务提供方。\n- Consumer:  调用远程服务的服务消费方。\n- Registry:  服务注册与发现的注册中心。\n- Monitor:  统计服务的调用次调和调用时间的监控中心。\n- Container:  服务运行容器。\n\n### 调用关系说明：\n\n- 服务容器负责启动，加载，运行服务提供者。\n- 服务提供者在启动时，向注册中心注册自己提供的服务。\n- 服务消费者在启动时，向注册中心订阅自己所需的服务。\n- 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n- 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n- 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n## Dubbo-admin管理平台的安装\n\n### dubbo-admin 本地编译打包\n\nhttps://github.com/alibaba/dubbo/releases  \nhttps://github.com/apache/incubator-dubbo/releases  \n解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址  \nhttps://github.com/apache/incubator-dubbo-ops\n\n### 克隆项目\n\napache 下的dubbo-admin git仓库：  \nhttps://github.com/apache/incubator-dubbo-ops  \n先把这个项目用git克隆到本地中  \n![mark](https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim)\n\n#### application.properties配置\n\n![mark](https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim)\n\n#### application-test.properties配置\n\n![](https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg)\n\n#### tomcat配置启动项\n\n![mark](https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim)\n\n#### 配置部署war包\n\n![mark](https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim)  \n![mark](https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim)\n\n#### 说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。\n\n#### Production Setup\n\n1. Clone source code on develop branch git clone https://github.com/apache/incubator-dubbo-admin.git\n2. Specify registry address in dubbo-admin-server/src/main/resources/application.properties\n3. Build  \n   mvn clean package  \n   ![mark](https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim)\n4. Start  \n   mvn --projects dubbo-admin-server spring-boot:run  \n   **启动Zookeeper集群**\n   ![mark](https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim)  \n   ![mark](https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim)\n\n5. Visit http://localhost:8080\n   ![mark](https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim)\n\n### 报错1\n\n![mark](https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim)\n\n### 解决办法\n\n如果SpringBoot在子模块，直接main启动子模块会报错。\n解决办法就是在IDEA MAVEN Projects->dubbo-admin-server->Plugins->spring-boot->spring-boot:run->run maven build\n![mark](https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim)\n\n### 报错2\n\n![mark](https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim)\n\n### 解决办法\n\ntaskkill /pid 8876 /f\n\n![mark](https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim)\n\n## zookeeper与dubbo关系\n\ndubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；\n\n## Netty在Dubbo中的应用\n\n**Dubbo 底层使用的是 Netty 作为网络通信**  \n\n1. dubbo的Consumer消费者如何使用Netty  \n\n### 调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。\n\n```java\n// get remote service proxy\nDemoService demoService = (DemoService) context.getBean(\"demoService\");\n```\n\n### 调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存  \n\n```java\nprivate ExchangeClient getSharedClient(URL url){\n\tString key=url.getAddress();\n\tReferenceCountExchangeClient client=referenceClientMap.get(key);\n\tif(client!=null){\n\t\tif(!=client.isClosed()){\n\t\t\tclient.incrementAndGetCount();\n\t\t\treturn client;\n\t\t}else{\n\t\t\treferenceClientMap.remove(key);\n\t\t}\n\t}\n\tsynchronized(key.intern()){\n\t\t//这个initClient()方法是创建Netty的client的\n\t\tExchangeClient exchangeClient=initClient(url);\n\t\tclient=new ReferenceCountExchangeClient(exchangeClient,ghostClientMap);\n\t\treferenceClientMap.put(key,client);\n\t\tghostClientMap.remove(key);\n\t\treturn client;\n\t}\n}\n```\n\n### 最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。\n\n```java\npublic AbstractClient(URL url, ChannelHandler handler) throws RemotingException {\n    doOpen();\n    connect();\n}\n```\n\n### doOpent 方法用来创建 Netty 的 bootstrap ：\n\n```java\nprotected void doOpen() throws Throwable {\n    NettyHelper.setNettyLoggerFactory();\n    bootstrap = new ClientBootstrap(channelFactory);\n    bootstrap.setOption(\"keepAlive\", true);\n    bootstrap.setOption(\"tcpNoDelay\", true);\n    bootstrap.setOption(\"connectTimeoutMillis\", getTimeout());\n    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n        public ChannelPipeline getPipeline() {\n            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);\n            ChannelPipeline pipeline = Channels.pipeline();\n            pipeline.addLast(\"decoder\", adapter.getDecoder());\n            pipeline.addLast(\"encoder\", adapter.getEncoder());\n            pipeline.addLast(\"handler\", nettyHandler);\n            return pipeline;\n        }\n    });\n}\n```\n\n### connect 方法用来连接提供者：\n\n```java\nprotected void doConnect() throws Throwable {\n    long start = System.currentTimeMillis();\n\t//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 \n    ChannelFuture future = bootstrap.connect(getConnectAddress());\n    boolean ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);\n    if (ret && future.isSuccess()) {\n        Channel newChannel = future.getChannel();\n        newChannel.setInterestOps(Channel.OP_READ_WRITE);\n    } \n}\n```\n\n### main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。  \n\n```java\npublic ResponseFuture request(Object request, int timeout) throws RemotingException {\n    Request req = new Request();\n    req.setVersion(\"2.0.0\");\n    req.setTwoWay(true);\n    req.setData(request);\n    DefaultFuture future = new DefaultFuture(channel, req, timeout);\n\t//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  \n    channel.send(req);\n    return future;\n}\n```\n\n## dubbo 的 Provider 提供者如何使用 Netty  \n\nProvider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。\n\n### NettyServer 对象的构造方法同样是 doOpen 方法。\n\n```java\nprotected void doOpen() throws Throwable {\n    NettyHelper.setNettyLoggerFactory();\n\t//boss 线程，worker 线程，和 ServerBootstrap\n    ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(\"NettyServerBoss\", true));\n    ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(\"NettyServerWorker\", true));\n    ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));\n    bootstrap = new ServerBootstrap(channelFactory);\n\t//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。\n    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n    channels = nettyHandler.getChannels();\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n        public ChannelPipeline getPipeline() {\n            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n            ChannelPipeline pipeline = Channels.pipeline();\n            pipeline.addLast(\"decoder\", adapter.getDecoder());\n            pipeline.addLast(\"encoder\", adapter.getEncoder());\n            pipeline.addLast(\"handler\", nettyHandler);\n            return pipeline;\n        }\n    });\n    channel = bootstrap.bind(getBindAddress());\n}\n```\n\n### Netty在Dubbo中的应用总结\n\ndubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。\n\n## Apache Storm分布式消息系统\n\nApache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。  \n\n### 什么是分布式消息系统？  \n\n分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。  \n大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。  \n一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。  \n需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。\n\n![mark](https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim)\n\n下表描述了一些流行的高吞吐量消息传递系统 -\n![mark](https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim)\nThrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。    \nApache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。  \nStorm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。\n\n## Storm工作原理\n\n![mark](https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim)\n\n### Storm与传统关系型数据库 \n\n传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存   \n传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据 \n关系型数据库重视事务，并发控制，相对来说Storm比较简陋   \nStorm与Hadoop，Spark等是流行的大数据方案    \n与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑  \n\n1. topology  \n   Storm集群中有两种组件节点，一种是**控制节点**(Nimbus节点)，另一种是**工作节点**(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。   \n   和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去  \n   数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。 \n   ![mark](https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim)\n\n2. zookeeper集群  \n   storm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。  \n   部署zookeeper有些需要注意的地方：  \n   ①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控   \n   ②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用\n\n3. Component\n   Storm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口 \n    全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。\n   ![mark](https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim)\n\n4. Spout\n   Spout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现\n\n   ```java\n   public interface ISpout extends Serializable { \n     void open(Map conf, TopologyContext context, SpoutOutputCollector collector); \n     void close(); \n     void nextTuple(); \n     void ack(Object msgId); \n     void fail(Object msgId); \n   }   \n   ```\n\n    ①open()方法 -- 初始化方法   \n    close() -- 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行   \n    ②ack(Object msgId) -- 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放   \n    ③fail(Object msgId) -- 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放   \n    ④nextTuple() -- 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout \n\n5. Bolt\n   Bolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成  \n     prepare方法 -- 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境   \n     declareOutputFields方法 -- 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似   \n     cleanup方法 -- 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。   \n     execute方法 -- 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。   \n     Storm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException   \n     通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple) \n\n6. Topology运行方式\n   在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式 \n\n### 本地运行的提交方式 \n\n```java\nLocalCluster cluster = new LocalCluster(); \ncluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); \nThread.sleep(2000); \ncluster.shutdown(); \n```\n\n### 分布式提交方式\n\n```java\nStormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology()); \n```\n\n  需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。 \n\n### 运行的命令如下###\n\n```shell\nstorm jar StormTopology.jar mainclass [args] \n```\n\n## storm守护进程的命令\n\n  Nimbus: storm nimbus 启动nimbus守护进程   \n  Supervisor: storm supervisor 启动supervisor守护迚程   \n  UI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。  \n  DRPC: storm drpc 启动DRPC的守护进程  \n\n## storm管理命令\n\n```shell\nJAR：storm jar topology_jar topology_class [arguments...] \n```\n\njar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。 \n\n```shell\nKILL：storm kill topology_name [-w wait_time] \n```\n\n杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能 \n\n```shell\n Deactivate：storm deactivate topology_name \n```\n\n 停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能 \n\t\n\n```shell\n  Activate：storm activate topology_name \n```\n\n   启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能 \n\n```shell\n Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]... \n```\n\n rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑   \n\t\n\n```shell\nstorm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8 \n```\n\n 还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等 \n\n## Storm与Hadoop的对比\n\n![mark](https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim)\n\n## DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：  \n\n引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。  \n\n1. 接收到一个RPC调用请求；  \n2. 发送请求到Storm上的**拓扑**；  \n3. 从Storm上接收计算结果；  \n4. 将计算结果返回给客户端。  \n\n\n\n## 附录\n\n### maven更新镜像源\n\n```xml\n<mirrors>\n\t\t<!-- 阿里云仓库 -->\n\t          <mirror>\n\t              <id>alimaven</id>\n\t              <mirrorOf>central</mirrorOf>\n\t             <name>aliyun maven</name>\n\t             <url>https://maven.aliyun.com/repository/central</url>\n\t         </mirror>\n\t          <!-- 中央仓库1 -->\n         <mirror>\n             <id>repo1</id>\n             <mirrorOf>central</mirrorOf>\n             <name>Human Readable Name for this Mirror.</name>\n             <url>http://repo1.maven.org/maven2/</url>\n         </mirror>\n     \n         <!-- 中央仓库2 -->\n         <mirror>\n             <id>repo2</id>\n             <mirrorOf>central</mirrorOf>\n             <name>Human Readable Name for this Mirror.</name>\n             <url>http://repo2.maven.org/maven2/</url>\n         </mirror>\n     </mirrors> \n  </mirrors>\n\t         \n```\n\n## RPC和MQ对比及其适用/不适用场合\n\n### 系统结构  \n\n**RPC系统结构：**  \nCosume <=> Provider  \nConsumer调用的Provider提供的服务  \n\n**Message Queue系统结构：**  \nSender <=> Queue <=> Reciver  \nSender发送消息给Queue；Receiver从Queue拿到消息来处理。\n\n### 功能的特点\n\n在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。  \n\n### 消息的特点\n\n- Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。\n- Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响\n- Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。\n- 所以对于有同步返回需求，用Message Queue则变得麻烦了。\n\n### PRC的特点\n\n- 同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。 \n- RPC也可以是异步调用。\n- 由于等待结果，Consumer（Client）会有线程消耗。\n- 如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。   \n\n### 适用场合说明\n\n- 希望同步得到结果的场合，RPC合适。\n- 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。  \n- 不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。  \n- 随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。\n- 这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。  \n\n### 不适用场合说明 \n\nRPC同步调用使用Message Queue来传输调用信息。  \n发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。\n\n","source":"_posts/storm-心得.md","raw":"---\ntitle: storm(心得)\ndate: 2020-01-16 16:08:52\ntags: Storm\ncategories: 大数据\n---\n\n# Storm入门\n\nStorm是一个**分布式的**，可靠的，容错的**数据流处理系统**。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。   \nStorm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等\nStorm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的  \nStorm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。\n一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。  \n注：Storm中的核心术语  \n**spout**龙卷，读取原始数据为bolt提供数据  \n**bolt** 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果    \n**nimbus** 雨云，主节点的守护进程，负责为工作节点分发任务  \n**topology** 拓扑结构，Storm的一个任务单元  \n**define field(s)** 定义域，由spout或bolt提供，被bolt接收  \n\n## Storm应用案例\n\n- 数据处理流，Storm不需要中间队列\n- 连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。\n- **分布式远程过程调用**\n- 频繁的CPU密集型操作**并行化**。\n\n## Storm组件\n\n在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。  \n主节点运行着一个叫做**Nimbus**的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。    \n**Supervisor**守护进程作为拓扑的一部分运行在工作节点上。  \n一个Storm**拓扑结构**在不同的机器上运行着众多的工作节点。\n因为Storm在**Zookeeper**或本地磁盘上**维持所有的集群状态**，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康  \n在系统底层，Storm使用了**zeromq**，这是一种先进的，可嵌入的**网络通讯库**，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets      \n\n### 注：zeromq的特性  \n\n- 一个并发架构的Socket库  \n- 对于集群产品和超级计算，比TCP要快    \n- 可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信  \n- 异步I / O的可扩展的多核消息传递应用程序  \n- 利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接  \n  注：最新的Storm已不再必须依赖**ZeroMQ**，各种依赖的库和软件也已经有更新的版本。\n  最近版本的Storm支持使用**netty**做消息队列。\n  Netty提供**异步的、事件驱动**的网络应用程序框架和工具，用以快速开发**高性能、高可靠性的**网络服务器和客户端程序。正好是 storm所需要的。\n\n## Storm的特性\n\n- 简化编程：使用Storm，实现实时处理的复杂性被大大降低了\n- 开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发\n- 容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。\n- 可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。\n- 可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。\n- 快速：速度是驱动Storm设计的一个关键因素\n- 事务性：可以为几乎任何计算得到恰好一次消息语义\n\n## 安装Storm集群\n\n要手工安装Storm，需要先安装以下软件  \n\n1. Zookeeper集群\n2. Java\n3. Python\n4. Unzip命令\n\n### 注：\n\nNimbus和管理进程将要依赖Java、Python和unzip命令\n\n### 前期准备\n\n1. 准备搭建3节点集群,准备3个虚拟机node1,node2,node3  \n2. 配置好hosts映射文件和互相的ssh免密登录  \n3. 配置好JDK  \n   注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好\n\n### 安装storm\n\n1. 准备好storm安装包\n2. 上传解压重命名为storm到/export/server路径下\n3. 修改配置文件 storm.yaml\n\n### 运行\n\n- 前台启动 (前台启动会占用窗口)  \n  （1）在node1上启动 nimbus进程(主节点) 和 web UI  \n  （2）在 node2 和 node3 上启动 supervisor(从节点)\n- 后台启动\n\n#### ssh脚本实现一键启动\n\n```shell\n.#!/bin/bash\nsource /etc/profile\nnohup /export/server/storm/bin/storm nimbus >/dev/null 2>&1 &\necho \"node1 nimbus is running\"\nnohup /export/server/storm/bin/storm ui >/dev/null 2>&1 &\necho \"node1 core is running\"\nfor host in node2 node3\ndo\n{\nssh $host \"source /etc/profile;nohup /export/server/storm/bin/storm supervisor >/dev/null 2>&1 &\"\necho \"$host Supervisor is running\"\n}\ndone\n```\n\n### 进入web页面查看集群\n\n## 使用入门\n\n### MAVEN依赖\n\n```xml\n<dependency>\n    <groupId>org.apache.storm</groupId>\n    <artifactId>storm-core</artifactId>\n    <version>1.1.1</version>\n    <!-- 目前<scope>可以使用5个值：\n    * compile，缺省值，适用于所有阶段，会随着项目一起发布。\n    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。\n    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。\n    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。\n    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  -->\n    <!--<scope>provided</scope>-->\n</dependency>\n```\n\n### 编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理\n\n```java\n/***\n * Version: \n * Description: 读取外部文件,把一行一行的数据发送给下游的bolt\n *              类似于hadoop mapreduce的inputformat\n ***/\n//BaseBasicSpout\npublic class ReadFileSpout extends BaseRichSpout {\n    private SpoutOutputCollector spoutOutputCollector;\n    private BufferedReader bufferedReader;\n    /**\n     * 初始化方法, 类似于这个类的构造器, 只被运行一次\n     * spout组件读取原始数据为bolt提供数据\n     * 一般用来打开数据链接, 打开网络连接\n     * @param map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用\n     * @param topologyContext 上下文对象, 一般不用\n     * @param spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架\n     */\n    public void open(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector) {\n        try {\n        \t//本地模式\n            //this.bufferedReader = new BufferedReader(new FileReader(new File(\"D:\\\\wordcount.txt\")));\n            //集群模式\n            this.bufferedReader = new BufferedReader(new FileReader(new File(\"//root//stormdata//wordcount.txt\")));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        this.spoutOutputCollector = spoutOutputCollector;\n    }\n\n    /**\n     * 下一个tuple, tuple是数据传送的基本单位\n     * 不断地往下一个组件发送tuple消息\n     * 这里面是该spout组件的核心逻辑\n     * 如从kafka消息队列中拿到数据\n     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去\n     */\n    public void nextTuple() {\n        String line = null;\n        try {\n        \t//一行一行的读取文件内容,并且一行一行的发送\n            line = bufferedReader.readLine();\n            if (line != null){\n\t\t\t\t//将信息封装成tuple，发送消息给下一个组件\n\t\t        //this.collector.emit(new Value(this.words[index]));\n\n                spoutOutputCollector.emit(Arrays.asList(line));\n\n\t\t\t\t//每发送一个消息，休眠500ms\n       \t\t\t// Thread.sleep(500);\n\t\t\t\t// Utils.sleep(500);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 通过字段声明发出的数据是什么,tuple中的数据的字段名\n     * @param outputFieldsDeclarer\n     */\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        outputFieldsDeclarer.declare(new Fields(\"line\"));\n    } \n}\n```\n\n### 编写Bolt类对出入的内容进行单词切分\n\n```java\n/***\n * Description: 输入一行一行的数据\n *              对一行数据进行切割\n *              输出单词及单词出现的次数\n ***\n//BaseBasicBolt\npublic class SplitBolt extends BaseRichBolt {\n    private OutputCollector outputCollector;\n    /**\n     * 初始化方法,只被运行一次\n     * @param map 配置文件\n     * @param topologyContext 上下文对象\n     * @param outputCollector 数据收集器\n     */\n    @Override\n    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {\n        this.outputCollector = outputCollector;\n    }\n\n    /**\n     * 执行业务逻辑的方法\n     * @param tuple 获取的上游数据\n     */\n    @Override\n    public void execute(Tuple tuple) {\n        //获取上游句子(字段:\"line\"),从tuple中读取数据\n\t\t//获取nextTuple()方法emit()过来的数据\t\n        String line = tuple.getStringByField(\"line\");\n        //对句子进行切割\n        String[] words = line.split(\" \");\n        //发送数据\n        for (String word : words) {\n            //需要发送单词和单词出现的次数,总共两个字段\n            outputCollector.emit(Arrays.asList(word, \"1\"));\n        }\n    }\n\n    /**\n     * 声明发送出去的数据\n     * @param outputFieldsDeclarer\n     */\n    @Override\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        outputFieldsDeclarer.declare(new Fields(\"word\", \"num\"));\n    }\n}\n```\n\n### 编写Bolt类对单词进行计数\n\n```java\n/***\n* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce\n*              输入单词及单词出现的次数\n*              输出打印在控制台\n***/\npublic class WordCountBolt extends BaseRichBolt {\n\t//定义一个map用于储存单词及其数量\n    private Map<String, Integer> wordCountMap = new HashMap<>();\n\n    /**\n     * 初始化方法\n     * @param map 配置文件\n     * @param topologyContext 上下文对象\n     * @param outputCollector 数据收集器\n     */\n    @Override\n    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {\n        //由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector\n    }\n\n    @Override\n    public void execute(Tuple tuple) {\n        //获取信息(单词, 数量)\n        String word = tuple.getStringByField(\"word\");\n        String num = tuple.getStringByField(\"num\");\n        //使用map进行记录\n        //开始计数\n        if (wordCountMap.containsKey(word)){\n            //如果map里已经有这个单词,就把数量进行累加\n            Integer integer = wordCountMap.get(word);\n            wordCountMap.put(word, integer + Integer.parseInt(num));\n        }else {\n            //如果map里已经没有这个单词,就把单词和数量放入map\n            wordCountMap.put(word, Integer.parseInt(num));\n        }\n\n        //打印\n        System.out.println(wordCountMap);\n    }\n\n    @Override\n    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n        //由于不向外发送数据,所以不用写\n    }\n}\n```\n\n### 编写启动类对程序进行整合\n\n```\n/***\n * Description: wordcount驱动类,用来提交任务\n ***/\npublic class WordCountTopology {\n    public static void main(String[] args) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException {\n        //通过TopologyBuilder 封装任务信息\n        TopologyBuilder topologyBuilder = new TopologyBuilder();\n```\n\n​     \n\n```java\n        //设置spout获取数据\n        //SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件\n\t\t//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task\n\n        topologyBuilder.setSpout(\"readfilesspout\", new ReadFileSpout(), 2);\n        //设置splitbolt 对句子进行切割\n        topologyBuilder.setBolt(\"splitbolt\", new SplitBolt(), 4).shuffleGrouping(\"readfilesspout\");\n        //设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息\n        topologyBuilder.setBolt(\"wordcountbolt\", new WordCountBolt(), 2).shuffleGrouping(\"splitbolt\");\n\n        //准备一个配置文件，配置一些topology在集群中运行的参数\n        Config config = new Config();\n\n        //启动2个worker!\n        config.setNumWorkers(2);\n\n        //任务提交有:本地模式 和 集群模式\n\n        //本地模式\n        //LocalCluster localCluster = new LocalCluster();\n        //localCluster.submitTopology(\"wordcount\", config, topologyBuilder.createTopology());\n\n        //集群模式,参数:Topology名字, 配置文件, Topology对象\n\t\t//用builder来创建topology\n        StormSubmitter.submitTopology(\"wordcount2\", config, topologyBuilder.createTopology());\n    }\n}\n```\n\n### 执行程序\n\n1. 选择本地模式运行  \n   直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台\n2. 选择上传到集群进行执行  \n   首先通过maven的package命名将程序打好jar包  \n\n#### 注：\n\n在storm-core的依赖中加入:<scope>provided</scope>  \n在上传到node2或node3上, 在指定路径下要确保存在日志文件\n\n# Storm Distributed RPC（DRPC）\n\n## 分布式远程过程调用\n\n- DRPC的主要作用就是利用Storm的**实时计算**能力来**并行化**CPU intensive的计算。  \n- 对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。  \n- DRPC其实不能算是storm本身的一个特性，它是通过组合storm的**原语**spout，bolt，topology而成的一种模式(pattern)。  \n- DRPC通过一个\"DRPC server\"来进行**协调均衡**。（Storm整合了DRPC server的一个实现）。  \n- DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。  \n- 对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。\n\n### 客户端使用DRPC来获取以\"http://baidu.com\"为参数的\"reach\"函数的返回结果：\n\n```java\nDRPCClient client = new DRPCClient(\"drpc-host\", 3772);\nString result = client.execute(\"reach\", \"http://baidu.com\");\n```\n\n![mark](https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim)  \n\n#### 1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用  \n\n#### 2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。\n\n#### 3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。\n\n#### 4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。\n\n#### 5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。\n\n## LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）\n\n### Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:\n\n1. 建立 spout\n2. 将结果返回到DRPC server\n3. 向bolts提供了在tuples集合上进行有限聚集的功能\n\n#### 创建LinearDRPCTopologyBuilder\n\n```java\npublic static class ExclaimBolt extends BaseBasicBolt {\n    public void execute(Tuple tuple, BasicOutputCollector collector) {\n        String input = tuple.getString(1);\n\t\t//简单的在元组的第二个字段的值后加了一个\"!\"\n        collector.emit(new Values(tuple.getValue(0), input + \"!\"));\n    }\n```\n\n​\t\t\n\n```java\n    public void declareOutputFields(OutputFieldsDeclarer declarer) {\n        declarer.declare(new Fields(\"id\", \"result\"));\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n  //我们将DRPC函数名告诉给topology（本例函数名为exclamation）。\t\n  //单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。\n  //第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。\n    LinearDRPCTopologyBuilder builder = new LinearDRPCTopologyBuilder(\"exclamation\");\n    builder.addBolt(new ExclaimBolt(), 3);\n}\n```\n\n#### 创建Local mode DRPC\n\n```java\n//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。\nLocalDRPC drpc = new LocalDRPC();\n//然后创建LocalCluster来以本地模式来运行该topology。\nLocalCluster cluster = new LocalCluster();\n//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。\n//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象\n//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;\ncluster.submitTopology(\"drpc-demo\", conf, builder.createLocalTopology(drpc));\n//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。\nSystem.out.println(\"Results for 'hello':\" + drpc.execute(\"exclamation\", \"hello\"));\n\ncluster.shutdown();\ndrpc.shutdown();\n```\n\n#### Remote mode DRPC\n\n1. 建立DRPC servers\n2. 配置DRPC servers的位置\n3. 向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：\n\n##### 1. 用storm脚本建立DRPC server：\n\n```java\nbin/storm drpc\n```\n\n##### 2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置\n\n```java\ndrpc.servers:\n  - \"drpc1.foo.com\"\n  - \"drpc2.foo.com\"\n```\n\n##### 3. 通过StormSubmitter建立DRPC topologies\n\n```java\nStormSubmitter.submitTopology(\"exclamation-drpc\", conf, builder.createRemoteTopology());\n```\n\n## Storm DRPC深入\n\n分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的**函数调用**进行**并行计算**。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。  \n可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。 \n\n### 注：\n\nStorm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）  \nStorm只负责数据的计算，不负责数据的存储     \n2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x \n\n![mark](https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim)\n**其中:**\nNimbus：负责资源分配和任务调度。  \nSupervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。  \nWorker：运行具体处理组件逻辑的进程。  \nTask：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。  \n![mark](https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim)\n\n### 注：\n\n**DataSource**: 数据源  \n**Spout**：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。   \n**Bolt**：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。   \n**Tuple**：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.  \n**Stream**：源源不断传递的tuple就组成了stream。  \n**Topology**：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。\n\n### 分组策略\n\n1. 随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用\n2. 字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。\n3. LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。\n\n\n\n## zookeeper安装和使用\n\nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。  \nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。  \nZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。    \n\n### zoo_sample.cfg文件配置\n\n```properties\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just \n# example sakes.\ndataDir=D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\data\ndataLogDir=D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\log\n# the port at which the clients will connect\nclientPort=2181\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns=60\n#\n# Be sure to read the maintenance section of the \n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount=3\n# Purge task interval in hours\n# Set to \"0\" to disable auto purge feature\n#autopurge.purgeInterval=1\n```\n\n### 参数解释\n\n- tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。\n- initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒\n- syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒\n- dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。\n- clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。\n\n### 异常\n\nSocket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information  \n**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg\n\nzookeeper启动成功\n![mark](https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim)\n\n## Zookeeper伪分布式集群搭建\n\n1. 将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。   \n2. 创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。\n3. 在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.  \n4. 修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改\n\n### zoo.cfg文件如下\n\n```properties\n# The number of milliseconds of each tick\n# 服务器与客户端之间交互的基本时间单元（ms）\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\n# zookeeper所能接受的客户端数量\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\n# 服务器与客户端之间请求和应答的时间间隔\nsyncLimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just \n# example sakes.\n# 保存zookeeper数据，日志路径\ndataDir=D:/DevelopSoftware/zookeeper/zk-data/8001/data\ndataLogDir=D:/DevelopSoftware/zookeeper/zk-data/8001/log\n# the port at which the clients will connect\n# 这是客户端链接的端口号\nclientPort=2181\t\t\t\t\t\t\t\t\t\t\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns=60\n#\n# Be sure to read the maintenance section of the \n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount=3\n# Purge task interval in hours\n# Set to \"0\" to disable auto purge feature\n#autopurge.purgeInterval=1\n\n# Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口\n# server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。\n# 客户端与zookeeper相互交互的端口\nserver.1=127.0.0.1:8001:9001\nserver.2=127.0.0.1:8002:9002\nserver.3=127.0.0.1:8003:9003\n```\n\n### 报错\n\n```java\n [myid:1] - WARN  [WorkerSender[myid=1]:QuorumCnxManager@584] - Cannot open channel to 3 at election address /127.0.0.1:9003\njava.net.ConnectException: Connection refused: connect\n        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)\n        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)\n        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n        at java.net.Socket.connect(Socket.java:589)\n        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:558)\n        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:534)\n        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:454)\n        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:435)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\n### 报错解决办法\n\n产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。\n\n## dubbo的引入\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进\n![mark](https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim)\n\n- 单一应用架构\n  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。  \n  此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。  \n\n- 垂直应用架构\n  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。  \n  此时，用于加速前端页面开发的  Web框架(MVC)  是关键。  \n\n- 分布式服务架构\n  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n  此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。  \n\n- 流动计算架构\n  当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率  \n  此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。  \n\n  \n\n在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。  \n\n1. 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。  \n   此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。  \n\n2. 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。  \n   这时，需要自动画出应用间的依赖关系图，以理清理关系。  \n\n3. 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？  \n   为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。     \n   其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。  \n\n### Dubbo的工作原理\n\n![mark](https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim)\n\n### 节点角色说明：\n\n- Provider:  暴露服务的服务提供方。\n- Consumer:  调用远程服务的服务消费方。\n- Registry:  服务注册与发现的注册中心。\n- Monitor:  统计服务的调用次调和调用时间的监控中心。\n- Container:  服务运行容器。\n\n### 调用关系说明：\n\n- 服务容器负责启动，加载，运行服务提供者。\n- 服务提供者在启动时，向注册中心注册自己提供的服务。\n- 服务消费者在启动时，向注册中心订阅自己所需的服务。\n- 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n- 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n- 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n## Dubbo-admin管理平台的安装\n\n### dubbo-admin 本地编译打包\n\nhttps://github.com/alibaba/dubbo/releases  \nhttps://github.com/apache/incubator-dubbo/releases  \n解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址  \nhttps://github.com/apache/incubator-dubbo-ops\n\n### 克隆项目\n\napache 下的dubbo-admin git仓库：  \nhttps://github.com/apache/incubator-dubbo-ops  \n先把这个项目用git克隆到本地中  \n![mark](https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim)\n\n#### application.properties配置\n\n![mark](https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim)\n\n#### application-test.properties配置\n\n![](https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg)\n\n#### tomcat配置启动项\n\n![mark](https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim)\n\n#### 配置部署war包\n\n![mark](https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim)  \n![mark](https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim)\n\n#### 说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。\n\n#### Production Setup\n\n1. Clone source code on develop branch git clone https://github.com/apache/incubator-dubbo-admin.git\n2. Specify registry address in dubbo-admin-server/src/main/resources/application.properties\n3. Build  \n   mvn clean package  \n   ![mark](https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim)\n4. Start  \n   mvn --projects dubbo-admin-server spring-boot:run  \n   **启动Zookeeper集群**\n   ![mark](https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim)  \n   ![mark](https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim)\n\n5. Visit http://localhost:8080\n   ![mark](https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim)\n\n### 报错1\n\n![mark](https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim)\n\n### 解决办法\n\n如果SpringBoot在子模块，直接main启动子模块会报错。\n解决办法就是在IDEA MAVEN Projects->dubbo-admin-server->Plugins->spring-boot->spring-boot:run->run maven build\n![mark](https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim)\n\n### 报错2\n\n![mark](https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim)\n\n### 解决办法\n\ntaskkill /pid 8876 /f\n\n![mark](https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim)\n\n## zookeeper与dubbo关系\n\ndubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；\n\n## Netty在Dubbo中的应用\n\n**Dubbo 底层使用的是 Netty 作为网络通信**  \n\n1. dubbo的Consumer消费者如何使用Netty  \n\n### 调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。\n\n```java\n// get remote service proxy\nDemoService demoService = (DemoService) context.getBean(\"demoService\");\n```\n\n### 调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存  \n\n```java\nprivate ExchangeClient getSharedClient(URL url){\n\tString key=url.getAddress();\n\tReferenceCountExchangeClient client=referenceClientMap.get(key);\n\tif(client!=null){\n\t\tif(!=client.isClosed()){\n\t\t\tclient.incrementAndGetCount();\n\t\t\treturn client;\n\t\t}else{\n\t\t\treferenceClientMap.remove(key);\n\t\t}\n\t}\n\tsynchronized(key.intern()){\n\t\t//这个initClient()方法是创建Netty的client的\n\t\tExchangeClient exchangeClient=initClient(url);\n\t\tclient=new ReferenceCountExchangeClient(exchangeClient,ghostClientMap);\n\t\treferenceClientMap.put(key,client);\n\t\tghostClientMap.remove(key);\n\t\treturn client;\n\t}\n}\n```\n\n### 最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。\n\n```java\npublic AbstractClient(URL url, ChannelHandler handler) throws RemotingException {\n    doOpen();\n    connect();\n}\n```\n\n### doOpent 方法用来创建 Netty 的 bootstrap ：\n\n```java\nprotected void doOpen() throws Throwable {\n    NettyHelper.setNettyLoggerFactory();\n    bootstrap = new ClientBootstrap(channelFactory);\n    bootstrap.setOption(\"keepAlive\", true);\n    bootstrap.setOption(\"tcpNoDelay\", true);\n    bootstrap.setOption(\"connectTimeoutMillis\", getTimeout());\n    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n        public ChannelPipeline getPipeline() {\n            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);\n            ChannelPipeline pipeline = Channels.pipeline();\n            pipeline.addLast(\"decoder\", adapter.getDecoder());\n            pipeline.addLast(\"encoder\", adapter.getEncoder());\n            pipeline.addLast(\"handler\", nettyHandler);\n            return pipeline;\n        }\n    });\n}\n```\n\n### connect 方法用来连接提供者：\n\n```java\nprotected void doConnect() throws Throwable {\n    long start = System.currentTimeMillis();\n\t//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 \n    ChannelFuture future = bootstrap.connect(getConnectAddress());\n    boolean ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);\n    if (ret && future.isSuccess()) {\n        Channel newChannel = future.getChannel();\n        newChannel.setInterestOps(Channel.OP_READ_WRITE);\n    } \n}\n```\n\n### main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。  \n\n```java\npublic ResponseFuture request(Object request, int timeout) throws RemotingException {\n    Request req = new Request();\n    req.setVersion(\"2.0.0\");\n    req.setTwoWay(true);\n    req.setData(request);\n    DefaultFuture future = new DefaultFuture(channel, req, timeout);\n\t//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  \n    channel.send(req);\n    return future;\n}\n```\n\n## dubbo 的 Provider 提供者如何使用 Netty  \n\nProvider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。\n\n### NettyServer 对象的构造方法同样是 doOpen 方法。\n\n```java\nprotected void doOpen() throws Throwable {\n    NettyHelper.setNettyLoggerFactory();\n\t//boss 线程，worker 线程，和 ServerBootstrap\n    ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(\"NettyServerBoss\", true));\n    ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(\"NettyServerWorker\", true));\n    ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));\n    bootstrap = new ServerBootstrap(channelFactory);\n\t//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。\n    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n    channels = nettyHandler.getChannels();\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n        public ChannelPipeline getPipeline() {\n            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n            ChannelPipeline pipeline = Channels.pipeline();\n            pipeline.addLast(\"decoder\", adapter.getDecoder());\n            pipeline.addLast(\"encoder\", adapter.getEncoder());\n            pipeline.addLast(\"handler\", nettyHandler);\n            return pipeline;\n        }\n    });\n    channel = bootstrap.bind(getBindAddress());\n}\n```\n\n### Netty在Dubbo中的应用总结\n\ndubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。\n\n## Apache Storm分布式消息系统\n\nApache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。  \n\n### 什么是分布式消息系统？  \n\n分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。  \n大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。  \n一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。  \n需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。\n\n![mark](https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim)\n\n下表描述了一些流行的高吞吐量消息传递系统 -\n![mark](https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim)\nThrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。    \nApache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。  \nStorm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。\n\n## Storm工作原理\n\n![mark](https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim)\n\n### Storm与传统关系型数据库 \n\n传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存   \n传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据 \n关系型数据库重视事务，并发控制，相对来说Storm比较简陋   \nStorm与Hadoop，Spark等是流行的大数据方案    \n与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑  \n\n1. topology  \n   Storm集群中有两种组件节点，一种是**控制节点**(Nimbus节点)，另一种是**工作节点**(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。   \n   和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去  \n   数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。 \n   ![mark](https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim)\n\n2. zookeeper集群  \n   storm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。  \n   部署zookeeper有些需要注意的地方：  \n   ①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控   \n   ②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用\n\n3. Component\n   Storm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口 \n    全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。\n   ![mark](https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim)\n\n4. Spout\n   Spout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现\n\n   ```java\n   public interface ISpout extends Serializable { \n     void open(Map conf, TopologyContext context, SpoutOutputCollector collector); \n     void close(); \n     void nextTuple(); \n     void ack(Object msgId); \n     void fail(Object msgId); \n   }   \n   ```\n\n    ①open()方法 -- 初始化方法   \n    close() -- 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行   \n    ②ack(Object msgId) -- 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放   \n    ③fail(Object msgId) -- 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放   \n    ④nextTuple() -- 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout \n\n5. Bolt\n   Bolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成  \n     prepare方法 -- 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境   \n     declareOutputFields方法 -- 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似   \n     cleanup方法 -- 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。   \n     execute方法 -- 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。   \n     Storm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException   \n     通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple) \n\n6. Topology运行方式\n   在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式 \n\n### 本地运行的提交方式 \n\n```java\nLocalCluster cluster = new LocalCluster(); \ncluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); \nThread.sleep(2000); \ncluster.shutdown(); \n```\n\n### 分布式提交方式\n\n```java\nStormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology()); \n```\n\n  需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。 \n\n### 运行的命令如下###\n\n```shell\nstorm jar StormTopology.jar mainclass [args] \n```\n\n## storm守护进程的命令\n\n  Nimbus: storm nimbus 启动nimbus守护进程   \n  Supervisor: storm supervisor 启动supervisor守护迚程   \n  UI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。  \n  DRPC: storm drpc 启动DRPC的守护进程  \n\n## storm管理命令\n\n```shell\nJAR：storm jar topology_jar topology_class [arguments...] \n```\n\njar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。 \n\n```shell\nKILL：storm kill topology_name [-w wait_time] \n```\n\n杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能 \n\n```shell\n Deactivate：storm deactivate topology_name \n```\n\n 停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能 \n\t\n\n```shell\n  Activate：storm activate topology_name \n```\n\n   启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能 \n\n```shell\n Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]... \n```\n\n rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑   \n\t\n\n```shell\nstorm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8 \n```\n\n 还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等 \n\n## Storm与Hadoop的对比\n\n![mark](https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim)\n\n## DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：  \n\n引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。  \n\n1. 接收到一个RPC调用请求；  \n2. 发送请求到Storm上的**拓扑**；  \n3. 从Storm上接收计算结果；  \n4. 将计算结果返回给客户端。  \n\n\n\n## 附录\n\n### maven更新镜像源\n\n```xml\n<mirrors>\n\t\t<!-- 阿里云仓库 -->\n\t          <mirror>\n\t              <id>alimaven</id>\n\t              <mirrorOf>central</mirrorOf>\n\t             <name>aliyun maven</name>\n\t             <url>https://maven.aliyun.com/repository/central</url>\n\t         </mirror>\n\t          <!-- 中央仓库1 -->\n         <mirror>\n             <id>repo1</id>\n             <mirrorOf>central</mirrorOf>\n             <name>Human Readable Name for this Mirror.</name>\n             <url>http://repo1.maven.org/maven2/</url>\n         </mirror>\n     \n         <!-- 中央仓库2 -->\n         <mirror>\n             <id>repo2</id>\n             <mirrorOf>central</mirrorOf>\n             <name>Human Readable Name for this Mirror.</name>\n             <url>http://repo2.maven.org/maven2/</url>\n         </mirror>\n     </mirrors> \n  </mirrors>\n\t         \n```\n\n## RPC和MQ对比及其适用/不适用场合\n\n### 系统结构  \n\n**RPC系统结构：**  \nCosume <=> Provider  \nConsumer调用的Provider提供的服务  \n\n**Message Queue系统结构：**  \nSender <=> Queue <=> Reciver  \nSender发送消息给Queue；Receiver从Queue拿到消息来处理。\n\n### 功能的特点\n\n在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。  \n\n### 消息的特点\n\n- Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。\n- Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响\n- Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。\n- 所以对于有同步返回需求，用Message Queue则变得麻烦了。\n\n### PRC的特点\n\n- 同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。 \n- RPC也可以是异步调用。\n- 由于等待结果，Consumer（Client）会有线程消耗。\n- 如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。   \n\n### 适用场合说明\n\n- 希望同步得到结果的场合，RPC合适。\n- 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。  \n- 不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。  \n- 随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。\n- 这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。  \n\n### 不适用场合说明 \n\nRPC同步调用使用Message Queue来传输调用信息。  \n发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。\n\n","slug":"storm-心得","published":1,"updated":"2020-01-22T02:46:50.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5p298pn000fbg0rv1dpfjqr","content":"<h1 id=\"Storm入门\"><a class=\"header-anchor\" href=\"#Storm入门\"></a>Storm入门</h1>\n<p>Storm是一个<strong>分布式的</strong>，可靠的，容错的<strong>数据流处理系统</strong>。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。<br>\nStorm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等<br>\nStorm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的<br>\nStorm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。<br>\n一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。<br>\n注：Storm中的核心术语<br>\n<strong>spout</strong>龙卷，读取原始数据为bolt提供数据<br>\n<strong>bolt</strong> 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果<br>\n<strong>nimbus</strong> 雨云，主节点的守护进程，负责为工作节点分发任务<br>\n<strong>topology</strong> 拓扑结构，Storm的一个任务单元<br>\n<strong>define field(s)</strong> 定义域，由spout或bolt提供，被bolt接收</p>\n<h2 id=\"Storm应用案例\"><a class=\"header-anchor\" href=\"#Storm应用案例\"></a>Storm应用案例</h2>\n<ul>\n<li>数据处理流，Storm不需要中间队列</li>\n<li>连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。</li>\n<li><strong>分布式远程过程调用</strong></li>\n<li>频繁的CPU密集型操作<strong>并行化</strong>。</li>\n</ul>\n<h2 id=\"Storm组件\"><a class=\"header-anchor\" href=\"#Storm组件\"></a>Storm组件</h2>\n<p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。<br>\n主节点运行着一个叫做<strong>Nimbus</strong>的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。<br>\n<strong>Supervisor</strong>守护进程作为拓扑的一部分运行在工作节点上。<br>\n一个Storm<strong>拓扑结构</strong>在不同的机器上运行着众多的工作节点。<br>\n因为Storm在<strong>Zookeeper</strong>或本地磁盘上<strong>维持所有的集群状态</strong>，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康<br>\n在系统底层，Storm使用了<strong>zeromq</strong>，这是一种先进的，可嵌入的<strong>网络通讯库</strong>，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets</p>\n<h3 id=\"注：zeromq的特性\"><a class=\"header-anchor\" href=\"#注：zeromq的特性\"></a>注：zeromq的特性</h3>\n<ul>\n<li>一个并发架构的Socket库</li>\n<li>对于集群产品和超级计算，比TCP要快</li>\n<li>可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信</li>\n<li>异步I / O的可扩展的多核消息传递应用程序</li>\n<li>利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接<br>\n注：最新的Storm已不再必须依赖<strong>ZeroMQ</strong>，各种依赖的库和软件也已经有更新的版本。<br>\n最近版本的Storm支持使用<strong>netty</strong>做消息队列。<br>\nNetty提供<strong>异步的、事件驱动</strong>的网络应用程序框架和工具，用以快速开发<strong>高性能、高可靠性的</strong>网络服务器和客户端程序。正好是 storm所需要的。</li>\n</ul>\n<h2 id=\"Storm的特性\"><a class=\"header-anchor\" href=\"#Storm的特性\"></a>Storm的特性</h2>\n<ul>\n<li>简化编程：使用Storm，实现实时处理的复杂性被大大降低了</li>\n<li>开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发</li>\n<li>容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。</li>\n<li>可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。</li>\n<li>可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。</li>\n<li>快速：速度是驱动Storm设计的一个关键因素</li>\n<li>事务性：可以为几乎任何计算得到恰好一次消息语义</li>\n</ul>\n<h2 id=\"安装Storm集群\"><a class=\"header-anchor\" href=\"#安装Storm集群\"></a>安装Storm集群</h2>\n<p>要手工安装Storm，需要先安装以下软件</p>\n<ol>\n<li>Zookeeper集群</li>\n<li>Java</li>\n<li>Python</li>\n<li>Unzip命令</li>\n</ol>\n<h3 id=\"注：\"><a class=\"header-anchor\" href=\"#注：\"></a>注：</h3>\n<p>Nimbus和管理进程将要依赖Java、Python和unzip命令</p>\n<h3 id=\"前期准备\"><a class=\"header-anchor\" href=\"#前期准备\"></a>前期准备</h3>\n<ol>\n<li>准备搭建3节点集群,准备3个虚拟机node1,node2,node3</li>\n<li>配置好hosts映射文件和互相的ssh免密登录</li>\n<li>配置好JDK<br>\n注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好</li>\n</ol>\n<h3 id=\"安装storm\"><a class=\"header-anchor\" href=\"#安装storm\"></a>安装storm</h3>\n<ol>\n<li>准备好storm安装包</li>\n<li>上传解压重命名为storm到/export/server路径下</li>\n<li>修改配置文件 storm.yaml</li>\n</ol>\n<h3 id=\"运行\"><a class=\"header-anchor\" href=\"#运行\"></a>运行</h3>\n<ul>\n<li>前台启动 (前台启动会占用窗口)<br>\n（1）在node1上启动 nimbus进程(主节点) 和 web UI<br>\n（2）在 node2 和 node3 上启动 supervisor(从节点)</li>\n<li>后台启动</li>\n</ul>\n<h4 id=\"ssh脚本实现一键启动\"><a class=\"header-anchor\" href=\"#ssh脚本实现一键启动\"></a>ssh脚本实现一键启动</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.#!/bin/bash</span><br><span class=\"line\">source /etc/profile</span><br><span class=\"line\">nohup /export/server/storm/bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo \"node1 nimbus is running\"</span><br><span class=\"line\">nohup /export/server/storm/bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo \"node1 core is running\"</span><br><span class=\"line\">for host in node2 node3</span><br><span class=\"line\">do</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">ssh $host \"source /etc/profile;nohup /export/server/storm/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;\"</span><br><span class=\"line\">echo \"$host Supervisor is running\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入web页面查看集群\"><a class=\"header-anchor\" href=\"#进入web页面查看集群\"></a>进入web页面查看集群</h3>\n<h2 id=\"使用入门\"><a class=\"header-anchor\" href=\"#使用入门\"></a>使用入门</h2>\n<h3 id=\"MAVEN依赖\"><a class=\"header-anchor\" href=\"#MAVEN依赖\"></a>MAVEN依赖</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.storm<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>storm-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 目前&lt;scope&gt;可以使用5个值：</span></span><br><span class=\"line\"><span class=\"comment\">    * compile，缺省值，适用于所有阶段，会随着项目一起发布。</span></span><br><span class=\"line\"><span class=\"comment\">    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。</span></span><br><span class=\"line\"><span class=\"comment\">    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。</span></span><br><span class=\"line\"><span class=\"comment\">    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</span></span><br><span class=\"line\"><span class=\"comment\">    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理\"><a class=\"header-anchor\" href=\"#编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理\"></a>编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\"> * Version: </span></span><br><span class=\"line\"><span class=\"comment\"> * Description: 读取外部文件,把一行一行的数据发送给下游的bolt</span></span><br><span class=\"line\"><span class=\"comment\"> *              类似于hadoop mapreduce的inputformat</span></span><br><span class=\"line\"><span class=\"comment\"> ***/</span></span><br><span class=\"line\"><span class=\"comment\">//BaseBasicSpout</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadFileSpout</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseRichSpout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SpoutOutputCollector spoutOutputCollector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BufferedReader bufferedReader;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化方法, 类似于这个类的构造器, 只被运行一次</span></span><br><span class=\"line\"><span class=\"comment\">     * spout组件读取原始数据为bolt提供数据</span></span><br><span class=\"line\"><span class=\"comment\">     * 一般用来打开数据链接, 打开网络连接</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> topologyContext 上下文对象, 一般不用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//本地模式</span></span><br><span class=\"line\">            <span class=\"comment\">//this.bufferedReader = new BufferedReader(new FileReader(new File(\"D:\\\\wordcount.txt\")));</span></span><br><span class=\"line\">            <span class=\"comment\">//集群模式</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"keyword\">new</span> File(<span class=\"string\">\"//root//stormdata//wordcount.txt\"</span>)));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.spoutOutputCollector = spoutOutputCollector;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 下一个tuple, tuple是数据传送的基本单位</span></span><br><span class=\"line\"><span class=\"comment\">     * 不断地往下一个组件发送tuple消息</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里面是该spout组件的核心逻辑</span></span><br><span class=\"line\"><span class=\"comment\">     * 如从kafka消息队列中拿到数据</span></span><br><span class=\"line\"><span class=\"comment\">     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">nextTuple</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//一行一行的读取文件内容,并且一行一行的发送</span></span><br><span class=\"line\">            line = bufferedReader.readLine();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (line != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将信息封装成tuple，发送消息给下一个组件</span></span><br><span class=\"line\">\t\t        <span class=\"comment\">//this.collector.emit(new Value(this.words[index]));</span></span><br><span class=\"line\"></span><br><span class=\"line\">                spoutOutputCollector.emit(Arrays.asList(line));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//每发送一个消息，休眠500ms</span></span><br><span class=\"line\">       \t\t\t<span class=\"comment\">// Thread.sleep(500);</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Utils.sleep(500);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过字段声明发出的数据是什么,tuple中的数据的字段名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputFieldsDeclarer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class=\"line\">        outputFieldsDeclarer.declare(<span class=\"keyword\">new</span> Fields(<span class=\"string\">\"line\"</span>));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Bolt类对出入的内容进行单词切分\"><a class=\"header-anchor\" href=\"#编写Bolt类对出入的内容进行单词切分\"></a>编写Bolt类对出入的内容进行单词切分</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\"> * Description: 输入一行一行的数据</span></span><br><span class=\"line\"><span class=\"comment\"> *              对一行数据进行切割</span></span><br><span class=\"line\"><span class=\"comment\"> *              输出单词及单词出现的次数</span></span><br><span class=\"line\"><span class=\"comment\"> ***</span></span><br><span class=\"line\"><span class=\"comment\">//BaseBasicBolt</span></span><br><span class=\"line\"><span class=\"comment\">public class SplitBolt extends BaseRichBolt &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    private OutputCollector outputCollector;</span></span><br><span class=\"line\"><span class=\"comment\">    /**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化方法,只被运行一次</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 配置文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> topologyContext 上下文对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputCollector 数据收集器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.outputCollector = outputCollector;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行业务逻辑的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> tuple 获取的上游数据</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Tuple tuple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取上游句子(字段:\"line\"),从tuple中读取数据</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//获取nextTuple()方法emit()过来的数据\t</span></span><br><span class=\"line\">        String line = tuple.getStringByField(<span class=\"string\">\"line\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//对句子进行切割</span></span><br><span class=\"line\">        String[] words = line.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : words) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//需要发送单词和单词出现的次数,总共两个字段</span></span><br><span class=\"line\">            outputCollector.emit(Arrays.asList(word, <span class=\"string\">\"1\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明发送出去的数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputFieldsDeclarer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class=\"line\">        outputFieldsDeclarer.declare(<span class=\"keyword\">new</span> Fields(<span class=\"string\">\"word\"</span>, <span class=\"string\">\"num\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Bolt类对单词进行计数\"><a class=\"header-anchor\" href=\"#编写Bolt类对单词进行计数\"></a>编写Bolt类对单词进行计数</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce</span></span><br><span class=\"line\"><span class=\"comment\">*              输入单词及单词出现的次数</span></span><br><span class=\"line\"><span class=\"comment\">*              输出打印在控制台</span></span><br><span class=\"line\"><span class=\"comment\">***/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordCountBolt</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseRichBolt</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//定义一个map用于储存单词及其数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Integer&gt; wordCountMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 配置文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> topologyContext 上下文对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputCollector 数据收集器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Tuple tuple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取信息(单词, 数量)</span></span><br><span class=\"line\">        String word = tuple.getStringByField(<span class=\"string\">\"word\"</span>);</span><br><span class=\"line\">        String num = tuple.getStringByField(<span class=\"string\">\"num\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//使用map进行记录</span></span><br><span class=\"line\">        <span class=\"comment\">//开始计数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wordCountMap.containsKey(word))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果map里已经有这个单词,就把数量进行累加</span></span><br><span class=\"line\">            Integer integer = wordCountMap.get(word);</span><br><span class=\"line\">            wordCountMap.put(word, integer + Integer.parseInt(num));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果map里已经没有这个单词,就把单词和数量放入map</span></span><br><span class=\"line\">            wordCountMap.put(word, Integer.parseInt(num));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//打印</span></span><br><span class=\"line\">        System.out.println(wordCountMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//由于不向外发送数据,所以不用写</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写启动类对程序进行整合\"><a class=\"header-anchor\" href=\"#编写启动类对程序进行整合\"></a>编写启动类对程序进行整合</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***</span><br><span class=\"line\"> * Description: wordcount驱动类,用来提交任务</span><br><span class=\"line\"> ***/</span><br><span class=\"line\">public class WordCountTopology &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException &#123;</span><br><span class=\"line\">        //通过TopologyBuilder 封装任务信息</span><br><span class=\"line\">        TopologyBuilder topologyBuilder = new TopologyBuilder();</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"comment\">//设置spout获取数据</span></span><br><span class=\"line\">        <span class=\"comment\">//SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task</span></span><br><span class=\"line\"></span><br><span class=\"line\">        topologyBuilder.setSpout(<span class=\"string\">\"readfilesspout\"</span>, <span class=\"keyword\">new</span> ReadFileSpout(), <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置splitbolt 对句子进行切割</span></span><br><span class=\"line\">        topologyBuilder.setBolt(<span class=\"string\">\"splitbolt\"</span>, <span class=\"keyword\">new</span> SplitBolt(), <span class=\"number\">4</span>).shuffleGrouping(<span class=\"string\">\"readfilesspout\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息</span></span><br><span class=\"line\">        topologyBuilder.setBolt(<span class=\"string\">\"wordcountbolt\"</span>, <span class=\"keyword\">new</span> WordCountBolt(), <span class=\"number\">2</span>).shuffleGrouping(<span class=\"string\">\"splitbolt\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//准备一个配置文件，配置一些topology在集群中运行的参数</span></span><br><span class=\"line\">        Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//启动2个worker!</span></span><br><span class=\"line\">        config.setNumWorkers(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//任务提交有:本地模式 和 集群模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//本地模式</span></span><br><span class=\"line\">        <span class=\"comment\">//LocalCluster localCluster = new LocalCluster();</span></span><br><span class=\"line\">        <span class=\"comment\">//localCluster.submitTopology(\"wordcount\", config, topologyBuilder.createTopology());</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//集群模式,参数:Topology名字, 配置文件, Topology对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//用builder来创建topology</span></span><br><span class=\"line\">        StormSubmitter.submitTopology(<span class=\"string\">\"wordcount2\"</span>, config, topologyBuilder.createTopology());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行程序\"><a class=\"header-anchor\" href=\"#执行程序\"></a>执行程序</h3>\n<ol>\n<li>选择本地模式运行<br>\n直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台</li>\n<li>选择上传到集群进行执行<br>\n首先通过maven的package命名将程序打好jar包</li>\n</ol>\n<h4 id=\"注：-v2\"><a class=\"header-anchor\" href=\"#注：-v2\"></a>注：</h4>\n<p>在storm-core的依赖中加入:<scope>provided</scope><br>\n在上传到node2或node3上, 在指定路径下要确保存在日志文件</p>\n<h1 id=\"Storm-Distributed-RPC（DRPC）\"><a class=\"header-anchor\" href=\"#Storm-Distributed-RPC（DRPC）\"></a>Storm Distributed RPC（DRPC）</h1>\n<h2 id=\"分布式远程过程调用\"><a class=\"header-anchor\" href=\"#分布式远程过程调用\"></a>分布式远程过程调用</h2>\n<ul>\n<li>DRPC的主要作用就是利用Storm的<strong>实时计算</strong>能力来<strong>并行化</strong>CPU intensive的计算。</li>\n<li>对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。</li>\n<li>DRPC其实不能算是storm本身的一个特性，它是通过组合storm的<strong>原语</strong>spout，bolt，topology而成的一种模式(pattern)。</li>\n<li>DRPC通过一个&quot;DRPC server&quot;来进行<strong>协调均衡</strong>。（Storm整合了DRPC server的一个实现）。</li>\n<li>DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。</li>\n<li>对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。</li>\n</ul>\n<h3 id=\"客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果：\"><a class=\"header-anchor\" href=\"#客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果：\"></a>客户端使用DRPC来获取以&quot;<a href=\"http://baidu.com\" target=\"_blank\" rel=\"noopener\">http://baidu.com</a>&quot;为参数的&quot;reach&quot;函数的返回结果：</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DRPCClient client = <span class=\"keyword\">new</span> DRPCClient(<span class=\"string\">\"drpc-host\"</span>, <span class=\"number\">3772</span>);</span><br><span class=\"line\">String result = client.execute(<span class=\"string\">\"reach\"</span>, <span class=\"string\">\"http://baidu.com\"</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用\"><a class=\"header-anchor\" href=\"#1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用\"></a>1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用</h4>\n<h4 id=\"2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。\"><a class=\"header-anchor\" href=\"#2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。\"></a>2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。</h4>\n<h4 id=\"3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。\"><a class=\"header-anchor\" href=\"#3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。\"></a>3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。</h4>\n<h4 id=\"4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。\"><a class=\"header-anchor\" href=\"#4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。\"></a>4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。</h4>\n<h4 id=\"5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。\"><a class=\"header-anchor\" href=\"#5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。\"></a>5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。</h4>\n<h2 id=\"LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）\"><a class=\"header-anchor\" href=\"#LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）\"></a>LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）</h2>\n<h3 id=\"Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下\"><a class=\"header-anchor\" href=\"#Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下\"></a>Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:</h3>\n<ol>\n<li>建立 spout</li>\n<li>将结果返回到DRPC server</li>\n<li>向bolts提供了在tuples集合上进行有限聚集的功能</li>\n</ol>\n<h4 id=\"创建LinearDRPCTopologyBuilder\"><a class=\"header-anchor\" href=\"#创建LinearDRPCTopologyBuilder\"></a>创建LinearDRPCTopologyBuilder</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExclaimBolt</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseBasicBolt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class=\"line\">        String input = tuple.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//简单的在元组的第二个字段的值后加了一个\"!\"</span></span><br><span class=\"line\">        collector.emit(<span class=\"keyword\">new</span> Values(tuple.getValue(<span class=\"number\">0</span>), input + <span class=\"string\">\"!\"</span>));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class=\"line\">        declarer.declare(<span class=\"keyword\">new</span> Fields(<span class=\"string\">\"id\"</span>, <span class=\"string\">\"result\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//我们将DRPC函数名告诉给topology（本例函数名为exclamation）。\t</span></span><br><span class=\"line\">  <span class=\"comment\">//单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。</span></span><br><span class=\"line\">  <span class=\"comment\">//第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。</span></span><br><span class=\"line\">    LinearDRPCTopologyBuilder builder = <span class=\"keyword\">new</span> LinearDRPCTopologyBuilder(<span class=\"string\">\"exclamation\"</span>);</span><br><span class=\"line\">    builder.addBolt(<span class=\"keyword\">new</span> ExclaimBolt(), <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建Local-mode-DRPC\"><a class=\"header-anchor\" href=\"#创建Local-mode-DRPC\"></a>创建Local mode DRPC</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。</span></span><br><span class=\"line\">LocalDRPC drpc = <span class=\"keyword\">new</span> LocalDRPC();</span><br><span class=\"line\"><span class=\"comment\">//然后创建LocalCluster来以本地模式来运行该topology。</span></span><br><span class=\"line\">LocalCluster cluster = <span class=\"keyword\">new</span> LocalCluster();</span><br><span class=\"line\"><span class=\"comment\">//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。</span></span><br><span class=\"line\"><span class=\"comment\">//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象</span></span><br><span class=\"line\"><span class=\"comment\">//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;</span></span><br><span class=\"line\">cluster.submitTopology(<span class=\"string\">\"drpc-demo\"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class=\"line\"><span class=\"comment\">//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Results for 'hello':\"</span> + drpc.execute(<span class=\"string\">\"exclamation\"</span>, <span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">cluster.shutdown();</span><br><span class=\"line\">drpc.shutdown();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Remote-mode-DRPC\"><a class=\"header-anchor\" href=\"#Remote-mode-DRPC\"></a>Remote mode DRPC</h4>\n<ol>\n<li>建立DRPC servers</li>\n<li>配置DRPC servers的位置</li>\n<li>向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：</li>\n</ol>\n<h5 id=\"1-用storm脚本建立DRPC-server：\"><a class=\"header-anchor\" href=\"#1-用storm脚本建立DRPC-server：\"></a>1. 用storm脚本建立DRPC server：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/storm drpc</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置\"><a class=\"header-anchor\" href=\"#2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置\"></a>2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drpc.servers:</span><br><span class=\"line\">  - <span class=\"string\">\"drpc1.foo.com\"</span></span><br><span class=\"line\">  - <span class=\"string\">\"drpc2.foo.com\"</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"3-通过StormSubmitter建立DRPC-topologies\"><a class=\"header-anchor\" href=\"#3-通过StormSubmitter建立DRPC-topologies\"></a>3. 通过StormSubmitter建立DRPC topologies</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormSubmitter.submitTopology(<span class=\"string\">\"exclamation-drpc\"</span>, conf, builder.createRemoteTopology());</span><br></pre></td></tr></table></figure>\n<h2 id=\"Storm-DRPC深入\"><a class=\"header-anchor\" href=\"#Storm-DRPC深入\"></a>Storm DRPC深入</h2>\n<p>分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的<strong>函数调用</strong>进行<strong>并行计算</strong>。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。<br>\n可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。</p>\n<h3 id=\"注：-v3\"><a class=\"header-anchor\" href=\"#注：-v3\"></a>注：</h3>\n<p>Storm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）<br>\nStorm只负责数据的计算，不负责数据的存储<br>\n2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim\" alt=\"mark\"><br>\n<strong>其中:</strong><br>\nNimbus：负责资源分配和任务调度。<br>\nSupervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>\nWorker：运行具体处理组件逻辑的进程。<br>\nTask：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"注：-v4\"><a class=\"header-anchor\" href=\"#注：-v4\"></a>注：</h3>\n<p><strong>DataSource</strong>: 数据源<br>\n<strong>Spout</strong>：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。<br>\n<strong>Bolt</strong>：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。<br>\n<strong>Tuple</strong>：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.<br>\n<strong>Stream</strong>：源源不断传递的tuple就组成了stream。<br>\n<strong>Topology</strong>：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。</p>\n<h3 id=\"分组策略\"><a class=\"header-anchor\" href=\"#分组策略\"></a>分组策略</h3>\n<ol>\n<li>随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用</li>\n<li>字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。</li>\n<li>LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。</li>\n</ol>\n<h2 id=\"zookeeper安装和使用\"><a class=\"header-anchor\" href=\"#zookeeper安装和使用\"></a>zookeeper安装和使用</h2>\n<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>\nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>\nZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p>\n<h3 id=\"zoo-sample-cfg文件配置\"><a class=\"header-anchor\" href=\"#zoo-sample-cfg文件配置\"></a>zoo_sample.cfg文件配置</h3>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The number of milliseconds of each tick</span></span><br><span class=\"line\"><span class=\"attr\">tickTime</span>=<span class=\"string\">2000</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that the initial </span></span><br><span class=\"line\"><span class=\"comment\"># synchronization phase can take</span></span><br><span class=\"line\"><span class=\"attr\">initLimit</span>=<span class=\"string\">10</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that can pass between </span></span><br><span class=\"line\"><span class=\"comment\"># sending a request and getting an acknowledgement</span></span><br><span class=\"line\"><span class=\"attr\">syncLimit</span>=<span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"comment\"># the directory where the snapshot is stored.</span></span><br><span class=\"line\"><span class=\"comment\"># do not use /tmp for storage, /tmp here is just </span></span><br><span class=\"line\"><span class=\"comment\"># example sakes.</span></span><br><span class=\"line\"><span class=\"attr\">dataDir</span>=<span class=\"string\">D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\data</span></span><br><span class=\"line\"><span class=\"attr\">dataLogDir</span>=<span class=\"string\">D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\log</span></span><br><span class=\"line\"><span class=\"comment\"># the port at which the clients will connect</span></span><br><span class=\"line\"><span class=\"attr\">clientPort</span>=<span class=\"string\">2181</span></span><br><span class=\"line\"><span class=\"comment\"># the maximum number of client connections.</span></span><br><span class=\"line\"><span class=\"comment\"># increase this if you need to handle more clients</span></span><br><span class=\"line\"><span class=\"comment\">#maxClientCnxns=60</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Be sure to read the maintenance section of the </span></span><br><span class=\"line\"><span class=\"comment\"># administrator guide before turning on autopurge.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The number of snapshots to retain in dataDir</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.snapRetainCount=3</span></span><br><span class=\"line\"><span class=\"comment\"># Purge task interval in hours</span></span><br><span class=\"line\"><span class=\"comment\"># Set to \"0\" to disable auto purge feature</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参数解释\"><a class=\"header-anchor\" href=\"#参数解释\"></a>参数解释</h3>\n<ul>\n<li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li>\n<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒</li>\n<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒</li>\n<li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li>\n<li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li>\n</ul>\n<h3 id=\"异常\"><a class=\"header-anchor\" href=\"#异常\"></a>异常</h3>\n<p>Socket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information<br>\n**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg</p>\n<p>zookeeper启动成功<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim\" alt=\"mark\"></p>\n<h2 id=\"Zookeeper伪分布式集群搭建\"><a class=\"header-anchor\" href=\"#Zookeeper伪分布式集群搭建\"></a>Zookeeper伪分布式集群搭建</h2>\n<ol>\n<li>将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。</li>\n<li>创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。</li>\n<li>在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.</li>\n<li>修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改</li>\n</ol>\n<h3 id=\"zoo-cfg文件如下\"><a class=\"header-anchor\" href=\"#zoo-cfg文件如下\"></a>zoo.cfg文件如下</h3>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The number of milliseconds of each tick</span></span><br><span class=\"line\"><span class=\"comment\"># 服务器与客户端之间交互的基本时间单元（ms）</span></span><br><span class=\"line\"><span class=\"attr\">tickTime</span>=<span class=\"string\">2000</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that the initial </span></span><br><span class=\"line\"><span class=\"comment\"># synchronization phase can take</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper所能接受的客户端数量</span></span><br><span class=\"line\"><span class=\"attr\">initLimit</span>=<span class=\"string\">10</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that can pass between </span></span><br><span class=\"line\"><span class=\"comment\"># sending a request and getting an acknowledgement</span></span><br><span class=\"line\"><span class=\"comment\"># 服务器与客户端之间请求和应答的时间间隔</span></span><br><span class=\"line\"><span class=\"attr\">syncLimit</span>=<span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"comment\"># the directory where the snapshot is stored.</span></span><br><span class=\"line\"><span class=\"comment\"># do not use /tmp for storage, /tmp here is just </span></span><br><span class=\"line\"><span class=\"comment\"># example sakes.</span></span><br><span class=\"line\"><span class=\"comment\"># 保存zookeeper数据，日志路径</span></span><br><span class=\"line\"><span class=\"attr\">dataDir</span>=<span class=\"string\">D:/DevelopSoftware/zookeeper/zk-data/8001/data</span></span><br><span class=\"line\"><span class=\"attr\">dataLogDir</span>=<span class=\"string\">D:/DevelopSoftware/zookeeper/zk-data/8001/log</span></span><br><span class=\"line\"><span class=\"comment\"># the port at which the clients will connect</span></span><br><span class=\"line\"><span class=\"comment\"># 这是客户端链接的端口号</span></span><br><span class=\"line\"><span class=\"attr\">clientPort</span>=<span class=\"string\">2181\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\"># the maximum number of client connections.</span></span><br><span class=\"line\"><span class=\"comment\"># increase this if you need to handle more clients</span></span><br><span class=\"line\"><span class=\"comment\">#maxClientCnxns=60</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Be sure to read the maintenance section of the </span></span><br><span class=\"line\"><span class=\"comment\"># administrator guide before turning on autopurge.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The number of snapshots to retain in dataDir</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.snapRetainCount=3</span></span><br><span class=\"line\"><span class=\"comment\"># Purge task interval in hours</span></span><br><span class=\"line\"><span class=\"comment\"># Set to \"0\" to disable auto purge feature</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.purgeInterval=1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口</span></span><br><span class=\"line\"><span class=\"comment\"># server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。</span></span><br><span class=\"line\"><span class=\"comment\"># 客户端与zookeeper相互交互的端口</span></span><br><span class=\"line\"><span class=\"meta\">server.1</span>=<span class=\"string\">127.0.0.1:8001:9001</span></span><br><span class=\"line\"><span class=\"meta\">server.2</span>=<span class=\"string\">127.0.0.1:8002:9002</span></span><br><span class=\"line\"><span class=\"meta\">server.3</span>=<span class=\"string\">127.0.0.1:8003:9003</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"报错\"><a class=\"header-anchor\" href=\"#报错\"></a>报错</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [myid:<span class=\"number\">1</span>] - WARN  [WorkerSender[myid=<span class=\"number\">1</span>]:QuorumCnxManager@<span class=\"number\">584</span>] - Cannot open channel to <span class=\"number\">3</span> at election address /<span class=\"number\">127.0</span>.0.1:<span class=\"number\">9003</span></span><br><span class=\"line\">java.net.ConnectException: Connection refused: connect</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:<span class=\"number\">85</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:<span class=\"number\">350</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:<span class=\"number\">206</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:<span class=\"number\">188</span>)</span><br><span class=\"line\">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:<span class=\"number\">172</span>)</span><br><span class=\"line\">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:<span class=\"number\">392</span>)</span><br><span class=\"line\">        at java.net.Socket.connect(Socket.java:<span class=\"number\">589</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:<span class=\"number\">558</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:<span class=\"number\">534</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:<span class=\"number\">454</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:<span class=\"number\">435</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"报错解决办法\"><a class=\"header-anchor\" href=\"#报错解决办法\"></a>报错解决办法</h3>\n<p>产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。</p>\n<h2 id=\"dubbo的引入\"><a class=\"header-anchor\" href=\"#dubbo的引入\"></a>dubbo的引入</h2>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim\" alt=\"mark\"></p>\n<ul>\n<li>\n<p>单一应用架构<br>\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>\n此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。</p>\n</li>\n<li>\n<p>垂直应用架构<br>\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>\n此时，用于加速前端页面开发的  Web框架(MVC)  是关键。</p>\n</li>\n<li>\n<p>分布式服务架构<br>\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>\n此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。</p>\n</li>\n<li>\n<p>流动计算架构<br>\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率<br>\n此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。</p>\n</li>\n</ul>\n<p>在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p>\n<ol>\n<li>\n<p>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。<br>\n此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</p>\n</li>\n<li>\n<p>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。<br>\n这时，需要自动画出应用间的依赖关系图，以理清理关系。</p>\n</li>\n<li>\n<p>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？<br>\n为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。<br>\n其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>\n</li>\n</ol>\n<h3 id=\"Dubbo的工作原理\"><a class=\"header-anchor\" href=\"#Dubbo的工作原理\"></a>Dubbo的工作原理</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"节点角色说明：\"><a class=\"header-anchor\" href=\"#节点角色说明：\"></a>节点角色说明：</h3>\n<ul>\n<li>Provider:  暴露服务的服务提供方。</li>\n<li>Consumer:  调用远程服务的服务消费方。</li>\n<li>Registry:  服务注册与发现的注册中心。</li>\n<li>Monitor:  统计服务的调用次调和调用时间的监控中心。</li>\n<li>Container:  服务运行容器。</li>\n</ul>\n<h3 id=\"调用关系说明：\"><a class=\"header-anchor\" href=\"#调用关系说明：\"></a>调用关系说明：</h3>\n<ul>\n<li>服务容器负责启动，加载，运行服务提供者。</li>\n<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>\n</ul>\n<h2 id=\"Dubbo-admin管理平台的安装\"><a class=\"header-anchor\" href=\"#Dubbo-admin管理平台的安装\"></a>Dubbo-admin管理平台的安装</h2>\n<h3 id=\"dubbo-admin-本地编译打包\"><a class=\"header-anchor\" href=\"#dubbo-admin-本地编译打包\"></a>dubbo-admin 本地编译打包</h3>\n<p><a href=\"https://github.com/alibaba/dubbo/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/dubbo/releases</a><br>\n<a href=\"https://github.com/apache/incubator-dubbo/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo/releases</a><br>\n解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址<br>\n<a href=\"https://github.com/apache/incubator-dubbo-ops\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo-ops</a></p>\n<h3 id=\"克隆项目\"><a class=\"header-anchor\" href=\"#克隆项目\"></a>克隆项目</h3>\n<p>apache 下的dubbo-admin git仓库：<br>\n<a href=\"https://github.com/apache/incubator-dubbo-ops\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo-ops</a><br>\n先把这个项目用git克隆到本地中<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"application-properties配置\"><a class=\"header-anchor\" href=\"#application-properties配置\"></a>application.properties配置</h4>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"application-test-properties配置\"><a class=\"header-anchor\" href=\"#application-test-properties配置\"></a>application-test.properties配置</h4>\n<p><img src=\"https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg\" alt></p>\n<h4 id=\"tomcat配置启动项\"><a class=\"header-anchor\" href=\"#tomcat配置启动项\"></a>tomcat配置启动项</h4>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"配置部署war包\"><a class=\"header-anchor\" href=\"#配置部署war包\"></a>配置部署war包</h4>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim\" alt=\"mark\"><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。\"><a class=\"header-anchor\" href=\"#说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。\"></a>说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。</h4>\n<h4 id=\"Production-Setup\"><a class=\"header-anchor\" href=\"#Production-Setup\"></a>Production Setup</h4>\n<ol>\n<li>\n<p>Clone source code on develop branch git clone <a href=\"https://github.com/apache/incubator-dubbo-admin.git\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo-admin.git</a></p>\n</li>\n<li>\n<p>Specify registry address in dubbo-admin-server/src/main/resources/application.properties</p>\n</li>\n<li>\n<p>Build<br>\nmvn clean package<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>Start<br>\nmvn --projects dubbo-admin-server spring-boot:run<br>\n<strong>启动Zookeeper集群</strong><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim\" alt=\"mark\"><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>Visit <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim\" alt=\"mark\"></p>\n</li>\n</ol>\n<h3 id=\"报错1\"><a class=\"header-anchor\" href=\"#报错1\"></a>报错1</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"解决办法\"><a class=\"header-anchor\" href=\"#解决办法\"></a>解决办法</h3>\n<p>如果SpringBoot在子模块，直接main启动子模块会报错。<br>\n解决办法就是在IDEA MAVEN Projects-&gt;dubbo-admin-server-&gt;Plugins-&gt;spring-boot-&gt;spring-boot:run-&gt;run maven build<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"报错2\"><a class=\"header-anchor\" href=\"#报错2\"></a>报错2</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"解决办法-v2\"><a class=\"header-anchor\" href=\"#解决办法-v2\"></a>解决办法</h3>\n<p>taskkill /pid 8876 /f</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim\" alt=\"mark\"></p>\n<h2 id=\"zookeeper与dubbo关系\"><a class=\"header-anchor\" href=\"#zookeeper与dubbo关系\"></a>zookeeper与dubbo关系</h2>\n<p>dubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；</p>\n<h2 id=\"Netty在Dubbo中的应用\"><a class=\"header-anchor\" href=\"#Netty在Dubbo中的应用\"></a>Netty在Dubbo中的应用</h2>\n<p><strong>Dubbo 底层使用的是 Netty 作为网络通信</strong></p>\n<ol>\n<li>dubbo的Consumer消费者如何使用Netty</li>\n</ol>\n<h3 id=\"调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。\"><a class=\"header-anchor\" href=\"#调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。\"></a>调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get remote service proxy</span></span><br><span class=\"line\">DemoService demoService = (DemoService) context.getBean(<span class=\"string\">\"demoService\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存\"><a class=\"header-anchor\" href=\"#调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存\"></a>调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeClient <span class=\"title\">getSharedClient</span><span class=\"params\">(URL url)</span></span>&#123;</span><br><span class=\"line\">\tString key=url.getAddress();</span><br><span class=\"line\">\tReferenceCountExchangeClient client=referenceClientMap.get(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(client!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!=client.isClosed())&#123;</span><br><span class=\"line\">\t\t\tclient.incrementAndGetCount();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> client;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\treferenceClientMap.remove(key);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">synchronized</span>(key.intern())&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这个initClient()方法是创建Netty的client的</span></span><br><span class=\"line\">\t\tExchangeClient exchangeClient=initClient(url);</span><br><span class=\"line\">\t\tclient=<span class=\"keyword\">new</span> ReferenceCountExchangeClient(exchangeClient,ghostClientMap);</span><br><span class=\"line\">\t\treferenceClientMap.put(key,client);</span><br><span class=\"line\">\t\tghostClientMap.remove(key);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> client;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。\"><a class=\"header-anchor\" href=\"#最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。\"></a>最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbstractClient</span><span class=\"params\">(URL url, ChannelHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    doOpen();</span><br><span class=\"line\">    connect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"doOpent-方法用来创建-Netty-的-bootstrap-：\"><a class=\"header-anchor\" href=\"#doOpent-方法用来创建-Netty-的-bootstrap-：\"></a>doOpent 方法用来创建 Netty 的 bootstrap ：</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    NettyHelper.setNettyLoggerFactory();</span><br><span class=\"line\">    bootstrap = <span class=\"keyword\">new</span> ClientBootstrap(channelFactory);</span><br><span class=\"line\">    bootstrap.setOption(<span class=\"string\">\"keepAlive\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    bootstrap.setOption(<span class=\"string\">\"tcpNoDelay\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    bootstrap.setOption(<span class=\"string\">\"connectTimeoutMillis\"</span>, getTimeout());</span><br><span class=\"line\">    <span class=\"keyword\">final</span> NettyHandler nettyHandler = <span class=\"keyword\">new</span> NettyHandler(getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    bootstrap.setPipelineFactory(<span class=\"keyword\">new</span> ChannelPipelineFactory() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ChannelPipeline <span class=\"title\">getPipeline</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            NettyCodecAdapter adapter = <span class=\"keyword\">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"decoder\"</span>, adapter.getDecoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"encoder\"</span>, adapter.getEncoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"handler\"</span>, nettyHandler);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipeline;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"connect-方法用来连接提供者：\"><a class=\"header-anchor\" href=\"#connect-方法用来连接提供者：\"></a>connect 方法用来连接提供者：</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"comment\">//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 </span></span><br><span class=\"line\">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class=\"line\">        Channel newChannel = future.getChannel();</span><br><span class=\"line\">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。\"><a class=\"header-anchor\" href=\"#main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。\"></a>main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request, <span class=\"keyword\">int</span> timeout)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    Request req = <span class=\"keyword\">new</span> Request();</span><br><span class=\"line\">    req.setVersion(<span class=\"string\">\"2.0.0\"</span>);</span><br><span class=\"line\">    req.setTwoWay(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    req.setData(request);</span><br><span class=\"line\">    DefaultFuture future = <span class=\"keyword\">new</span> DefaultFuture(channel, req, timeout);</span><br><span class=\"line\">\t<span class=\"comment\">//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  </span></span><br><span class=\"line\">    channel.send(req);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dubbo-的-Provider-提供者如何使用-Netty\"><a class=\"header-anchor\" href=\"#dubbo-的-Provider-提供者如何使用-Netty\"></a>dubbo 的 Provider 提供者如何使用 Netty</h2>\n<p>Provider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。</p>\n<h3 id=\"NettyServer-对象的构造方法同样是-doOpen-方法。\"><a class=\"header-anchor\" href=\"#NettyServer-对象的构造方法同样是-doOpen-方法。\"></a>NettyServer 对象的构造方法同样是 doOpen 方法。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    NettyHelper.setNettyLoggerFactory();</span><br><span class=\"line\">\t<span class=\"comment\">//boss 线程，worker 线程，和 ServerBootstrap</span></span><br><span class=\"line\">    ExecutorService boss = Executors.newCachedThreadPool(<span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">\"NettyServerBoss\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    ExecutorService worker = Executors.newCachedThreadPool(<span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">\"NettyServerWorker\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    ChannelFactory channelFactory = <span class=\"keyword\">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class=\"line\">    bootstrap = <span class=\"keyword\">new</span> ServerBootstrap(channelFactory);</span><br><span class=\"line\">\t<span class=\"comment\">//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> NettyHandler nettyHandler = <span class=\"keyword\">new</span> NettyHandler(getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    channels = nettyHandler.getChannels();</span><br><span class=\"line\">    bootstrap.setPipelineFactory(<span class=\"keyword\">new</span> ChannelPipelineFactory() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ChannelPipeline <span class=\"title\">getPipeline</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            NettyCodecAdapter adapter = <span class=\"keyword\">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"decoder\"</span>, adapter.getDecoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"encoder\"</span>, adapter.getEncoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"handler\"</span>, nettyHandler);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipeline;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    channel = bootstrap.bind(getBindAddress());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Netty在Dubbo中的应用总结\"><a class=\"header-anchor\" href=\"#Netty在Dubbo中的应用总结\"></a>Netty在Dubbo中的应用总结</h3>\n<p>dubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。</p>\n<h2 id=\"Apache-Storm分布式消息系统\"><a class=\"header-anchor\" href=\"#Apache-Storm分布式消息系统\"></a>Apache Storm分布式消息系统</h2>\n<p>Apache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。</p>\n<h3 id=\"什么是分布式消息系统？\"><a class=\"header-anchor\" href=\"#什么是分布式消息系统？\"></a>什么是分布式消息系统？</h3>\n<p>分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。<br>\n大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。<br>\n一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。<br>\n需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim\" alt=\"mark\"></p>\n<p>下表描述了一些流行的高吞吐量消息传递系统 -<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim\" alt=\"mark\"><br>\nThrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。<br>\nApache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。<br>\nStorm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。</p>\n<h2 id=\"Storm工作原理\"><a class=\"header-anchor\" href=\"#Storm工作原理\"></a>Storm工作原理</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"Storm与传统关系型数据库\"><a class=\"header-anchor\" href=\"#Storm与传统关系型数据库\"></a>Storm与传统关系型数据库</h3>\n<p>传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存<br>\n传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据<br>\n关系型数据库重视事务，并发控制，相对来说Storm比较简陋<br>\nStorm与Hadoop，Spark等是流行的大数据方案<br>\n与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑</p>\n<ol>\n<li>\n<p>topology<br>\nStorm集群中有两种组件节点，一种是<strong>控制节点</strong>(Nimbus节点)，另一种是<strong>工作节点</strong>(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。<br>\n和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去<br>\n数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>zookeeper集群<br>\nstorm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。<br>\n部署zookeeper有些需要注意的地方：<br>\n①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控<br>\n②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用</p>\n</li>\n<li>\n<p>Component<br>\nStorm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口<br>\n全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>Spout<br>\nSpout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISpout</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextTuple</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ack</span><span class=\"params\">(Object msgId)</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fail</span><span class=\"params\">(Object msgId)</span></span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>①open()方法 – 初始化方法<br>\nclose() – 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行<br>\n②ack(Object msgId) – 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放<br>\n③fail(Object msgId) – 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放<br>\n④nextTuple() – 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout</p>\n</li>\n<li>\n<p>Bolt<br>\nBolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成<br>\nprepare方法 – 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境<br>\ndeclareOutputFields方法 – 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似<br>\ncleanup方法 – 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。<br>\nexecute方法 – 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。<br>\nStorm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException<br>\n通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple)</p>\n</li>\n<li>\n<p>Topology运行方式<br>\n在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式</p>\n</li>\n</ol>\n<h3 id=\"本地运行的提交方式\"><a class=\"header-anchor\" href=\"#本地运行的提交方式\"></a>本地运行的提交方式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalCluster cluster = <span class=\"keyword\">new</span> LocalCluster(); </span><br><span class=\"line\">cluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); </span><br><span class=\"line\">Thread.sleep(<span class=\"number\">2000</span>); </span><br><span class=\"line\">cluster.shutdown();</span><br></pre></td></tr></table></figure>\n<h3 id=\"分布式提交方式\"><a class=\"header-anchor\" href=\"#分布式提交方式\"></a>分布式提交方式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology());</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。</p>\n<h3 id=\"运行的命令如下\"><a class=\"header-anchor\" href=\"#运行的命令如下\"></a>运行的命令如下###</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm jar StormTopology.jar mainclass [args]</span><br></pre></td></tr></table></figure>\n<h2 id=\"storm守护进程的命令\"><a class=\"header-anchor\" href=\"#storm守护进程的命令\"></a>storm守护进程的命令</h2>\n<p>Nimbus: storm nimbus 启动nimbus守护进程<br>\nSupervisor: storm supervisor 启动supervisor守护迚程<br>\nUI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。<br>\nDRPC: storm drpc 启动DRPC的守护进程</p>\n<h2 id=\"storm管理命令\"><a class=\"header-anchor\" href=\"#storm管理命令\"></a>storm管理命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAR：storm jar topology_jar topology_class [arguments...]</span><br></pre></td></tr></table></figure>\n<p>jar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KILL：storm kill topology_name [-w wait_time]</span><br></pre></td></tr></table></figure>\n<p>杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deactivate：storm deactivate topology_name</span><br></pre></td></tr></table></figure>\n<p>停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Activate：storm activate topology_name</span><br></pre></td></tr></table></figure>\n<p>启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]...</span><br></pre></td></tr></table></figure>\n<p>rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8</span><br></pre></td></tr></table></figure>\n<p>还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等</p>\n<h2 id=\"Storm与Hadoop的对比\"><a class=\"header-anchor\" href=\"#Storm与Hadoop的对比\"></a>Storm与Hadoop的对比</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim\" alt=\"mark\"></p>\n<h2 id=\"DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下：\"><a class=\"header-anchor\" href=\"#DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下：\"></a>DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：</h2>\n<p>引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。</p>\n<ol>\n<li>接收到一个RPC调用请求；</li>\n<li>发送请求到Storm上的<strong>拓扑</strong>；</li>\n<li>从Storm上接收计算结果；</li>\n<li>将计算结果返回给客户端。</li>\n</ol>\n<h2 id=\"附录\"><a class=\"header-anchor\" href=\"#附录\"></a>附录</h2>\n<h3 id=\"maven更新镜像源\"><a class=\"header-anchor\" href=\"#maven更新镜像源\"></a>maven更新镜像源</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class=\"line\">\t          <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">\t              <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>alimaven<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t              <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">\t             <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun maven<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t             <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">\t         <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">\t          <span class=\"comment\">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>repo1<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Human Readable Name for this Mirror.<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">     </span><br><span class=\"line\">         <span class=\"comment\">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>repo2<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Human Readable Name for this Mirror.<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"RPC和MQ对比及其适用-不适用场合\"><a class=\"header-anchor\" href=\"#RPC和MQ对比及其适用-不适用场合\"></a>RPC和MQ对比及其适用/不适用场合</h2>\n<h3 id=\"系统结构\"><a class=\"header-anchor\" href=\"#系统结构\"></a>系统结构</h3>\n<p><strong>RPC系统结构：</strong><br>\nCosume &lt;=&gt; Provider<br>\nConsumer调用的Provider提供的服务</p>\n<p><strong>Message Queue系统结构：</strong><br>\nSender &lt;=&gt; Queue &lt;=&gt; Reciver<br>\nSender发送消息给Queue；Receiver从Queue拿到消息来处理。</p>\n<h3 id=\"功能的特点\"><a class=\"header-anchor\" href=\"#功能的特点\"></a>功能的特点</h3>\n<p>在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。</p>\n<h3 id=\"消息的特点\"><a class=\"header-anchor\" href=\"#消息的特点\"></a>消息的特点</h3>\n<ul>\n<li>Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。</li>\n<li>Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响</li>\n<li>Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。</li>\n<li>所以对于有同步返回需求，用Message Queue则变得麻烦了。</li>\n</ul>\n<h3 id=\"PRC的特点\"><a class=\"header-anchor\" href=\"#PRC的特点\"></a>PRC的特点</h3>\n<ul>\n<li>同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。</li>\n<li>RPC也可以是异步调用。</li>\n<li>由于等待结果，Consumer（Client）会有线程消耗。</li>\n<li>如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。</li>\n</ul>\n<h3 id=\"适用场合说明\"><a class=\"header-anchor\" href=\"#适用场合说明\"></a>适用场合说明</h3>\n<ul>\n<li>希望同步得到结果的场合，RPC合适。</li>\n<li>希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。</li>\n<li>不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。</li>\n<li>随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。</li>\n<li>这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。</li>\n</ul>\n<h3 id=\"不适用场合说明\"><a class=\"header-anchor\" href=\"#不适用场合说明\"></a>不适用场合说明</h3>\n<p>RPC同步调用使用Message Queue来传输调用信息。<br>\n发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Storm入门\"><a class=\"header-anchor\" href=\"#Storm入门\"></a>Storm入门</h1>\n<p>Storm是一个<strong>分布式的</strong>，可靠的，容错的<strong>数据流处理系统</strong>。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。<br>\nStorm是Twitter开源的一个分布式的实时计算系统，用于数据的实时分析，持续计算，分布式RPC等等<br>\nStorm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的<br>\nStorm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。<br>\n一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。<br>\n注：Storm中的核心术语<br>\n<strong>spout</strong>龙卷，读取原始数据为bolt提供数据<br>\n<strong>bolt</strong> 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果<br>\n<strong>nimbus</strong> 雨云，主节点的守护进程，负责为工作节点分发任务<br>\n<strong>topology</strong> 拓扑结构，Storm的一个任务单元<br>\n<strong>define field(s)</strong> 定义域，由spout或bolt提供，被bolt接收</p>\n<h2 id=\"Storm应用案例\"><a class=\"header-anchor\" href=\"#Storm应用案例\"></a>Storm应用案例</h2>\n<ul>\n<li>数据处理流，Storm不需要中间队列</li>\n<li>连续计算。连续发送数据到客户端，使它们能够实时更新并显示结果。</li>\n<li><strong>分布式远程过程调用</strong></li>\n<li>频繁的CPU密集型操作<strong>并行化</strong>。</li>\n</ul>\n<h2 id=\"Storm组件\"><a class=\"header-anchor\" href=\"#Storm组件\"></a>Storm组件</h2>\n<p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。<br>\n主节点运行着一个叫做<strong>Nimbus</strong>的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。<br>\n<strong>Supervisor</strong>守护进程作为拓扑的一部分运行在工作节点上。<br>\n一个Storm<strong>拓扑结构</strong>在不同的机器上运行着众多的工作节点。<br>\n因为Storm在<strong>Zookeeper</strong>或本地磁盘上<strong>维持所有的集群状态</strong>，守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康<br>\n在系统底层，Storm使用了<strong>zeromq</strong>，这是一种先进的，可嵌入的<strong>网络通讯库</strong>，它提供的绝妙功能使Storm成为可能。其中，Storm只用了push/pull sockets</p>\n<h3 id=\"注：zeromq的特性\"><a class=\"header-anchor\" href=\"#注：zeromq的特性\"></a>注：zeromq的特性</h3>\n<ul>\n<li>一个并发架构的Socket库</li>\n<li>对于集群产品和超级计算，比TCP要快</li>\n<li>可通过inproc（进程内）, IPC（进程间）, TCP和multicast(多播协议)通信</li>\n<li>异步I / O的可扩展的多核消息传递应用程序</li>\n<li>利用扇出(fanout), 发布订阅（PUB-SUB）,管道（pipeline）, 请求应答（REQ-REP），等方式实现N-N连接<br>\n注：最新的Storm已不再必须依赖<strong>ZeroMQ</strong>，各种依赖的库和软件也已经有更新的版本。<br>\n最近版本的Storm支持使用<strong>netty</strong>做消息队列。<br>\nNetty提供<strong>异步的、事件驱动</strong>的网络应用程序框架和工具，用以快速开发<strong>高性能、高可靠性的</strong>网络服务器和客户端程序。正好是 storm所需要的。</li>\n</ul>\n<h2 id=\"Storm的特性\"><a class=\"header-anchor\" href=\"#Storm的特性\"></a>Storm的特性</h2>\n<ul>\n<li>简化编程：使用Storm，实现实时处理的复杂性被大大降低了</li>\n<li>开发容易：使用一门基于JVM的语言开发会更容易，也可以借助一个小的中间件，在Storm上使用任何语言开发</li>\n<li>容错：Storm集群会关注工作节点状态，如果宕机了必要的时候会重新分配任务。</li>\n<li>可扩展：所有需要为扩展集群所做的工作就是增加机器。Storm会在新机器就绪时向它们分配任务。</li>\n<li>可靠的：所有消息都可保证至少处理一次。如果出错了，消息可能处理不只一次，永远不会丢失消息。</li>\n<li>快速：速度是驱动Storm设计的一个关键因素</li>\n<li>事务性：可以为几乎任何计算得到恰好一次消息语义</li>\n</ul>\n<h2 id=\"安装Storm集群\"><a class=\"header-anchor\" href=\"#安装Storm集群\"></a>安装Storm集群</h2>\n<p>要手工安装Storm，需要先安装以下软件</p>\n<ol>\n<li>Zookeeper集群</li>\n<li>Java</li>\n<li>Python</li>\n<li>Unzip命令</li>\n</ol>\n<h3 id=\"注：\"><a class=\"header-anchor\" href=\"#注：\"></a>注：</h3>\n<p>Nimbus和管理进程将要依赖Java、Python和unzip命令</p>\n<h3 id=\"前期准备\"><a class=\"header-anchor\" href=\"#前期准备\"></a>前期准备</h3>\n<ol>\n<li>准备搭建3节点集群,准备3个虚拟机node1,node2,node3</li>\n<li>配置好hosts映射文件和互相的ssh免密登录</li>\n<li>配置好JDK<br>\n注：storm是依赖于zookeeper的,搭建storm集群前,必须先把zookeeper集群搭建好</li>\n</ol>\n<h3 id=\"安装storm\"><a class=\"header-anchor\" href=\"#安装storm\"></a>安装storm</h3>\n<ol>\n<li>准备好storm安装包</li>\n<li>上传解压重命名为storm到/export/server路径下</li>\n<li>修改配置文件 storm.yaml</li>\n</ol>\n<h3 id=\"运行\"><a class=\"header-anchor\" href=\"#运行\"></a>运行</h3>\n<ul>\n<li>前台启动 (前台启动会占用窗口)<br>\n（1）在node1上启动 nimbus进程(主节点) 和 web UI<br>\n（2）在 node2 和 node3 上启动 supervisor(从节点)</li>\n<li>后台启动</li>\n</ul>\n<h4 id=\"ssh脚本实现一键启动\"><a class=\"header-anchor\" href=\"#ssh脚本实现一键启动\"></a>ssh脚本实现一键启动</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.#!/bin/bash</span><br><span class=\"line\">source /etc/profile</span><br><span class=\"line\">nohup /export/server/storm/bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo \"node1 nimbus is running\"</span><br><span class=\"line\">nohup /export/server/storm/bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo \"node1 core is running\"</span><br><span class=\"line\">for host in node2 node3</span><br><span class=\"line\">do</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">ssh $host \"source /etc/profile;nohup /export/server/storm/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;\"</span><br><span class=\"line\">echo \"$host Supervisor is running\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入web页面查看集群\"><a class=\"header-anchor\" href=\"#进入web页面查看集群\"></a>进入web页面查看集群</h3>\n<h2 id=\"使用入门\"><a class=\"header-anchor\" href=\"#使用入门\"></a>使用入门</h2>\n<h3 id=\"MAVEN依赖\"><a class=\"header-anchor\" href=\"#MAVEN依赖\"></a>MAVEN依赖</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.storm<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>storm-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 目前&lt;scope&gt;可以使用5个值：</span></span><br><span class=\"line\"><span class=\"comment\">    * compile，缺省值，适用于所有阶段，会随着项目一起发布。</span></span><br><span class=\"line\"><span class=\"comment\">    * provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。</span></span><br><span class=\"line\"><span class=\"comment\">    * runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。</span></span><br><span class=\"line\"><span class=\"comment\">    * test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。</span></span><br><span class=\"line\"><span class=\"comment\">    * system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。  --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理\"><a class=\"header-anchor\" href=\"#编写Spout类读取日志文件中的内容-并把数据发送给下游Bolt类进行处理\"></a>编写Spout类读取日志文件中的内容, 并把数据发送给下游Bolt类进行处理</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\"> * Version: </span></span><br><span class=\"line\"><span class=\"comment\"> * Description: 读取外部文件,把一行一行的数据发送给下游的bolt</span></span><br><span class=\"line\"><span class=\"comment\"> *              类似于hadoop mapreduce的inputformat</span></span><br><span class=\"line\"><span class=\"comment\"> ***/</span></span><br><span class=\"line\"><span class=\"comment\">//BaseBasicSpout</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadFileSpout</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseRichSpout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SpoutOutputCollector spoutOutputCollector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BufferedReader bufferedReader;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化方法, 类似于这个类的构造器, 只被运行一次</span></span><br><span class=\"line\"><span class=\"comment\">     * spout组件读取原始数据为bolt提供数据</span></span><br><span class=\"line\"><span class=\"comment\">     * 一般用来打开数据链接, 打开网络连接</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 传入的是storm集群的配置文件和用户自定义的配置文件, 一般不用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> topologyContext 上下文对象, 一般不用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> spoutOutputCollector 数据输出的收集器,spout把数据传给此参数,由此参数传给storm框架</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//本地模式</span></span><br><span class=\"line\">            <span class=\"comment\">//this.bufferedReader = new BufferedReader(new FileReader(new File(\"D:\\\\wordcount.txt\")));</span></span><br><span class=\"line\">            <span class=\"comment\">//集群模式</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"keyword\">new</span> File(<span class=\"string\">\"//root//stormdata//wordcount.txt\"</span>)));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.spoutOutputCollector = spoutOutputCollector;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 下一个tuple, tuple是数据传送的基本单位</span></span><br><span class=\"line\"><span class=\"comment\">     * 不断地往下一个组件发送tuple消息</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里面是该spout组件的核心逻辑</span></span><br><span class=\"line\"><span class=\"comment\">     * 如从kafka消息队列中拿到数据</span></span><br><span class=\"line\"><span class=\"comment\">     * 后台有个while方法一直调用该方法, 每调用一次就发送一个tuple出去</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">nextTuple</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//一行一行的读取文件内容,并且一行一行的发送</span></span><br><span class=\"line\">            line = bufferedReader.readLine();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (line != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将信息封装成tuple，发送消息给下一个组件</span></span><br><span class=\"line\">\t\t        <span class=\"comment\">//this.collector.emit(new Value(this.words[index]));</span></span><br><span class=\"line\"></span><br><span class=\"line\">                spoutOutputCollector.emit(Arrays.asList(line));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//每发送一个消息，休眠500ms</span></span><br><span class=\"line\">       \t\t\t<span class=\"comment\">// Thread.sleep(500);</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Utils.sleep(500);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过字段声明发出的数据是什么,tuple中的数据的字段名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputFieldsDeclarer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class=\"line\">        outputFieldsDeclarer.declare(<span class=\"keyword\">new</span> Fields(<span class=\"string\">\"line\"</span>));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Bolt类对出入的内容进行单词切分\"><a class=\"header-anchor\" href=\"#编写Bolt类对出入的内容进行单词切分\"></a>编写Bolt类对出入的内容进行单词切分</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\"> * Description: 输入一行一行的数据</span></span><br><span class=\"line\"><span class=\"comment\"> *              对一行数据进行切割</span></span><br><span class=\"line\"><span class=\"comment\"> *              输出单词及单词出现的次数</span></span><br><span class=\"line\"><span class=\"comment\"> ***</span></span><br><span class=\"line\"><span class=\"comment\">//BaseBasicBolt</span></span><br><span class=\"line\"><span class=\"comment\">public class SplitBolt extends BaseRichBolt &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    private OutputCollector outputCollector;</span></span><br><span class=\"line\"><span class=\"comment\">    /**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化方法,只被运行一次</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 配置文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> topologyContext 上下文对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputCollector 数据收集器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.outputCollector = outputCollector;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 执行业务逻辑的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> tuple 获取的上游数据</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Tuple tuple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取上游句子(字段:\"line\"),从tuple中读取数据</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//获取nextTuple()方法emit()过来的数据\t</span></span><br><span class=\"line\">        String line = tuple.getStringByField(<span class=\"string\">\"line\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//对句子进行切割</span></span><br><span class=\"line\">        String[] words = line.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : words) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//需要发送单词和单词出现的次数,总共两个字段</span></span><br><span class=\"line\">            outputCollector.emit(Arrays.asList(word, <span class=\"string\">\"1\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明发送出去的数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputFieldsDeclarer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class=\"line\">        outputFieldsDeclarer.declare(<span class=\"keyword\">new</span> Fields(<span class=\"string\">\"word\"</span>, <span class=\"string\">\"num\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Bolt类对单词进行计数\"><a class=\"header-anchor\" href=\"#编写Bolt类对单词进行计数\"></a>编写Bolt类对单词进行计数</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">* Description: 负责统计每个单词出现的次数, 类似于hadoop mapreduce的reduce</span></span><br><span class=\"line\"><span class=\"comment\">*              输入单词及单词出现的次数</span></span><br><span class=\"line\"><span class=\"comment\">*              输出打印在控制台</span></span><br><span class=\"line\"><span class=\"comment\">***/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordCountBolt</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseRichBolt</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//定义一个map用于储存单词及其数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Integer&gt; wordCountMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 配置文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> topologyContext 上下文对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> outputCollector 数据收集器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//由于WordCountBolt是最后一个bolt所以不需要提取出OutputCollector</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Tuple tuple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取信息(单词, 数量)</span></span><br><span class=\"line\">        String word = tuple.getStringByField(<span class=\"string\">\"word\"</span>);</span><br><span class=\"line\">        String num = tuple.getStringByField(<span class=\"string\">\"num\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//使用map进行记录</span></span><br><span class=\"line\">        <span class=\"comment\">//开始计数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wordCountMap.containsKey(word))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果map里已经有这个单词,就把数量进行累加</span></span><br><span class=\"line\">            Integer integer = wordCountMap.get(word);</span><br><span class=\"line\">            wordCountMap.put(word, integer + Integer.parseInt(num));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果map里已经没有这个单词,就把单词和数量放入map</span></span><br><span class=\"line\">            wordCountMap.put(word, Integer.parseInt(num));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//打印</span></span><br><span class=\"line\">        System.out.println(wordCountMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//由于不向外发送数据,所以不用写</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写启动类对程序进行整合\"><a class=\"header-anchor\" href=\"#编写启动类对程序进行整合\"></a>编写启动类对程序进行整合</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***</span><br><span class=\"line\"> * Description: wordcount驱动类,用来提交任务</span><br><span class=\"line\"> ***/</span><br><span class=\"line\">public class WordCountTopology &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws InvalidTopologyException, AuthorizationException, AlreadyAliveException &#123;</span><br><span class=\"line\">        //通过TopologyBuilder 封装任务信息</span><br><span class=\"line\">        TopologyBuilder topologyBuilder = new TopologyBuilder();</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"comment\">//设置spout获取数据</span></span><br><span class=\"line\">        <span class=\"comment\">//SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint):参数:自定义id, spout对象, 并发数量 表示用多少个excutor来执行这个组件</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//setNumTasks(8)，设置该组件执行时并发的task数量，也就意味着1个excutor会执行8个task</span></span><br><span class=\"line\"></span><br><span class=\"line\">        topologyBuilder.setSpout(<span class=\"string\">\"readfilesspout\"</span>, <span class=\"keyword\">new</span> ReadFileSpout(), <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置splitbolt 对句子进行切割</span></span><br><span class=\"line\">        topologyBuilder.setBolt(<span class=\"string\">\"splitbolt\"</span>, <span class=\"keyword\">new</span> SplitBolt(), <span class=\"number\">4</span>).shuffleGrouping(<span class=\"string\">\"readfilesspout\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//设置wordcountbolt 对单词进行统计，将bolt设置到topology中，并且指定他接收的消息</span></span><br><span class=\"line\">        topologyBuilder.setBolt(<span class=\"string\">\"wordcountbolt\"</span>, <span class=\"keyword\">new</span> WordCountBolt(), <span class=\"number\">2</span>).shuffleGrouping(<span class=\"string\">\"splitbolt\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//准备一个配置文件，配置一些topology在集群中运行的参数</span></span><br><span class=\"line\">        Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//启动2个worker!</span></span><br><span class=\"line\">        config.setNumWorkers(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//任务提交有:本地模式 和 集群模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//本地模式</span></span><br><span class=\"line\">        <span class=\"comment\">//LocalCluster localCluster = new LocalCluster();</span></span><br><span class=\"line\">        <span class=\"comment\">//localCluster.submitTopology(\"wordcount\", config, topologyBuilder.createTopology());</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//集群模式,参数:Topology名字, 配置文件, Topology对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//用builder来创建topology</span></span><br><span class=\"line\">        StormSubmitter.submitTopology(<span class=\"string\">\"wordcount2\"</span>, config, topologyBuilder.createTopology());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行程序\"><a class=\"header-anchor\" href=\"#执行程序\"></a>执行程序</h3>\n<ol>\n<li>选择本地模式运行<br>\n直接运行驱动类的main方法即可, 统计后的结果会直接打印在控制台</li>\n<li>选择上传到集群进行执行<br>\n首先通过maven的package命名将程序打好jar包</li>\n</ol>\n<h4 id=\"注：-v2\"><a class=\"header-anchor\" href=\"#注：-v2\"></a>注：</h4>\n<p>在storm-core的依赖中加入:<scope>provided</scope><br>\n在上传到node2或node3上, 在指定路径下要确保存在日志文件</p>\n<h1 id=\"Storm-Distributed-RPC（DRPC）\"><a class=\"header-anchor\" href=\"#Storm-Distributed-RPC（DRPC）\"></a>Storm Distributed RPC（DRPC）</h1>\n<h2 id=\"分布式远程过程调用\"><a class=\"header-anchor\" href=\"#分布式远程过程调用\"></a>分布式远程过程调用</h2>\n<ul>\n<li>DRPC的主要作用就是利用Storm的<strong>实时计算</strong>能力来<strong>并行化</strong>CPU intensive的计算。</li>\n<li>对于每一次函数调用，Storm topology将函数的参数当成是输入流，并且将函数运行的结果作为输出流。</li>\n<li>DRPC其实不能算是storm本身的一个特性，它是通过组合storm的<strong>原语</strong>spout，bolt，topology而成的一种模式(pattern)。</li>\n<li>DRPC通过一个&quot;DRPC server&quot;来进行<strong>协调均衡</strong>。（Storm整合了DRPC server的一个实现）。</li>\n<li>DRPC server接受一个RPC请求，发送该请求给Storm topology，接受该Storm topology产生的结果，并把结果返回给客户端。</li>\n<li>对于客户端来说，一次DRPC调用就像是一次正常的RPC调用一样。</li>\n</ul>\n<h3 id=\"客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果：\"><a class=\"header-anchor\" href=\"#客户端使用DRPC来获取以-http-baidu-com-为参数的-reach-函数的返回结果：\"></a>客户端使用DRPC来获取以&quot;<a href=\"http://baidu.com\" target=\"_blank\" rel=\"noopener\">http://baidu.com</a>&quot;为参数的&quot;reach&quot;函数的返回结果：</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DRPCClient client = <span class=\"keyword\">new</span> DRPCClient(<span class=\"string\">\"drpc-host\"</span>, <span class=\"number\">3772</span>);</span><br><span class=\"line\">String result = client.execute(<span class=\"string\">\"reach\"</span>, <span class=\"string\">\"http://baidu.com\"</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/rPnjrFMNdD6e.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用\"><a class=\"header-anchor\" href=\"#1-客户端将要执行的函数名以及相应的参数发送给DRPC-server-。实现了这个函数的topology使用\"></a>1. 客户端将要执行的函数名以及相应的参数发送给DRPC server 。实现了这个函数的topology使用</h4>\n<h4 id=\"2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。\"><a class=\"header-anchor\" href=\"#2-DRPCSpout来接收从DRPC-server传来的函数的远程调用流，从而来执行该函数。\"></a>2. DRPCSpout来接收从DRPC server传来的函数的远程调用流，从而来执行该函数。</h4>\n<h4 id=\"3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。\"><a class=\"header-anchor\" href=\"#3-每一次函数的远程调用都被DRPC-server附上了一个唯一的id。\"></a>3. 每一次函数的远程调用都被DRPC server附上了一个唯一的id。</h4>\n<h4 id=\"4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。\"><a class=\"header-anchor\" href=\"#4-接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC-server并将结果及相应的函数远程调用id返回给DRPC-server。\"></a>4. 接下来topology计算结果，在最后topology中的bolt调用ReturnResults来连接DRPC server并将结果及相应的函数远程调用id返回给DRPC server。</h4>\n<h4 id=\"5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。\"><a class=\"header-anchor\" href=\"#5-接下来DRPC-server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。\"></a>5. 接下来DRPC server通过id来匹配相应的客户端，此时客户端还处于等待状态，匹配上后，疏通等待状态的客户端，并开始将结果发送给客户端。</h4>\n<h2 id=\"LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）\"><a class=\"header-anchor\" href=\"#LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）\"></a>LinearDRPCTopologyBuilder（线性DRPCTopologyBuilder）</h2>\n<h3 id=\"Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下\"><a class=\"header-anchor\" href=\"#Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化-这些步骤如下\"></a>Storm中有个LinearDRPCTopologyBuilder，实现了几乎所以DRPC步骤的自动化,这些步骤如下:</h3>\n<ol>\n<li>建立 spout</li>\n<li>将结果返回到DRPC server</li>\n<li>向bolts提供了在tuples集合上进行有限聚集的功能</li>\n</ol>\n<h4 id=\"创建LinearDRPCTopologyBuilder\"><a class=\"header-anchor\" href=\"#创建LinearDRPCTopologyBuilder\"></a>创建LinearDRPCTopologyBuilder</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExclaimBolt</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseBasicBolt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class=\"line\">        String input = tuple.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//简单的在元组的第二个字段的值后加了一个\"!\"</span></span><br><span class=\"line\">        collector.emit(<span class=\"keyword\">new</span> Values(tuple.getValue(<span class=\"number\">0</span>), input + <span class=\"string\">\"!\"</span>));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOutputFields</span><span class=\"params\">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class=\"line\">        declarer.declare(<span class=\"keyword\">new</span> Fields(<span class=\"string\">\"id\"</span>, <span class=\"string\">\"result\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//我们将DRPC函数名告诉给topology（本例函数名为exclamation）。\t</span></span><br><span class=\"line\">  <span class=\"comment\">//单个DRPC server可以负责处理多个函数，函数之间通过函数名来进行区分。</span></span><br><span class=\"line\">  <span class=\"comment\">//第一个bolt的输入是一个2元组，第一个字段为request id，第二个字段为request对应的参数。</span></span><br><span class=\"line\">    LinearDRPCTopologyBuilder builder = <span class=\"keyword\">new</span> LinearDRPCTopologyBuilder(<span class=\"string\">\"exclamation\"</span>);</span><br><span class=\"line\">    builder.addBolt(<span class=\"keyword\">new</span> ExclaimBolt(), <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建Local-mode-DRPC\"><a class=\"header-anchor\" href=\"#创建Local-mode-DRPC\"></a>创建Local mode DRPC</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先创建一个LocalDRPC对象。该对象将会在进程中模拟一个DRPC server。</span></span><br><span class=\"line\">LocalDRPC drpc = <span class=\"keyword\">new</span> LocalDRPC();</span><br><span class=\"line\"><span class=\"comment\">//然后创建LocalCluster来以本地模式来运行该topology。</span></span><br><span class=\"line\">LocalCluster cluster = <span class=\"keyword\">new</span> LocalCluster();</span><br><span class=\"line\"><span class=\"comment\">//LinearDRPCTopologyBuilder有单独的方法来创建本地的topologies以及远程的topologies。</span></span><br><span class=\"line\"><span class=\"comment\">//在本地模式中，LocalDRPC对象不会绑定到任何端口，所以，topology需要知道与其通信的对象</span></span><br><span class=\"line\"><span class=\"comment\">//（即将drpc作为参数传入：builder. createLocalTopology(drpc)）;</span></span><br><span class=\"line\">cluster.submitTopology(<span class=\"string\">\"drpc-demo\"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class=\"line\"><span class=\"comment\">//在建立了topology后，我们可以使用LocalDRPC的execute进行DRPC远程调用。</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Results for 'hello':\"</span> + drpc.execute(<span class=\"string\">\"exclamation\"</span>, <span class=\"string\">\"hello\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">cluster.shutdown();</span><br><span class=\"line\">drpc.shutdown();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Remote-mode-DRPC\"><a class=\"header-anchor\" href=\"#Remote-mode-DRPC\"></a>Remote mode DRPC</h4>\n<ol>\n<li>建立DRPC servers</li>\n<li>配置DRPC servers的位置</li>\n<li>向Storm cluster提交DRPC topologies,可用storm脚本建立DRPC server：</li>\n</ol>\n<h5 id=\"1-用storm脚本建立DRPC-server：\"><a class=\"header-anchor\" href=\"#1-用storm脚本建立DRPC-server：\"></a>1. 用storm脚本建立DRPC server：</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/storm drpc</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置\"><a class=\"header-anchor\" href=\"#2-配置DRPC-servers位置，通过storm-yaml来进行配置或者在topology程序中进行配置\"></a>2. 配置DRPC servers位置，通过storm.yaml来进行配置或者在topology程序中进行配置</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drpc.servers:</span><br><span class=\"line\">  - <span class=\"string\">\"drpc1.foo.com\"</span></span><br><span class=\"line\">  - <span class=\"string\">\"drpc2.foo.com\"</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"3-通过StormSubmitter建立DRPC-topologies\"><a class=\"header-anchor\" href=\"#3-通过StormSubmitter建立DRPC-topologies\"></a>3. 通过StormSubmitter建立DRPC topologies</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormSubmitter.submitTopology(<span class=\"string\">\"exclamation-drpc\"</span>, conf, builder.createRemoteTopology());</span><br></pre></td></tr></table></figure>\n<h2 id=\"Storm-DRPC深入\"><a class=\"header-anchor\" href=\"#Storm-DRPC深入\"></a>Storm DRPC深入</h2>\n<p>分布式dRPC（distributed RPC，DRPC）用于对Storm上大量的<strong>函数调用</strong>进行<strong>并行计算</strong>。对于每一次函数调用，Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。<br>\n可概括为：Storm进行计算，根据客户端提交的请求参数，而返回Storm计算的结果。</p>\n<h3 id=\"注：-v3\"><a class=\"header-anchor\" href=\"#注：-v3\"></a>注：</h3>\n<p>Storm是一个流式计算框架，数据源源不断的产生，收集，计算。（数据实时产生、实时传输、实时计算、实时展示）<br>\nStorm只负责数据的计算，不负责数据的存储<br>\n2013年前后，阿里巴巴基于storm框架，使用java语言开发了类似的流式计算框架佳作，Jstorm。2016年年底阿里巴巴将源码贡献给了Apache storm，两个项目开始合并，新的项目名字叫做storm2.x</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/RcA2os1xUqfW.png?imageslim\" alt=\"mark\"><br>\n<strong>其中:</strong><br>\nNimbus：负责资源分配和任务调度。<br>\nSupervisor：负责接受nimbus分配的任务，启动和停止属于自己管理的worker进程。<br>\nWorker：运行具体处理组件逻辑的进程。<br>\nTask：worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/nC49B0GwGz0o.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"注：-v4\"><a class=\"header-anchor\" href=\"#注：-v4\"></a>注：</h3>\n<p><strong>DataSource</strong>: 数据源<br>\n<strong>Spout</strong>：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。<br>\n<strong>Bolt</strong>：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。<br>\n<strong>Tuple</strong>：一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.<br>\n<strong>Stream</strong>：源源不断传递的tuple就组成了stream。<br>\n<strong>Topology</strong>：Storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。</p>\n<h3 id=\"分组策略\"><a class=\"header-anchor\" href=\"#分组策略\"></a>分组策略</h3>\n<ol>\n<li>随机分组(Shuffle grouping)：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。 跨服务器通信，浪费网络资源，尽量不适用</li>\n<li>字段分组(Fields grouping)：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。 跨服务器，除非有必要，才使用这种方式。</li>\n<li>LocalOrShuffle 分组。 优先将数据发送到本地的Task，节约网络通信的资源。</li>\n</ol>\n<h2 id=\"zookeeper安装和使用\"><a class=\"header-anchor\" href=\"#zookeeper安装和使用\"></a>zookeeper安装和使用</h2>\n<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>\nZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>\nZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p>\n<h3 id=\"zoo-sample-cfg文件配置\"><a class=\"header-anchor\" href=\"#zoo-sample-cfg文件配置\"></a>zoo_sample.cfg文件配置</h3>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The number of milliseconds of each tick</span></span><br><span class=\"line\"><span class=\"attr\">tickTime</span>=<span class=\"string\">2000</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that the initial </span></span><br><span class=\"line\"><span class=\"comment\"># synchronization phase can take</span></span><br><span class=\"line\"><span class=\"attr\">initLimit</span>=<span class=\"string\">10</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that can pass between </span></span><br><span class=\"line\"><span class=\"comment\"># sending a request and getting an acknowledgement</span></span><br><span class=\"line\"><span class=\"attr\">syncLimit</span>=<span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"comment\"># the directory where the snapshot is stored.</span></span><br><span class=\"line\"><span class=\"comment\"># do not use /tmp for storage, /tmp here is just </span></span><br><span class=\"line\"><span class=\"comment\"># example sakes.</span></span><br><span class=\"line\"><span class=\"attr\">dataDir</span>=<span class=\"string\">D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\data</span></span><br><span class=\"line\"><span class=\"attr\">dataLogDir</span>=<span class=\"string\">D:\\\\DevelopSoftware\\\\zookeeper\\\\zookeeper-3.4.14\\\\log</span></span><br><span class=\"line\"><span class=\"comment\"># the port at which the clients will connect</span></span><br><span class=\"line\"><span class=\"attr\">clientPort</span>=<span class=\"string\">2181</span></span><br><span class=\"line\"><span class=\"comment\"># the maximum number of client connections.</span></span><br><span class=\"line\"><span class=\"comment\"># increase this if you need to handle more clients</span></span><br><span class=\"line\"><span class=\"comment\">#maxClientCnxns=60</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Be sure to read the maintenance section of the </span></span><br><span class=\"line\"><span class=\"comment\"># administrator guide before turning on autopurge.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The number of snapshots to retain in dataDir</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.snapRetainCount=3</span></span><br><span class=\"line\"><span class=\"comment\"># Purge task interval in hours</span></span><br><span class=\"line\"><span class=\"comment\"># Set to \"0\" to disable auto purge feature</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参数解释\"><a class=\"header-anchor\" href=\"#参数解释\"></a>参数解释</h3>\n<ul>\n<li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li>\n<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒</li>\n<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒</li>\n<li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li>\n<li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li>\n</ul>\n<h3 id=\"异常\"><a class=\"header-anchor\" href=\"#异常\"></a>异常</h3>\n<p>Socket error occurred: localhost/0:0:0:0:0:0:0:1:2181: Connection refused: no further information<br>\n**解决办法：**将conf下的zoo_sample.cfg文件改成zoo.cfg文件。zkServer启动的时候要找到的zool.cfg而实际上在conf文件夹下面却是zoo_sample.cfg</p>\n<p>zookeeper启动成功<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/OVbwuEhqSMG5.png?imageslim\" alt=\"mark\"></p>\n<h2 id=\"Zookeeper伪分布式集群搭建\"><a class=\"header-anchor\" href=\"#Zookeeper伪分布式集群搭建\"></a>Zookeeper伪分布式集群搭建</h2>\n<ol>\n<li>将Zookeeper解压后，复制三份，分别起名为8001,8002,8003，放到同一个目录中如zk-cluster。</li>\n<li>创建zk-data文件夹，在zk-data中新建8001,8002,8003文件夹。在每个文件夹下都创建data,log文件夹。</li>\n<li>在上面创建的data目录下，创建myid文件，文件名就是myid，没有后缀，然后8001下的文件内容为1,8002下的myid内容为2，8003下的myid内容为3.</li>\n<li>修改zk-cluster中8001、8002、8003 下conf目录中的配置文件zoo.cfg ,下面是我8001下的zoo.cfg ,其中和8002，8003略作修改</li>\n</ol>\n<h3 id=\"zoo-cfg文件如下\"><a class=\"header-anchor\" href=\"#zoo-cfg文件如下\"></a>zoo.cfg文件如下</h3>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The number of milliseconds of each tick</span></span><br><span class=\"line\"><span class=\"comment\"># 服务器与客户端之间交互的基本时间单元（ms）</span></span><br><span class=\"line\"><span class=\"attr\">tickTime</span>=<span class=\"string\">2000</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that the initial </span></span><br><span class=\"line\"><span class=\"comment\"># synchronization phase can take</span></span><br><span class=\"line\"><span class=\"comment\"># zookeeper所能接受的客户端数量</span></span><br><span class=\"line\"><span class=\"attr\">initLimit</span>=<span class=\"string\">10</span></span><br><span class=\"line\"><span class=\"comment\"># The number of ticks that can pass between </span></span><br><span class=\"line\"><span class=\"comment\"># sending a request and getting an acknowledgement</span></span><br><span class=\"line\"><span class=\"comment\"># 服务器与客户端之间请求和应答的时间间隔</span></span><br><span class=\"line\"><span class=\"attr\">syncLimit</span>=<span class=\"string\">5</span></span><br><span class=\"line\"><span class=\"comment\"># the directory where the snapshot is stored.</span></span><br><span class=\"line\"><span class=\"comment\"># do not use /tmp for storage, /tmp here is just </span></span><br><span class=\"line\"><span class=\"comment\"># example sakes.</span></span><br><span class=\"line\"><span class=\"comment\"># 保存zookeeper数据，日志路径</span></span><br><span class=\"line\"><span class=\"attr\">dataDir</span>=<span class=\"string\">D:/DevelopSoftware/zookeeper/zk-data/8001/data</span></span><br><span class=\"line\"><span class=\"attr\">dataLogDir</span>=<span class=\"string\">D:/DevelopSoftware/zookeeper/zk-data/8001/log</span></span><br><span class=\"line\"><span class=\"comment\"># the port at which the clients will connect</span></span><br><span class=\"line\"><span class=\"comment\"># 这是客户端链接的端口号</span></span><br><span class=\"line\"><span class=\"attr\">clientPort</span>=<span class=\"string\">2181\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\"># the maximum number of client connections.</span></span><br><span class=\"line\"><span class=\"comment\"># increase this if you need to handle more clients</span></span><br><span class=\"line\"><span class=\"comment\">#maxClientCnxns=60</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Be sure to read the maintenance section of the </span></span><br><span class=\"line\"><span class=\"comment\"># administrator guide before turning on autopurge.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The number of snapshots to retain in dataDir</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.snapRetainCount=3</span></span><br><span class=\"line\"><span class=\"comment\"># Purge task interval in hours</span></span><br><span class=\"line\"><span class=\"comment\"># Set to \"0\" to disable auto purge feature</span></span><br><span class=\"line\"><span class=\"comment\">#autopurge.purgeInterval=1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Cluster Zookeeper Server Address 下面配置不需要修改 要注意的就是，下面server.number (number是1、2、3)分别对应myid中的内容，zookeeper也是通过server后面的数字以及dataDir下的myid内容来判断zookeeper集群的关系的（哪个server对应哪个地址），然后后面两个端口号，一个是跟服务器发送链接的端口，另一个是接受服务器链接的端口</span></span><br><span class=\"line\"><span class=\"comment\"># server.A=B:C:D  其中A是一个数字，代表这是第几号服务器；B是服务器的IP地址；C表示服务器与群集中的“领导者”交换信息的端口；当领导者失效后，D表示用来执行选举时服务器相互通信的端口。</span></span><br><span class=\"line\"><span class=\"comment\"># 客户端与zookeeper相互交互的端口</span></span><br><span class=\"line\"><span class=\"meta\">server.1</span>=<span class=\"string\">127.0.0.1:8001:9001</span></span><br><span class=\"line\"><span class=\"meta\">server.2</span>=<span class=\"string\">127.0.0.1:8002:9002</span></span><br><span class=\"line\"><span class=\"meta\">server.3</span>=<span class=\"string\">127.0.0.1:8003:9003</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"报错\"><a class=\"header-anchor\" href=\"#报错\"></a>报错</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [myid:<span class=\"number\">1</span>] - WARN  [WorkerSender[myid=<span class=\"number\">1</span>]:QuorumCnxManager@<span class=\"number\">584</span>] - Cannot open channel to <span class=\"number\">3</span> at election address /<span class=\"number\">127.0</span>.0.1:<span class=\"number\">9003</span></span><br><span class=\"line\">java.net.ConnectException: Connection refused: connect</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)</span><br><span class=\"line\">        at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:<span class=\"number\">85</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:<span class=\"number\">350</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:<span class=\"number\">206</span>)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:<span class=\"number\">188</span>)</span><br><span class=\"line\">        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:<span class=\"number\">172</span>)</span><br><span class=\"line\">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:<span class=\"number\">392</span>)</span><br><span class=\"line\">        at java.net.Socket.connect(Socket.java:<span class=\"number\">589</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.connectOne(QuorumCnxManager.java:<span class=\"number\">558</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.QuorumCnxManager.toSend(QuorumCnxManager.java:<span class=\"number\">534</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.process(FastLeaderElection.java:<span class=\"number\">454</span>)</span><br><span class=\"line\">        at org.apache.zookeeper.server.quorum.FastLeaderElection$Messenger$WorkerSender.run(FastLeaderElection.java:<span class=\"number\">435</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"报错解决办法\"><a class=\"header-anchor\" href=\"#报错解决办法\"></a>报错解决办法</h3>\n<p>产生上述Waring信息是因为zookeeper服务的每个实例都拥有全局的配置信息，他们在启动的时候需要随时随地的进行leader选举，此时server1就需要和其他两个zookeeper实例进行通信，但是，另外两个zookeeper实例还没有启动起来，因此将会产生上述所示的提示信息。当我们用同样的方式启动server2和server3后就不会再有这样的警告信息了。</p>\n<h2 id=\"dubbo的引入\"><a class=\"header-anchor\" href=\"#dubbo的引入\"></a>dubbo的引入</h2>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/wjl7jTS7zaLL.png?imageslim\" alt=\"mark\"></p>\n<ul>\n<li>\n<p>单一应用架构<br>\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>\n此时，用于简化增删改查工作量的  数据访问框架(ORM)  是关键。</p>\n</li>\n<li>\n<p>垂直应用架构<br>\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>\n此时，用于加速前端页面开发的  Web框架(MVC)  是关键。</p>\n</li>\n<li>\n<p>分布式服务架构<br>\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>\n此时，用于提高业务复用及整合的  分布式服务框架(RPC)  是关键。</p>\n</li>\n<li>\n<p>流动计算架构<br>\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率<br>\n此时，用于提高机器利用率的  资源调度和治理中心(SOA)  是关键。</p>\n</li>\n</ul>\n<p>在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p>\n<ol>\n<li>\n<p>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。<br>\n此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</p>\n</li>\n<li>\n<p>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。<br>\n这时，需要自动画出应用间的依赖关系图，以理清理关系。</p>\n</li>\n<li>\n<p>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？<br>\n为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。<br>\n其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>\n</li>\n</ol>\n<h3 id=\"Dubbo的工作原理\"><a class=\"header-anchor\" href=\"#Dubbo的工作原理\"></a>Dubbo的工作原理</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/9BmbGSdmqAIw.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"节点角色说明：\"><a class=\"header-anchor\" href=\"#节点角色说明：\"></a>节点角色说明：</h3>\n<ul>\n<li>Provider:  暴露服务的服务提供方。</li>\n<li>Consumer:  调用远程服务的服务消费方。</li>\n<li>Registry:  服务注册与发现的注册中心。</li>\n<li>Monitor:  统计服务的调用次调和调用时间的监控中心。</li>\n<li>Container:  服务运行容器。</li>\n</ul>\n<h3 id=\"调用关系说明：\"><a class=\"header-anchor\" href=\"#调用关系说明：\"></a>调用关系说明：</h3>\n<ul>\n<li>服务容器负责启动，加载，运行服务提供者。</li>\n<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>\n</ul>\n<h2 id=\"Dubbo-admin管理平台的安装\"><a class=\"header-anchor\" href=\"#Dubbo-admin管理平台的安装\"></a>Dubbo-admin管理平台的安装</h2>\n<h3 id=\"dubbo-admin-本地编译打包\"><a class=\"header-anchor\" href=\"#dubbo-admin-本地编译打包\"></a>dubbo-admin 本地编译打包</h3>\n<p><a href=\"https://github.com/alibaba/dubbo/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/dubbo/releases</a><br>\n<a href=\"https://github.com/apache/incubator-dubbo/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo/releases</a><br>\n解压后，根目录里不存在dubbo-admin，无法编译打包，发现dubbo-admin迁移到新地址<br>\n<a href=\"https://github.com/apache/incubator-dubbo-ops\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo-ops</a></p>\n<h3 id=\"克隆项目\"><a class=\"header-anchor\" href=\"#克隆项目\"></a>克隆项目</h3>\n<p>apache 下的dubbo-admin git仓库：<br>\n<a href=\"https://github.com/apache/incubator-dubbo-ops\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo-ops</a><br>\n先把这个项目用git克隆到本地中<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/K3cL9oIMDyUc.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"application-properties配置\"><a class=\"header-anchor\" href=\"#application-properties配置\"></a>application.properties配置</h4>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/OBg6vOx9Hm2v.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"application-test-properties配置\"><a class=\"header-anchor\" href=\"#application-test-properties配置\"></a>application-test.properties配置</h4>\n<p><img src=\"https://ws1.sinaimg.cn/large/005Vjva3gy1g3a8nhcmhnj30tw04ujrj.jpg\" alt></p>\n<h4 id=\"tomcat配置启动项\"><a class=\"header-anchor\" href=\"#tomcat配置启动项\"></a>tomcat配置启动项</h4>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/jTIptyM29eyc.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"配置部署war包\"><a class=\"header-anchor\" href=\"#配置部署war包\"></a>配置部署war包</h4>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/pMWYodys0jHX.png?imageslim\" alt=\"mark\"><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/815r6xyBFzgC.png?imageslim\" alt=\"mark\"></p>\n<h4 id=\"说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。\"><a class=\"header-anchor\" href=\"#说明：可以发现最新版本的-dubbo-admin-为springboot项目，可以直接打包成jar，使用java-jar-xxx-jar-运行。\"></a>说明：可以发现最新版本的 dubbo-admin 为springboot项目，可以直接打包成jar，使用java -jar xxx.jar 运行。</h4>\n<h4 id=\"Production-Setup\"><a class=\"header-anchor\" href=\"#Production-Setup\"></a>Production Setup</h4>\n<ol>\n<li>\n<p>Clone source code on develop branch git clone <a href=\"https://github.com/apache/incubator-dubbo-admin.git\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo-admin.git</a></p>\n</li>\n<li>\n<p>Specify registry address in dubbo-admin-server/src/main/resources/application.properties</p>\n</li>\n<li>\n<p>Build<br>\nmvn clean package<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/QW4o2Lu212cH.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>Start<br>\nmvn --projects dubbo-admin-server spring-boot:run<br>\n<strong>启动Zookeeper集群</strong><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/6S0qSXjElGrA.png?imageslim\" alt=\"mark\"><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/KuguVid47fPC.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>Visit <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a><br>\n<img src=\"https://img.jinguo.tech/blog/20200116/LvOOUrd9THDG.png?imageslim\" alt=\"mark\"></p>\n</li>\n</ol>\n<h3 id=\"报错1\"><a class=\"header-anchor\" href=\"#报错1\"></a>报错1</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/Y5eggYkh3Rcn.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"解决办法\"><a class=\"header-anchor\" href=\"#解决办法\"></a>解决办法</h3>\n<p>如果SpringBoot在子模块，直接main启动子模块会报错。<br>\n解决办法就是在IDEA MAVEN Projects-&gt;dubbo-admin-server-&gt;Plugins-&gt;spring-boot-&gt;spring-boot:run-&gt;run maven build<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/3Ks7eNPV4RNd.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"报错2\"><a class=\"header-anchor\" href=\"#报错2\"></a>报错2</h3>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/rbB1U2e6QnzT.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"解决办法-v2\"><a class=\"header-anchor\" href=\"#解决办法-v2\"></a>解决办法</h3>\n<p>taskkill /pid 8876 /f</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/C9aKSFeYcYUi.png?imageslim\" alt=\"mark\"></p>\n<h2 id=\"zookeeper与dubbo关系\"><a class=\"header-anchor\" href=\"#zookeeper与dubbo关系\"></a>zookeeper与dubbo关系</h2>\n<p>dubbo是动物园，动物园里有什么动物，有动物园自己说了算，zookeeper只是登记了园里有什么动物可供参观，游客可以参观那个动物，参观人数太多，ZK如何分流等，动物园可以不用ZK做这个工作（能提供这个功能的有很多），可以用别的做这个注册、选举、分流、负载均衡的管理工作，只是大家都用ZK；dubbo中的注册中心用了zookeeper而已，也可以用别的，dubbo有注册中心（使用了ZK）、服务提供者、消费者、运行容器，监视器；</p>\n<h2 id=\"Netty在Dubbo中的应用\"><a class=\"header-anchor\" href=\"#Netty在Dubbo中的应用\"></a>Netty在Dubbo中的应用</h2>\n<p><strong>Dubbo 底层使用的是 Netty 作为网络通信</strong></p>\n<ol>\n<li>dubbo的Consumer消费者如何使用Netty</li>\n</ol>\n<h3 id=\"调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。\"><a class=\"header-anchor\" href=\"#调用-Spring-容器的-getBean-方法-dubbo-扩展了-FactoryBean，所以，会调用-getObject-方法，该方法会创建代理对象。\"></a>调用 Spring 容器的 getBean 方法, dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get remote service proxy</span></span><br><span class=\"line\">DemoService demoService = (DemoService) context.getBean(<span class=\"string\">\"demoService\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存\"><a class=\"header-anchor\" href=\"#调用-DubboProtocol-实例的-getClients（URL-url）-方法，当这个给定的-URL-的-client-没有初始化则创建，然后放入缓存\"></a>调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeClient <span class=\"title\">getSharedClient</span><span class=\"params\">(URL url)</span></span>&#123;</span><br><span class=\"line\">\tString key=url.getAddress();</span><br><span class=\"line\">\tReferenceCountExchangeClient client=referenceClientMap.get(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(client!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!=client.isClosed())&#123;</span><br><span class=\"line\">\t\t\tclient.incrementAndGetCount();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> client;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\treferenceClientMap.remove(key);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">synchronized</span>(key.intern())&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这个initClient()方法是创建Netty的client的</span></span><br><span class=\"line\">\t\tExchangeClient exchangeClient=initClient(url);</span><br><span class=\"line\">\t\tclient=<span class=\"keyword\">new</span> ReferenceCountExchangeClient(exchangeClient,ghostClientMap);</span><br><span class=\"line\">\t\treferenceClientMap.put(key,client);</span><br><span class=\"line\">\t\tghostClientMap.remove(key);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> client;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。\"><a class=\"header-anchor\" href=\"#最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。\"></a>最终调用的就是抽象父类AbstractClient的构造方法，构造方法中包含了创建Socket客户端，连接客户端等行为。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbstractClient</span><span class=\"params\">(URL url, ChannelHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    doOpen();</span><br><span class=\"line\">    connect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"doOpent-方法用来创建-Netty-的-bootstrap-：\"><a class=\"header-anchor\" href=\"#doOpent-方法用来创建-Netty-的-bootstrap-：\"></a>doOpent 方法用来创建 Netty 的 bootstrap ：</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    NettyHelper.setNettyLoggerFactory();</span><br><span class=\"line\">    bootstrap = <span class=\"keyword\">new</span> ClientBootstrap(channelFactory);</span><br><span class=\"line\">    bootstrap.setOption(<span class=\"string\">\"keepAlive\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    bootstrap.setOption(<span class=\"string\">\"tcpNoDelay\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    bootstrap.setOption(<span class=\"string\">\"connectTimeoutMillis\"</span>, getTimeout());</span><br><span class=\"line\">    <span class=\"keyword\">final</span> NettyHandler nettyHandler = <span class=\"keyword\">new</span> NettyHandler(getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    bootstrap.setPipelineFactory(<span class=\"keyword\">new</span> ChannelPipelineFactory() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ChannelPipeline <span class=\"title\">getPipeline</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            NettyCodecAdapter adapter = <span class=\"keyword\">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"decoder\"</span>, adapter.getDecoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"encoder\"</span>, adapter.getEncoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"handler\"</span>, nettyHandler);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipeline;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"connect-方法用来连接提供者：\"><a class=\"header-anchor\" href=\"#connect-方法用来连接提供者：\"></a>connect 方法用来连接提供者：</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"comment\">//调用了 bootstrap 的 connect 方法,这里使用的是 jboss 的 netty3,当连接成功后，注册写事件，准备开始向提供者传递数据。 </span></span><br><span class=\"line\">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class=\"line\">        Channel newChannel = future.getChannel();</span><br><span class=\"line\">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。\"><a class=\"header-anchor\" href=\"#main-方法最终会调用-HeaderExchangeChannel-的-request-方法，通过-channel-进行请求。\"></a>main 方法最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request, <span class=\"keyword\">int</span> timeout)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    Request req = <span class=\"keyword\">new</span> Request();</span><br><span class=\"line\">    req.setVersion(<span class=\"string\">\"2.0.0\"</span>);</span><br><span class=\"line\">    req.setTwoWay(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    req.setData(request);</span><br><span class=\"line\">    DefaultFuture future = <span class=\"keyword\">new</span> DefaultFuture(channel, req, timeout);</span><br><span class=\"line\">\t<span class=\"comment\">//send 方法中最后调用 jboss Netty 中继承了 NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。  </span></span><br><span class=\"line\">    channel.send(req);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dubbo-的-Provider-提供者如何使用-Netty\"><a class=\"header-anchor\" href=\"#dubbo-的-Provider-提供者如何使用-Netty\"></a>dubbo 的 Provider 提供者如何使用 Netty</h2>\n<p>Provider 作为被访问方，是一个 Server 模式的 Socket。 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了  InitializingBean，ApplicationContextAware，ApplicationListener。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。  然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。</p>\n<h3 id=\"NettyServer-对象的构造方法同样是-doOpen-方法。\"><a class=\"header-anchor\" href=\"#NettyServer-对象的构造方法同样是-doOpen-方法。\"></a>NettyServer 对象的构造方法同样是 doOpen 方法。</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    NettyHelper.setNettyLoggerFactory();</span><br><span class=\"line\">\t<span class=\"comment\">//boss 线程，worker 线程，和 ServerBootstrap</span></span><br><span class=\"line\">    ExecutorService boss = Executors.newCachedThreadPool(<span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">\"NettyServerBoss\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    ExecutorService worker = Executors.newCachedThreadPool(<span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">\"NettyServerWorker\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    ChannelFactory channelFactory = <span class=\"keyword\">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class=\"line\">    bootstrap = <span class=\"keyword\">new</span> ServerBootstrap(channelFactory);</span><br><span class=\"line\">\t<span class=\"comment\">//在添加了编解码 handler 之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> NettyHandler nettyHandler = <span class=\"keyword\">new</span> NettyHandler(getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    channels = nettyHandler.getChannels();</span><br><span class=\"line\">    bootstrap.setPipelineFactory(<span class=\"keyword\">new</span> ChannelPipelineFactory() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ChannelPipeline <span class=\"title\">getPipeline</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            NettyCodecAdapter adapter = <span class=\"keyword\">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"decoder\"</span>, adapter.getDecoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"encoder\"</span>, adapter.getEncoder());</span><br><span class=\"line\">            pipeline.addLast(<span class=\"string\">\"handler\"</span>, nettyHandler);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipeline;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    channel = bootstrap.bind(getBindAddress());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Netty在Dubbo中的应用总结\"><a class=\"header-anchor\" href=\"#Netty在Dubbo中的应用总结\"></a>Netty在Dubbo中的应用总结</h3>\n<p>dubbo中消费者使用 NettyClient，提供者使用 NettyServer，Provider 启动的时候，会开启端口监听。Client 在 Spring getBean 的时候，会创建 Client。当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。</p>\n<h2 id=\"Apache-Storm分布式消息系统\"><a class=\"header-anchor\" href=\"#Apache-Storm分布式消息系统\"></a>Apache Storm分布式消息系统</h2>\n<p>Apache Storm处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。Spout将从消息系统读取数据，并将其转换为元组并输入到Apache Storm中。Apache Storm在内部使用其自己的分布式消息传递系统，用于其nimbus和主管之间的通信。</p>\n<h3 id=\"什么是分布式消息系统？\"><a class=\"header-anchor\" href=\"#什么是分布式消息系统？\"></a>什么是分布式消息系统？</h3>\n<p>分布式消息传递基于可靠消息队列的概念。消息在客户端应用程序和消息系统之间异步排队。分布式消息传递系统提供可靠性，可扩展性和持久性的好处。<br>\n大多数消息模式遵循发布 - 订阅模型（简称发布 - 订阅），其中消息的发送者称为发布者，而想要接收消息的那些被称为订阅者。<br>\n一旦消息已经被发​​送者发布，订阅者可以在过滤选项的帮助下接收所选择的消息。通常我们有两种类型的过滤，一种是基于主题的过滤，另一种是基于内容的过滤。<br>\n需要注意的是，pub-sub模型只能通过消息进行通信。它是一个非常松散耦合的架构;甚至发件人不知道他们的订阅者是谁。许多消息模式使消息代理能够交换发布消息以便由许多订户及时访问。</p>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/lG6PiOTlO76X.png?imageslim\" alt=\"mark\"></p>\n<p>下表描述了一些流行的高吞吐量消息传递系统 -<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/LFSn4gj0zFXj.png?imageslim\" alt=\"mark\"><br>\nThrift在Facebook上构建，用于跨语言服务开发和远程过程调用（RPC）。后来，它成为一个开源的Apache项目。Apache Thrift是一种接口定义语言，允许以容易的方式在定义的数据类型之上定义新的数据类型和服务实现。<br>\nApache Thrift也是一个支持嵌入式系统，移动应用程序，Web应用程序和许多其他编程语言的通信框架。与Apache Thrift相关的一些关键功能是它的模块化，灵活性和高性能。此外，它可以在分布式应用程序中执行流式处理，消息传递和RPC。<br>\nStorm广泛使用Thrift协议进行内部通信和数据定义。Storm拓扑只是Thrift Structs。在Apache Storm中运行拓扑的Storm Nimbus是一个Thrift服务。</p>\n<h2 id=\"Storm工作原理\"><a class=\"header-anchor\" href=\"#Storm工作原理\"></a>Storm工作原理</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/79gVc35j1D9V.png?imageslim\" alt=\"mark\"></p>\n<h3 id=\"Storm与传统关系型数据库\"><a class=\"header-anchor\" href=\"#Storm与传统关系型数据库\"></a>Storm与传统关系型数据库</h3>\n<p>传统关系型数据库是先存后计算，而storm则是先算后存，甚至不存<br>\n传统关系型数据库很难部署实时计算，只能部署定时任务统计分析窗口数据<br>\n关系型数据库重视事务，并发控制，相对来说Storm比较简陋<br>\nStorm与Hadoop，Spark等是流行的大数据方案<br>\n与Storm关系密切的语言：核心代码用clojure书写，实用程序用python开发，使用java开发拓扑</p>\n<ol>\n<li>\n<p>topology<br>\nStorm集群中有两种组件节点，一种是<strong>控制节点</strong>(Nimbus节点)，另一种是<strong>工作节点</strong>(Supervisor节点)。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。所有Topology任务的 提交必须在Storm客户端节点上进行(需要配置 storm.yaml文件)，由Nimbus节点分配给其他Supervisor节点进行处理。 Nimbus负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。Nimbus节点首先将提交的Topology进行分片，分成一个个的Task，并将Task和Supervisor相关的信息提交到 zookeeper集群上，Supervisor会去zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理。<br>\n和同样是计算框架的MapReduce相比，MapReduce集群上运行的是Job，而Storm集群上运行的是Topology。但是Job在运行结束之后会自行结束，Topology却只能被手动的kill掉，否则会一直运行下去<br>\n数据存储之后的展现，也是需要自己处理的，storm UI 只提供对topology的监控和统计。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/giIigvaTGzfK.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>zookeeper集群<br>\nstorm使用zookeeper来协调整个集群， 但是要注意的是storm并不用zookeeper来传递消息。所以zookeeper上的负载是非常低的，单个节点的zookeeper在大多数情况下 都已经足够了， 但是如果你要部署大一点的storm集群， 那么你需要的zookeeper也要大一点。<br>\n部署zookeeper有些需要注意的地方：<br>\n①对zookeeper做好监控非常重要， zookeeper是fail-fast的系统，只要出现什么错误就会退出， 所以实际场景中要监控<br>\n②实际场景中要配置一个cron job来压缩zookeeper的数据和业务日志。zookeeper自己是不会去压缩这些的，所以你如果不设置一个cron job, 磁盘会很快不够用</p>\n</li>\n<li>\n<p>Component<br>\nStorm中，Spout和Bolt都是Component。所以，Storm定义了一个名叫IComponent的总接口<br>\n全家谱如下：绿色部分是我们最常用、比较简单的部分。红色部分是与事务相关的。<br>\n<img src=\"https://img.jinguo.tech/blog/20200116/3ydBPi1GBWs0.png?imageslim\" alt=\"mark\"></p>\n</li>\n<li>\n<p>Spout<br>\nSpout是Stream的消息产生源， Spout组件的实现可以通过继承BaseRichSpout类或者其他Spout类来完成，也可以通过实现IRichSpout接口来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISpout</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">nextTuple</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ack</span><span class=\"params\">(Object msgId)</span></span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fail</span><span class=\"params\">(Object msgId)</span></span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>①open()方法 – 初始化方法<br>\nclose() – 在该spout将要关闭时调用。但是不保证其一定被调用，因为在集群中supervisor节点，可以使用kill -9来杀死worker进程。只有当Storm是在本地模式下运行，如果是发送停止命令，可以保证close的执行<br>\n②ack(Object msgId) – 成功处理tuple时回调的方法，通常情况下，此方法的实现是将消息队列中的消息移除，防止消息重放<br>\n③fail(Object msgId) – 处理tuple失败时回调的方法，通常情况下，此方法的实现是将消息放回消息队列中然后在稍后时间里重放<br>\n④nextTuple() – 这是Spout类中最重要的一个方法。发射一个Tuple到Topology都是通过这个方法来实现的。调用此方法时，storm向spout发出请求，让spout发出元组（tuple）到输出器（ouput collector）。这种方法应该是非阻塞的，所以spout如果没有元组发出，这个方法应该返回。nextTuple、ack 和fail 都在spout任务的同一个线程中被循环调用。 当没有元组的发射时，应该让nextTuple睡眠一个很短的时间（如一毫秒），以免浪费太多的CPU。继承了BaseRichSpout后，不用实现close、 activate、 deactivate、 ack、 fail 和 getComponentConfiguration 方法，只关心最基本核心的部分。   通常情况下（Shell和事务型的除外），实现一个Spout，可以直接实现接口IRichSpout，如果不想写多余的代码，可以直接继承BaseRichSpout</p>\n</li>\n<li>\n<p>Bolt<br>\nBolt类接收由Spout或者其他上游Bolt类发来的Tuple，对其进行处理。Bolt组件的实现可以通过继承BasicRichBolt类或者IRichBolt接口等来完成<br>\nprepare方法 – 此方法和Spout中的open方法类似，在集群中一个worker中的task初始化时调用。 它提供了bolt执行的环境<br>\ndeclareOutputFields方法 – 用于声明当前Bolt发送的Tuple中包含的字段(field)，和Spout中类似<br>\ncleanup方法 – 同ISpout的close方法，在关闭前调用。同样不保证其一定执行。<br>\nexecute方法 – 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送是通过emit方法来完成的。execute接受一个tuple进行处理，并用prepare方法传入的  OutputCollector的ack方法（表示成功）或fail（表示失败）来反馈处理结果。<br>\nStorm提供了IBasicBolt接口，其目的就是实现该接口的Bolt不用在代码中提供反馈结果了，Storm内部会自动反馈成功。如果你确实要反馈失败，可以抛出FailedException<br>\n通常情况下，实现一个Bolt，可以实现IRichBolt接口或继承BaseRichBolt，如果不想自己处理结果反馈，可以实现 IBasicBolt接口或继承BaseBasicBolt，它实际上相当于自动实现了collector.emit.ack(inputTuple)</p>\n</li>\n<li>\n<p>Topology运行方式<br>\n在开始创建项目之前，了解Storm的操作模式(operation modes)是很重要的。 Storm有两种运行方式</p>\n</li>\n</ol>\n<h3 id=\"本地运行的提交方式\"><a class=\"header-anchor\" href=\"#本地运行的提交方式\"></a>本地运行的提交方式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalCluster cluster = <span class=\"keyword\">new</span> LocalCluster(); </span><br><span class=\"line\">cluster.submitTopology(TOPOLOGY_NAME, conf, builder.createTopology()); </span><br><span class=\"line\">Thread.sleep(<span class=\"number\">2000</span>); </span><br><span class=\"line\">cluster.shutdown();</span><br></pre></td></tr></table></figure>\n<h3 id=\"分布式提交方式\"><a class=\"header-anchor\" href=\"#分布式提交方式\"></a>分布式提交方式</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormSubmitter.submitTopology（TOPOLOGY_NAME, conf, builder.createTopology());</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，在Storm代码编写完成之后，需要打包成jar包放到Nimbus中运行，打包的时候，不需要把依赖的jar都打迚去，否则如果把依赖的storm.jar包打进去的话，运行时会出现重复的配置文件错误导致Topology无法运行。因为Topology运行之前，会加载本地的 storm.yaml 配置文件。</p>\n<h3 id=\"运行的命令如下\"><a class=\"header-anchor\" href=\"#运行的命令如下\"></a>运行的命令如下###</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm jar StormTopology.jar mainclass [args]</span><br></pre></td></tr></table></figure>\n<h2 id=\"storm守护进程的命令\"><a class=\"header-anchor\" href=\"#storm守护进程的命令\"></a>storm守护进程的命令</h2>\n<p>Nimbus: storm nimbus 启动nimbus守护进程<br>\nSupervisor: storm supervisor 启动supervisor守护迚程<br>\nUI：storm ui 这将启动stormUI的守护进程,为监测storm集群提供一个基于web的用户界面。<br>\nDRPC: storm drpc 启动DRPC的守护进程</p>\n<h2 id=\"storm管理命令\"><a class=\"header-anchor\" href=\"#storm管理命令\"></a>storm管理命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAR：storm jar topology_jar topology_class [arguments...]</span><br></pre></td></tr></table></figure>\n<p>jar命令是用于提交一个集群拓扑.它运行指定参数的topology_class中的main()方法，上传topology_jar到nimbus，由nimbus发布到集群中。一旦提交，storm将激活拓扑并开始处理topology_class 中的main()方法，main()方法负责调用StormSubmitter.submitTopology()方法，并提供一个唯一的拓扑(集群)的名。如果一个拥有该名称的拓扑已经存在于集群中，jar命令将会失败。常见的做法是在使用命令行参数来指定拓扑名称，以便拓扑在提交的时候被命名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KILL：storm kill topology_name [-w wait_time]</span><br></pre></td></tr></table></figure>\n<p>杀死一个拓扑，可以使用kill命令。它会以一种安全的方式销毁一个拓扑，首先停用拓扑，在等待拓扑消息的时间段内允许拓扑完成当前的数据流。执行kill命令时可以通过-w [等待秒数]指定拓扑停用以后的等待时间。也可以在Storm UI 界面上实现同样的功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deactivate：storm deactivate topology_name</span><br></pre></td></tr></table></figure>\n<p>停用拓扑时，所有已分发的元组都会得到处理，spouts的nextTuple方法将不会被调用。也可以在Storm UI 界面上实现同样的功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Activate：storm activate topology_name</span><br></pre></td></tr></table></figure>\n<p>启动一个停用的拓扑。也可以在Storm UI 界面上实现同样的功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rebalance：storm rebalance topology_name [-w wait_time] [-n worker_count] [-e component_name=executer_count]...</span><br></pre></td></tr></table></figure>\n<p>rebalance使你重新分配集群任务。这是个很强大的命令。比如，你向一个运行中的集群增加了节点。rebalance命令将会停用拓扑，然后在相应超时时间之后重分配worker，并重启拓扑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storm rebalance wordcount-topology -w 15 -n 5 -e sentence-spout=4 -e split-bolt=8</span><br></pre></td></tr></table></figure>\n<p>还有其他管理命令，如：Remoteconfvalue、REPL、Classpath等</p>\n<h2 id=\"Storm与Hadoop的对比\"><a class=\"header-anchor\" href=\"#Storm与Hadoop的对比\"></a>Storm与Hadoop的对比</h2>\n<p><img src=\"https://img.jinguo.tech/blog/20200116/inthPTtTa26V.png?imageslim\" alt=\"mark\"></p>\n<h2 id=\"DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下：\"><a class=\"header-anchor\" href=\"#DRPC通过DRPC-Server来实现，DRPC-Server的整体工作过程如下：\"></a>DRPC通过DRPC Server来实现，DRPC Server的整体工作过程如下：</h2>\n<p>引入DRPC主要是利用storm的实时计算能力来并行化CPU密集性的计算任务。</p>\n<ol>\n<li>接收到一个RPC调用请求；</li>\n<li>发送请求到Storm上的<strong>拓扑</strong>；</li>\n<li>从Storm上接收计算结果；</li>\n<li>将计算结果返回给客户端。</li>\n</ol>\n<h2 id=\"附录\"><a class=\"header-anchor\" href=\"#附录\"></a>附录</h2>\n<h3 id=\"maven更新镜像源\"><a class=\"header-anchor\" href=\"#maven更新镜像源\"></a>maven更新镜像源</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class=\"line\">\t          <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">\t              <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>alimaven<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t              <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">\t             <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun maven<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t             <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">\t         <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">\t          <span class=\"comment\">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>repo1<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Human Readable Name for this Mirror.<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">     </span><br><span class=\"line\">         <span class=\"comment\">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>repo2<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Human Readable Name for this Mirror.<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"RPC和MQ对比及其适用-不适用场合\"><a class=\"header-anchor\" href=\"#RPC和MQ对比及其适用-不适用场合\"></a>RPC和MQ对比及其适用/不适用场合</h2>\n<h3 id=\"系统结构\"><a class=\"header-anchor\" href=\"#系统结构\"></a>系统结构</h3>\n<p><strong>RPC系统结构：</strong><br>\nCosume &lt;=&gt; Provider<br>\nConsumer调用的Provider提供的服务</p>\n<p><strong>Message Queue系统结构：</strong><br>\nSender &lt;=&gt; Queue &lt;=&gt; Reciver<br>\nSender发送消息给Queue；Receiver从Queue拿到消息来处理。</p>\n<h3 id=\"功能的特点\"><a class=\"header-anchor\" href=\"#功能的特点\"></a>功能的特点</h3>\n<p>在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。</p>\n<h3 id=\"消息的特点\"><a class=\"header-anchor\" href=\"#消息的特点\"></a>消息的特点</h3>\n<ul>\n<li>Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。</li>\n<li>Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响</li>\n<li>Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。</li>\n<li>所以对于有同步返回需求，用Message Queue则变得麻烦了。</li>\n</ul>\n<h3 id=\"PRC的特点\"><a class=\"header-anchor\" href=\"#PRC的特点\"></a>PRC的特点</h3>\n<ul>\n<li>同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。</li>\n<li>RPC也可以是异步调用。</li>\n<li>由于等待结果，Consumer（Client）会有线程消耗。</li>\n<li>如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。</li>\n</ul>\n<h3 id=\"适用场合说明\"><a class=\"header-anchor\" href=\"#适用场合说明\"></a>适用场合说明</h3>\n<ul>\n<li>希望同步得到结果的场合，RPC合适。</li>\n<li>希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。</li>\n<li>不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。</li>\n<li>随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。</li>\n<li>这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。</li>\n</ul>\n<h3 id=\"不适用场合说明\"><a class=\"header-anchor\" href=\"#不适用场合说明\"></a>不适用场合说明</h3>\n<p>RPC同步调用使用Message Queue来传输调用信息。<br>\n发送端是在等待，同时占用一个中间点的资源，没有对等的收益。RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck5p297p20001bg0ra2esksxi","category_id":"ck5p297pv0005bg0rgp5jwo1v","_id":"ck5p297qf000abg0rzkmctm08"},{"post_id":"ck5p298j5000bbg0rmya5p4od","category_id":"ck5p297pv0005bg0rgp5jwo1v","_id":"ck5p298j9000dbg0rybat5ww0"},{"post_id":"ck5p298pn000fbg0rv1dpfjqr","category_id":"ck5p298pq000gbg0rg1mf7fmg","_id":"ck5p298pw000jbg0rhg5dhcfv"}],"PostTag":[{"post_id":"ck5p297p20001bg0ra2esksxi","tag_id":"ck5p297pz0006bg0rh30za2y4","_id":"ck5p297qe0009bg0ret7ut7dd"},{"post_id":"ck5p298j5000bbg0rmya5p4od","tag_id":"ck5p298j7000cbg0rxaqch1or","_id":"ck5p298jb000ebg0rosfy9pko"},{"post_id":"ck5p298pn000fbg0rv1dpfjqr","tag_id":"ck5p298pr000hbg0rmba0t0gh","_id":"ck5p298pt000ibg0rhm3pxtu5"}],"Tag":[{"name":"MQ","_id":"ck5p297pz0006bg0rh30za2y4"},{"name":"Netty","_id":"ck5p298j7000cbg0rxaqch1or"},{"name":"Storm","_id":"ck5p298pr000hbg0rmba0t0gh"}]}}